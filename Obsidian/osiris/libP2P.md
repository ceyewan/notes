libp2p 是一个去中心化网络框架，旨在简化分布式点对点（P2P）应用程序的构建。它通过提供一套模块化的网络组件，帮助开发者解决构建大规模、可靠和高效的 P2P 系统中的各种挑战。libp2p 使得开发者可以在多种传输协议、内容发现机制和身份验证方式中选择最适合的方案，从而构建高效、安全且具可扩展性的去中心化应用。

> [!NOTE] P2P
> P2P（Peer-to-Peer）网络是一种分布式网络架构，在这种架构中，所有参与节点（或设备）在网络中都是对等的，具备相同的权利和能力来提供服务、共享资源或交换信息。与传统的客户端-服务器（C/S）模型不同，P2P 网络没有中心化的服务器，所有节点既可以作为客户端也可以作为服务器。

## 1 Key Concepts

### 1.1 Transport

libp2p 使开发者能够灵活选择适合其应用需求的传输协议。传输协议位于网络栈的底层，libp2p 支持 TCP 和 QUIC 等协议，后者是一种基于 UDP 构建的高效传输协议，特别适合低延迟应用。当两个对等节点在互联网上建立连接时，它们将使用这些传输协议进行数据交换。

### 1.2 Stream Multiplexing

为了优化资源使用并减少高开销的连接建立操作，libp2p 支持流复用（stream multiplexing）。这意味着在同一个底层连接上，libp2p 可以并行地传输多种类型的数据。流复用通过将物理连接分解为多个逻辑流（每个流处理一种特定的数据类型）来实现，从而显著提高了网络通信效率。

### 1.3 NAT Traversal

在 P2P 网络中，节点通常处于 NAT 后面，这使得直接建立连接变得困难。libp2p 提供了几种 NAT 穿越机制，例如 NAT 打洞（hole punching）和中继（relay）。这些方法可以帮助节点绕过 NAT 限制，使得它们能够与其他节点建立直接连接，无论它们处于私有网络中的哪个位置。

### 1.4 Protocols

libp2p 提供了一个高度模块化的协议体系，允许开发者定义和使用各种协议进行数据交换。每个协议在 libp2p 中通过一个唯一的协议标识符来表示，这些协议可以是针对不同类型数据的处理规则。例如，两个对等节点 A 和 B 之间的通信可能会包括多个协议，其中 A 打开一个用于协议 xxx 的流，B 则为该协议创建处理器来接收并管理消息。通过这种机制，libp2p 支持多种数据格式和协议的并行处理。

### 1.5 Peer Identity

在去中心化的 P2P 网络中，每个节点必须具有唯一的身份。libp2p 通过对等节点 ID 来实现这一点，该 ID 是从对等节点的私钥派生出来的 multihash（多重哈希）标识符。该身份标识符是网络中对等节点的唯一证明，用于确保节点的身份在通信过程中得到验证。

### 1.6 Addressing

libp2p 使用一种称为“多地址”（multiaddress）的寻址机制，允许节点通过多个协议栈进行通信。多地址不仅仅是 IP 地址，它还可以包括传输协议、端口号以及其他上下文信息，确保节点在复杂的网络拓扑中能够正确定位。例如，一个多地址可能类似于：

```
/ip4/127.0.0.1/tcp/8080/http/my-image.png
```

这表示一个运行在本地机器（IP: 127.0.0.1）上、使用 TCP 协议、监听端口 8080 并提供 HTTP 服务的资源。

### 1.7 Security

libp2p 默认提供加密连接，确保所有节点之间的通信都是安全的。在 libp2p 中，对等节点的身份通过私钥生成的公钥进行验证，因此每个对等节点的连接都能得到加密保护。这种安全机制有效地防止了中间人攻击和未经授权的访问，保证了点对点通信的保密性和完整性。

### 1.8 Publish/Subscribe

libp2p 提供了一个高效的发布/订阅（Pub/Sub）系统，允许对等节点基于主题进行消息传递。在这种机制中，主题是用于分类和分发消息的抽象。每个主题类似于一个消息桶，节点可以订阅自己感兴趣的主题，从而接收到相关的消息。

## 2 Connecting Peers

在 libp2p 中，建立对等节点之间的连接是其核心操作之一。整个过程涉及从节点标识和寻址到协议协商、连接保护和多路复用等多个方面。以下是 libp2p 节点连接过程的详细介绍。

### 2.1 Understanding Nodes

在 libp2p 网络中，**节点**（Node）指的是网络中的单个对等体（peer），通常代表网络中的一台计算机或设备。每个节点通过与其他节点的直接连接来交换数据。通过 libp2p，节点可以作为发送者和接收者进行双向通信。

例如，以下代码片段展示了如何使用 libp2p 的默认设置创建一个节点：

```go
host, err := libp2p.New()
```

每个节点不仅需要能够唯一标识，还需要能够准确定位其他节点以建立连接。libp2p 使用 **多地址（Multiaddress）** 和 **对等标识符（Peer Identifiers）** 来分别标识节点的位置和身份。

### 2.2 Peer Identity

在 libp2p 网络中，每个节点都有一个唯一的 **peer ID**，它由节点的公钥派生而来。具体而言，peer ID 是一个 **multihash**，它实际上是公钥经过哈希处理后的结果。

-   如果公钥的字节长度超过 42 字节，libp2p 会将公钥哈希化生成 peer ID。
-   如果公钥的字节长度小于或等于 42 字节，则 peer ID 本身就是公钥，哈希函数为 **identity hash**，即输出的摘要与输入完全一致。

这种基于公钥派生的身份机制确保了每个对等节点在网络中的唯一性和不可伪造性。

### 2.3 Multiaddress

为了在 libp2p 网络中定位节点，**多地址（Multiaddress）** 机制应运而生。多地址是 libp2p 中用于描述节点位置的一个重要概念。多地址可以包含多种信息，如节点的 IP 地址、端口号以及传输协议类型（TCP、UDP、QUIC 等），甚至是 DNS 地址或加密连接的描述。

多地址的主要优势在于它的**自描述性**：只要你看到一个多地址，你就能知道这个地址涉及哪些网络协议和连接细节。

### 2.4 Establishing a connection

在 libp2p 中，节点之间的连接是通过一系列的协议协商来完成的。这一过程被称为 **连接引导**（connection bootstrapping）。连接引导的关键步骤包括：

-   **握手**：初始化与对等节点的连接，验证双方是否具备必要的协议支持。
- **安全协议协商**：确保连接的安全性，通常通过协商加密协议（如 TLS 或 Noise 协议）来保护数据传输。
- **流复用协议**：协商流复用器，允许在同一连接上同时传输多个不同类型的数据流。

需要注意的是，libp2p 强制要求所有连接都必须经过加密，并且支持流复用。未加密或未复用的连接是不可用的。

### 2.5 Handshake

连接引导过程中的第一步是 **握手**，它确保了两个对等节点能够成功建立连接并且理解彼此所支持的协议。具体来说，libp2p 使用 **multistream-select** 协议来进行版本协商。

握手的过程如下所示：
```
# Request: Do you understand "/multistream/1.0.0"?
> /multistream/1.0.0

# Response: I do.
+ /multistream/1.0.0
```

通过这种方式，节点能够确认对方是否支持多流协议（multistream），从而为后续的协议协商做准备。
### 2.6 Security

在握手成功后，两个对等节点将协商安全协议，以确保连接是加密的并且数据传输安全。libp2p 会根据预定的优先级依次尝试不同的加密协议。例如，首先尝试使用 **TLS**，如果对方不支持 TLS，则切换到 **Noise** 协议。

安全协议的协商示例如下：
```
# Request: Do you understand "/tls/1.0.0"?
> /tls/1.0.0

# Response: I do not
+ na

# Request: Do you understand "/noise/1.0.0"?
> /noise/1.0.0

# Response: I do
+ /noise/1.0.0
```

这种多层协议的选择机制确保了连接始终能够得到合适的加密保护。
### 2.7 Multiplexer

连接保护后，libp2p 会继续协商一个 **多路复用器协议**，这一协议允许在单一连接上承载多个逻辑流。每个流都代表了一个特定的协议数据交换，例如 DHT 操作或 ping 请求。

这种流复用的机制使得 libp2p 能够在同一连接上同时处理不同类型的数据交互，大大提高了效率。每个流会被分配一个唯一的 **流 ID**，这样即便是同一连接上的数据也能被正确区分和处理。

以下是一个流复用的示意图，展示了在同一连接上同时处理不同协议的数据流：

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217104752.png)

### 2.8 Negotiating protocols

一旦连接建立，节点将交换支持的 **应用协议**。每个协议都通过协议标识符进行标识，并且需要经过 **multistream-select** 协议的协商过程。协议标识符会发送给对等方，若对方不支持某个协议，则会返回 **na**（Not Available）响应。

当某个协议被接受后，libp2p 会为该协议分配一个 **处理器（Handler）**，用于管理该协议的数据流和交换。这样，不同的应用协议可以在同一连接上并行处理。
### 2.9 Peer Discovery

除了通过 peer ID 唯一标识对等节点外，libp2p 还需要通过 **对等发现（Peer Discovery）** 来查找网络中的其他节点。libp2p 提供了两种接口来实现这一目标：**Advertiser** 和 **Discoverer**。

- **Advertiser** 允许节点将自己的服务公开到网络中，通常通过广播自己的协议支持情况。
- **Discoverer** 则帮助节点找到其他对等节点，常见的实现方法包括 **mDNS** 和 **Kademlia DHT**。Kademlia DHT 用于在 IPFS 网络中发现对等节点，而 mDNS 则用于局域网中的对等节点发现。

## 3 The Distributed Hash Table

### 3.1 Introduction

Kademlia 分布式哈希表在 libp2p 中用于提供对等节点发现和内容路由。简单来说，哈希表是一组记录，每条记录包含一个 `key -> value` 映射。在分布式哈希表中，记录分布在网络中，这意味着每个节点持有记录的子集。

在查找特定记录时，我们没有集中式的注册表；因此，我们必须向网络中的对等节点询问，直到找到该记录。然而，这种搜索并不是随机的，而是由 DHT 距离度量引导的。

### 3.2 The Distance Metric

哈希表提供的主要操作是通过其键检索值。为了决定谁存储哪些键，键会被哈希并与其 PeerIDs（已经是哈希值）进行比较，这使得 DHT 能够计算距离度量。距离度量表示两个 ID 之间的距离；因此，这是一个逻辑距离，而不是物理距离。DHT 距离允许对等节点分类键的“接近”程度，并且只接受存储与其接近的键。因此，在 DHT 上存储内容涉及找到一个足够接近该键的节点。

密钥与对等方的接近程度通过距离函数（即 `distance(key_id, peer_id)` ）计算，该函数对 ID 应用 XOR 操作。XOR 结果转换为整数以量化 ID 之间的距离。例如， `distance(key1, peer9) = 4` 表示 `peer9` 对等方与 `key1` 密钥之间的距离为 `4` 。

关于距离函数的数学解释并不简单，而且超出了本次讲座的内容。

### 3.3 The Routing Table

距离度量不仅可以计算键和对等 ID 之间的距离，还可以计算对等 ID 之间的距离。为了便于在网络中发现对等节点（即能够回答 `FIND_NODES` 操作），一个对等节点会维护一个根据与它们的距离划分的对等节点列表。近距离的桶更大。因此，一个节点可能不会存储某个键，但它通常能够提供一个已知节点列表，这些节点比它自己更接近该键，从而帮助查找最近的节点。

### 3.4 DHT Operations

libp2p DHT 基于 Kademlia DHT，因此它包含了其大部分核心概念，并添加了一些额外功能。节点使用 libp2p 流进行通信。协议提供的操作包括：

- `FIND_NODE` : 给定一个键，找到最接近该键的节点。
- `PUT_VALUE` : 在 DHT 中添加一个 `key -> value` 映射。
- `GET_VALUE` : 给定一个键，找到对应的值。
- `ADD_PROVIDERS` : 在网络中宣传某个对等节点正在提供给定的密钥。
- `GET_PROVIDERS` : 查找为给定键提供值的对等方。

### 3.5 Find the Closest Nodes

`FIND_NODE` 操作返回给定键的 k 个最近节点。

对等节点的近邻节点保存在路由表中。为了找到对等节点与特定键最接近的节点，我们首先计算每个近邻节点与键的距离（即， `distance(close_peer, key)` ）。然后，我们选取距离最小的节点。

因为一个节点可能有许多邻近节点，所以使用一个参数 `k` 来限制我们应该考虑的节点数量。例如，如果 `k = 4` ，我们应该只考虑与键距离最近的四个节点。

1. `Peer 1` 有四个亲密的对等节点，这些节点存储在其路由表中。
2. `FIND_NODE(key1)` 操作返回距离 `key1` 键最近的 k 个节点。计算每个接近对等节点与键之间的距离（即 `distance(close_peer, key1)` ）。然后，选择距离最小的 k 个节点（在示例中， `k = 2` ）。

