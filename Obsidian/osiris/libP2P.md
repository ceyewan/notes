libp2p 是一个去中心化网络框架，旨在简化分布式点对点（P2P）应用程序的构建。它通过提供一套模块化的网络组件，帮助开发者解决构建大规模、可靠和高效的 P2P 系统中的各种挑战。libp2p 使得开发者可以在多种传输协议、内容发现机制和身份验证方式中选择最适合的方案，从而构建高效、安全且具可扩展性的去中心化应用。

> [!NOTE] P2P
> P2P（Peer-to-Peer）网络是一种分布式网络架构，在这种架构中，所有参与节点（或设备）在网络中都是对等的，具备相同的权利和能力来提供服务、共享资源或交换信息。与传统的客户端-服务器（C/S）模型不同，P2P 网络没有中心化的服务器，所有节点既可以作为客户端也可以作为服务器。

## 1 Key Concepts

### 1.1 Transport

libp2p 使开发者能够灵活选择适合其应用需求的传输协议。传输协议位于网络栈的底层，libp2p 支持 TCP 和 QUIC 等协议，后者是一种基于 UDP 构建的高效传输协议，特别适合低延迟应用。当两个对等节点在互联网上建立连接时，它们将使用这些传输协议进行数据交换。

### 1.2 Stream Multiplexing

为了优化资源使用并减少高开销的连接建立操作，libp2p 支持流复用（stream multiplexing）。这意味着在同一个底层连接上，libp2p 可以并行地传输多种类型的数据。流复用通过将物理连接分解为多个逻辑流（每个流处理一种特定的数据类型）来实现，从而显著提高了网络通信效率。

### 1.3 NAT Traversal

在 P2P 网络中，节点通常处于 NAT 后面，这使得直接建立连接变得困难。libp2p 提供了几种 NAT 穿越机制，例如 NAT 打洞（hole punching）和中继（relay）。这些方法可以帮助节点绕过 NAT 限制，使得它们能够与其他节点建立直接连接，无论它们处于私有网络中的哪个位置。

### 1.4 Protocols

libp2p 提供了一个高度模块化的协议体系，允许开发者定义和使用各种协议进行数据交换。每个协议在 libp2p 中通过一个唯一的协议标识符来表示，这些协议可以是针对不同类型数据的处理规则。例如，两个对等节点 A 和 B 之间的通信可能会包括多个协议，其中 A 打开一个用于协议 xxx 的流，B 则为该协议创建处理器来接收并管理消息。通过这种机制，libp2p 支持多种数据格式和协议的并行处理。

### 1.5 Peer Identity

在去中心化的 P2P 网络中，每个节点必须具有唯一的身份。libp2p 通过对等节点 ID 来实现这一点，该 ID 是从对等节点的私钥派生出来的 multihash（多重哈希）标识符。该身份标识符是网络中对等节点的唯一证明，用于确保节点的身份在通信过程中得到验证。

### 1.6 Addressing

libp2p 使用一种称为“多地址”（multiaddress）的寻址机制，允许节点通过多个协议栈进行通信。多地址不仅仅是 IP 地址，它还可以包括传输协议、端口号以及其他上下文信息，确保节点在复杂的网络拓扑中能够正确定位。例如，一个多地址可能类似于：

```
/ip4/127.0.0.1/tcp/8080/http/my-image.png
```

这表示一个运行在本地机器（IP: 127.0.0.1）上、使用 TCP 协议、监听端口 8080 并提供 HTTP 服务的资源。

### 1.7 Security

libp2p 默认提供加密连接，确保所有节点之间的通信都是安全的。在 libp2p 中，对等节点的身份通过私钥生成的公钥进行验证，因此每个对等节点的连接都能得到加密保护。这种安全机制有效地防止了中间人攻击和未经授权的访问，保证了点对点通信的保密性和完整性。

### 1.8 Publish/Subscribe

libp2p 提供了一个高效的发布/订阅（Pub/Sub）系统，允许对等节点基于主题进行消息传递。在这种机制中，主题是用于分类和分发消息的抽象。每个主题类似于一个消息桶，节点可以订阅自己感兴趣的主题，从而接收到相关的消息。

## 2 Connecting Peers

在 libp2p 中，建立对等节点之间的连接是其核心操作之一。整个过程涉及从节点标识和寻址到协议协商、连接保护和多路复用等多个方面。以下是 libp2p 节点连接过程的详细介绍。

### 2.1 Understanding Nodes

在 libp2p 网络中，**节点**（Node）指的是网络中的单个对等体（peer），通常代表网络中的一台计算机或设备。每个节点通过与其他节点的直接连接来交换数据。通过 libp2p，节点可以作为发送者和接收者进行双向通信。

例如，以下代码片段展示了如何使用 libp2p 的默认设置创建一个节点：

```go
host, err := libp2p.New()
```

每个节点不仅需要能够唯一标识，还需要能够准确定位其他节点以建立连接。libp2p 使用 **多地址（Multiaddress）** 和 **对等标识符（Peer Identifiers）** 来分别标识节点的位置和身份。

### 2.2 Peer Identity

在 libp2p 网络中，每个节点都有一个唯一的 **peer ID**，它由节点的公钥派生而来。具体而言，peer ID 是一个 **multihash**，它实际上是公钥经过哈希处理后的结果。

-   如果公钥的字节长度超过 42 字节，libp2p 会将公钥哈希化生成 peer ID。
-   如果公钥的字节长度小于或等于 42 字节，则 peer ID 本身就是公钥，哈希函数为 **identity hash**，即输出的摘要与输入完全一致。

这种基于公钥派生的身份机制确保了每个对等节点在网络中的唯一性和不可伪造性。

### 2.3 Multiaddress

为了在 libp2p 网络中定位节点，**多地址（Multiaddress）** 机制应运而生。多地址是 libp2p 中用于描述节点位置的一个重要概念。多地址可以包含多种信息，如节点的 IP 地址、端口号以及传输协议类型（TCP、UDP、QUIC 等），甚至是 DNS 地址或加密连接的描述。

多地址的主要优势在于它的**自描述性**：只要你看到一个多地址，你就能知道这个地址涉及哪些网络协议和连接细节。

### 2.4 Establishing a connection

在 libp2p 中，节点之间的连接是通过一系列的协议协商来完成的。这一过程被称为 **连接引导**（connection bootstrapping）。连接引导的关键步骤包括：

-   **握手**：初始化与对等节点的连接，验证双方是否具备必要的协议支持。
- **安全协议协商**：确保连接的安全性，通常通过协商加密协议（如 TLS 或 Noise 协议）来保护数据传输。
- **流复用协议**：协商流复用器，允许在同一连接上同时传输多个不同类型的数据流。

需要注意的是，libp2p 强制要求所有连接都必须经过加密，并且支持流复用。未加密或未复用的连接是不可用的。

### 2.5 Handshake

连接引导过程中的第一步是 **握手**，它确保了两个对等节点能够成功建立连接并且理解彼此所支持的协议。具体来说，libp2p 使用 **multistream-select** 协议来进行版本协商。

握手的过程如下所示：
```
# Request: Do you understand "/multistream/1.0.0"?
> /multistream/1.0.0

# Response: I do.
+ /multistream/1.0.0
```

通过这种方式，节点能够确认对方是否支持多流协议（multistream），从而为后续的协议协商做准备。
### 2.6 Security

在握手成功后，两个对等节点将协商安全协议，以确保连接是加密的并且数据传输安全。libp2p 会根据预定的优先级依次尝试不同的加密协议。例如，首先尝试使用 **TLS**，如果对方不支持 TLS，则切换到 **Noise** 协议。

安全协议的协商示例如下：
```
# Request: Do you understand "/tls/1.0.0"?
> /tls/1.0.0

# Response: I do not
+ na

# Request: Do you understand "/noise/1.0.0"?
> /noise/1.0.0

# Response: I do
+ /noise/1.0.0
```

这种多层协议的选择机制确保了连接始终能够得到合适的加密保护。
### 2.7 Multiplexer

连接保护后，libp2p 会继续协商一个 **多路复用器协议**，这一协议允许在单一连接上承载多个逻辑流。每个流都代表了一个特定的协议数据交换，例如 DHT 操作或 ping 请求。

这种流复用的机制使得 libp2p 能够在同一连接上同时处理不同类型的数据交互，大大提高了效率。每个流会被分配一个唯一的 **流 ID**，这样即便是同一连接上的数据也能被正确区分和处理。

以下是一个流复用的示意图，展示了在同一连接上同时处理不同协议的数据流：

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217104752.png)

### 2.8 Negotiating protocols

一旦连接建立，节点将交换支持的 **应用协议**。每个协议都通过协议标识符进行标识，并且需要经过 **multistream-select** 协议的协商过程。协议标识符会发送给对等方，若对方不支持某个协议，则会返回 **na**（Not Available）响应。

当某个协议被接受后，libp2p 会为该协议分配一个 **处理器（Handler）**，用于管理该协议的数据流和交换。这样，不同的应用协议可以在同一连接上并行处理。
### 2.9 Peer Discovery

除了通过 peer ID 唯一标识对等节点外，libp2p 还需要通过 **对等发现（Peer Discovery）** 来查找网络中的其他节点。libp2p 提供了两种接口来实现这一目标：**Advertiser** 和 **Discoverer**。

- **Advertiser** 允许节点将自己的服务公开到网络中，通常通过广播自己的协议支持情况。
- **Discoverer** 则帮助节点找到其他对等节点，常见的实现方法包括 **mDNS** 和 **Kademlia DHT**。Kademlia DHT 用于在 IPFS 网络中发现对等节点，而 mDNS 则用于局域网中的对等节点发现。

## 3 The Distributed Hash Table

### 3.1 Introduction

在 libp2p 中，**Kademlia 分布式哈希表（DHT）** 用于 **对等节点发现** 和 **内容路由**。简而言之，DHT 是一种去中心化的键值存储系统，其中每条记录表示一个 key -> value 映射。DHT 中的记录分布在整个网络中，每个对等节点持有部分记录。

当需要查找某个特定记录时，系统并没有集中式的目录服务；相反，必须通过向网络中的其他对等节点查询来完成查找。这个查询过程并非随机进行，而是通过 **距离度量** 来引导，确保高效地找到目标记录。

### 3.2 The Distance Metric

DHT 中的核心操作是根据 **键**（key）来检索对应的 **值**（value）。为了决定哪些对等节点负责哪些键，DHT 使用 **距离度量**，通过对键和对等节点 ID 进行哈希处理并使用 **异或（XOR）** 操作来计算距离。距离的计算公式如下：

```
distance(key_id, peer_id) = XOR(key_id, peer_id)
```

该距离值是逻辑距离而非物理距离，它通过 XOR 计算生成一个数值，表示两个 ID 之间的距离。例如，如果 distance(key1, peer9) = 4，表示 peer9 对等节点与 key1 键之间的距离为 4。

XOR 距离度量帮助 DHT 确定键与对等节点之间的接近程度，从而实现对键的高效路由和存储。虽然 XOR 距离的数学解释较为复杂，但它在保证 DHT 的去中心化和扩展性方面至关重要。
### 3.3 The Routing Table

每个节点在 DHT 中维护一个 **路由表**，这个路由表记录了与本节点 ID 距离最接近的对等节点。为了加速查找过程，路由表将对等节点划分为多个 **桶**，每个桶包含距离本节点 ID 特定距离范围内的对等节点。离本节点 ID 更近的桶包含的对等节点较多。

这种基于距离的组织方式，使得节点能够快速找到与特定键最接近的对等节点。如果一个节点无法存储某个键，它通常能够返回一个接近该键的节点列表，帮助继续查找目标节点。Kademlia DHT 确保每个节点只存储与自己 ID 接近的键，因此每个节点的存储负载与其 ID 的位置密切相关。
### 3.4 DHT Operations

libp2p DHT 基于 Kademlia 协议，提供了若干核心操作，这些操作实现了键值存储和对等节点发现。主要操作包括：

- `FIND_NODE` : 根据给定的键，查找与该键最接近的对等节点。该操作用于查找目标键。
- `PUT_VALUE` : 在 DHT 中添加一个 key -> value 映射。值将被存储在离该键最近的节点上。
- `GET_VALUE` : 根据给定的键，查找并返回对应的值。该操作通过查找与键最接近的节点来获取值。
- `ADD_PROVIDERS` : 在网络中公告某个节点正在提供特定键的值。此操作用于内容广告。
- `GET_PROVIDERS` : 查找哪些对等节点正在提供特定键对应的值。此操作用于内容的发现。

### 3.5 Find the Closest Nodes

**FIND_NODE** 操作返回与给定键最接近的 k 个节点。

该操作利用路由表来寻找离目标键最接近的节点。具体来说，DHT 计算每个节点与目标键之间的距离（即通过 XOR 距离函数），然后选取距离最小的节点。为确保高效查询，使用参数 k 来限制返回的节点数量。例如，当 k = 4 时，系统只会返回离目标键最近的四个节点。

查询过程如下：

1. **Peer 1** 维护着与它最近的对等节点列表。
2. 执行 **FIND_NODE(key1)** 操作，计算每个节点与 key1 的距离，选取离目标键最近的 k 个节点（例如，选取与键距离最近的 2 个节点）。
### 3.6 Value Storage

在 DHT 中存储值时，使用 **PUT_VALUE** 操作。首先，DHT 会为键计算一个 ID，并根据该键 ID 与对等节点 ID 的距离来确定哪个节点负责存储该键。

存储过程如下：

1. **Peer 1** 想要存储一个新键。它首先执行 **FIND_NODE(key)** 操作，找到离该键最近的 k 个节点。
2. 在找到离键最接近的节点后，节点继续查询其邻近节点，直到找到最接近该键的节点。
3. 节点将该键值对存储在最接近的节点上。

由于每个节点只存储与自己 ID 最接近的键，因此有可能存在多个节点存储相同的键。这种冗余性提高了系统的可用性，但也可能导致一致性问题，因此需要适当的验证策略。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217113531.png)
### 3.7 Value Retrieval

为了检索某个特定键的值，使用 **GET_VALUE** 操作。该操作的过程是通过多轮迭代，在网络中查找存储该键的节点。

检索过程如下：

1. **Peer 1** 发起 **FIND_NODE(key1)** 操作。
2. 它查询与键最接近的节点（如 Peer 2 和 Peer 3），计算每个节点与键之间的距离，选出最接近的节点。
3. 该过程继续向网络中的邻近节点发起请求，直到找到存储该键的节点（例如 Peer 10）。
4. **Peer 10** 返回与该键对应的值。

由于可能有多个节点存储相同的键，因此可能会遇到值不一致的情况，这时需要验证策略来保证值的正确性。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217121142.png)
### 3.8 Advertising Content

除了通过 **GET_VALUE** 操作检索值，DHT 还提供了 **ADD_PROVIDER** 和 **GET_PROVIDERS** 操作，用于内容的广告和查找。这些操作对于分布式文件系统（例如 IPFS）尤其重要。

- **ADD_PROVIDER**：此操作由一个节点发起，用来宣布该节点正在提供特定内容（如 CID）。默认情况下，该记录在 24 小时后过期。
- **GET_PROVIDERS**：此操作查询哪些对等节点正在提供某个特定内容。

在 IPFS 中，**GET_PROVIDERS** 用于查找哪些节点提供特定的文件（由 CID 标识），而 **GET_VALUE** 是一种通用的 Kademlia 协议操作，用于查询存储在 DHT 中的任意键值。