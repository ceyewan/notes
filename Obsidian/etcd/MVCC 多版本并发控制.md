# MVCC 多版本并发控制

## 1 **MVCC 基础概念**

### 1.1 **什么是 MVCC？**

**多版本并发控制（Multi-Version Concurrency Control，MVCC）** 是一种用于数据库管理系统的并发控制机制，旨在提高系统的并发性能，特别是在读多写少的场景下。MVCC 的核心思想是通过维护数据的多个版本来实现并发操作，而不是通过传统的锁机制来限制对数据的访问。

与 **锁机制（Lock-Based）** 的并发控制相比，MVCC 的主要区别在于它允许多个事务同时读取数据，而不会相互阻塞。在锁机制中，读写操作通常需要互斥，即读操作会阻塞写操作，写操作也会阻塞读操作。而 MVCC 通过为每个事务提供数据的一个快照（Snapshot），使得读操作不会阻塞写操作，写操作也不会阻塞读操作。

MVCC 的核心目标是 **实现高并发读写，避免读写冲突**，从而提升系统的整体性能。

### 1.2 **MVCC 解决了什么问题？**

MVCC 主要解决了以下几个问题：

1. **读写操作之间的阻塞问题**：在传统的锁机制中，读写操作通常会相互阻塞。MVCC 通过为每个事务提供数据的一个快照，使得读操作不会阻塞写操作，写操作也不会阻塞读操作，从而提高了系统的并发性能。
2. **事务隔离性**：MVCC 能够实现不同的事务隔离级别，如 MySQL 中的 **REPEATABLE READ**。通过 MVCC，事务可以看到一个一致的数据视图，即使在事务执行期间其他事务对数据进行了修改。
3. **数据版本历史追溯**：MVCC 通过维护数据的多个版本，使得系统能够追溯数据的历史状态。这在某些场景下非常有用，例如 etcd 的 **Watch 机制**，可以监控键值对的变化历史。

> [!NOTE] REPEATABLE READ
> **REPEATABLE READ** 是 MySQL 默认的事务隔离级别，它通过 MVCC（多版本并发控制）机制确保在同一个事务中多次读取同一数据时，结果是一致的，即使其他事务在此期间修改了这些数据。它避免了脏读和不可重复读，并通过 **Next-Key Locking**（间隙锁）部分避免了幻读。然而，这种隔离级别可能会带来锁争用和存储开销，尤其是在长事务场景下。

### 1.3 **核心组成要素**

MVCC 的实现依赖于以下几个核心组成要素：

1. **版本号（Version/Timestamp）**：每个数据版本都有一个唯一的版本号或时间戳，用于标识该版本的创建时间或事务 ID。版本号通常由系统自动生成，并随着事务的提交而递增。
2. **数据快照（Snapshot）**：MVCC 为每个事务提供一个数据快照，该快照包含了事务开始时数据库中所有数据的可见版本。事务在读取数据时，只能看到快照中的数据，而不会受到其他事务修改的影响。
3. **可见性规则（Visibility Rules）**：MVCC 通过可见性规则来确定哪些数据版本对当前事务是可见的。通常，事务只能看到在它开始之前已经提交的数据版本，而看不到未提交的或在其开始之后提交的数据版本。
4. **垃圾回收机制（旧版本数据清理）**：由于 MVCC 会保留数据的多个版本，随着时间的推移，旧版本的数据可能会占用大量存储空间。因此，MVCC 需要一种垃圾回收机制来定期清理不再需要的旧版本数据，以防止存储空间的无限膨胀。

---

## 2 **MVCC 在 MySQL 中的实现**

1. **核心机制**
    - 通过 **Undo Log** 存储历史版本
    - **Read View** 控制事务可见性
    - 版本链（Row Version Chain）的构建与遍历
2. **与事务隔离级别的关系**
    - REPEATABLE READ 的实现细节
    - 如何避免幻读（Phantom Read）
3. **关键数据结构**
    - 隐藏字段：`DB_TRX_ID`（事务 ID）、`DB_ROLL_PTR`（回滚指针）
    - Undo Log 的结构与生命周期

---

## 3 **MVCC 在 Etcd 中的实现**

1. **设计目标与场景**
    - 分布式协调系统的需求（高可用、强一致性）
    - Watch 机制与历史版本查询
2. **核心机制**
    - 基于 **键值存储的版本化设计**
    - 全局单调递增的版本号（Revision）
    - 数据存储结构（B+ 树或 BoltDB 的优化）
3. **版本压缩与清理**
    - Compact 操作的作用（防止存储膨胀）
    - 如何保留历史版本窗口？

---

## 4 **MySQL Vs Etcd 的 MVCC 对比**

| **特性**         | **MySQL**                      | **etcd**                               |
| ---------------- | ------------------------------ | -------------------------------------- |
| **目标场景**     | 关系型事务处理（OLTP）         | 分布式系统协调、配置管理               |
| **版本存储**     | Undo Log + 行版本链            | 全局版本号 + 键值历史版本存储          |
| **隔离性实现**   | 通过 Read View 控制事务可见性  | 基于版本号的线性一致性（Linearizable） |
| **垃圾回收**     | 后台 Purge 线程清理 Undo Log   | Compact 操作手动/自动触发              |
| **版本查询能力** | 有限（依赖 Undo Log 保留时间） | 直接通过版本号访问历史数据             |

---

## 5 **MVCC 的优缺点**

1. **优势**
    - 提升并发性能（减少锁竞争）
    - 支持非阻塞读取
    - 天然支持数据历史版本（如审计、回滚）
2. **局限性**
    - 存储空间开销（需保留多版本数据）
    - 垃圾回收机制的设计复杂度
    - 对长事务的敏感性（如 MySQL 的 Undo Log 膨胀）

---

## 6 **应用场景**

1. **适合使用 MVCC 的场景**
    - 高并发读多写少的系统（如电商库存）
    - 需要事务隔离性的数据库
    - 分布式系统状态同步（如 Kubernetes 使用 etcd）
2. **不适用场景**
    - 写密集型系统（版本管理开销过大）
    - 对实时一致性要求极高的场景

---
