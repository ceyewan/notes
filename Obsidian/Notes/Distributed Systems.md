## 1 Introduction

这本书作者写于 2013 年，所以有些内容可能有点过时，有些新技术可能没有涉及。

分布式编程大部分时候都是在处理分布式以下的两个后果：
- 信息以光速传播
- 独立的事物会独立失败

本文分为五个章节，分别是基础知识、抽象层次、时间及顺序、复制：防止分歧、复制：接受分歧。

## 2 Distributed systems at a high level

分布式编程是使用多台计算机来解决可以在一台计算机上解决的同一问题的艺术。每台计算机上都要执行**存储**和**计算**两个基本任务。

### 2.1 Scalability

> 可拓展性是系统、网络或进程以有效的方式处理不断增长的工作量的能力，或者是扩大其规模以适应这种增长的能力。

- **规模可拓展性**：添加更多节点应该使系统线性更快​​；增加数据集不应增加延迟。
- **地理可拓展性**：应该可以使用多个数据中心来减少响应用户查询所需的时间，同时以某种合理的方式处理跨数据中心的延迟。
- **管理可拓展性**：添加更多节点不应增加系统的管理成本（例如管理员与机器的比率）。

### 2.2 Performance（latency）

> 性能是计算机系统完成的有用工作量与所使用的时间和资源的比较。可能会涉及：
> - 响应时间（延迟）
> - 高吞吐量
> - 计算资源利用率低

针对这些方面优化都需要权衡，例如，大批量可以实现高吞吐量，但是由于批处理，响应时间会更长。

### 2.3 Availability（fault tolerance）

> 可用性是系统处于正常运行状态的时间比例。如果用户无法访问系统，则称该系统不可用。分布式系统采用一堆不可靠的组件，并在它们之上构建一个**可靠**的系统。主要是通过**容错技术**来保证的。

### 2.4 限制

分布式系统受到两个物理因素的约束：
- 节点数量（随着所需存储和计算能力的增加而增加）
- 节点之间的距离（信息最多以光速传播）

独立节点数量的增加会增加系统发生故障的可能性（降低可用性并增加管理成本）；

独立节点数量的增加可能会增加节点之间通信的需求（随着规模的增加而降低性能）；

地理距离的增加会增加远程节点之间通信的最小延迟（降低某些操作的性能）。

### 2.5 Abstractions and models

抽象通过消除与解决问题无关的现实世界方面使事情更易于管理。模型以精确的方式描述分布式系统的关键属性。
- 系统模型（异步、同步）
- 故障模型（崩溃-故障、分区、拜占庭）
- 一致性模型（强一致性、最终一致性）

### 2.6 Design techniques：partition and replicate

抽象通过消除与解决问题无关的现实世界方面使事情更易于管理。模型以精确的方式描述分布式系统的关键属性。有两种可应用于数据集的基本技术。它可以分为多个节点（**分区**）以允许更多并行处理。它还可以复制或缓存在不同的节点上，以减少客户端和服务器之间的距离并提高容错能力（**复制**）。

#### 2.6.1 分区

分区是将数据集划分为较小的不同独立集合以减少数据集增长的影响，因为每个分区都是数据的子集。通过限制要处理的数据量并将相关数据定位在同一分区中来提高性能。

#### 2.6.2 复制

复制是在多台机器上复制相同的数据；这允许更多的服务器参与计算。是抵抗延迟的主要方式。
- **提高性能**：通过在多台机器上复制相同的数据，允许更多的服务器参与计算，从而减少延迟。
- **增强可用性**：通过创建数据的多个副本，提高系统的可用性，并增加在节点失败前系统能容忍的节点数量。

复制也带来了新的挑战。
- **同步问题**：多个独立的副本需要保持一致性，确保数据在不同机器上同步。
- **一致性模型的选择**：一致性模型决定了如何保证数据的同步与一致性，并影响系统的可用性与延迟。

>**强一致性**指的是在分布式系统中，所有节点的状态在任何时刻都是一致的。当一个写操作完成后，所有后续的读操作都能看到这个更新，且不会返回过时的数据。它通常通过锁或同步机制来确保，保证了数据的一致性，但代价是可能会引入较高的延迟。强一致性确保了数据的准确性，但在网络故障或高延迟环境下可能会影响系统的可用性。
  **弱一致性**则表示系统在某些时间点可能存在不同步的状态，允许节点之间的数据在短时间内处于不一致的状态。即便某个节点的更新没有被立即同步到其他节点，系统仍然认为是正常的，最终一致性通常在这种情况下得到保证。弱一致性强调高可用性和性能，通常适用于对一致性要求不高、容忍暂时数据不一致的场景，如社交媒体应用、缓存系统等。

## 3 Time and order

