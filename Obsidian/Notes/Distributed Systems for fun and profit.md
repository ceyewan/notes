## 1 Introduction

这本书作者写于 2013 年，所以有些内容可能有点过时，有些新技术可能没有涉及。

分布式编程大部分时候都是在处理分布的两个后果的影响：
- 信息以光速传播
- 独立的事物会独立失败

即分布式编程的核心是处理**距离**和**存在多个事物**。

本文分为五个章节，分别是基础知识（可拓展性、可用性、性能、延迟和容错等）、抽象层次的上下变化（抽象概念和不可能性结果、CAP 定理）、时间及顺序、复制：防止分歧（2PC 和 paxos）、复制：接受分歧（弱一致性）。

## 2 Distributed systems at a high level 分布式系统概述

分布式编程是使用多台计算机来解决可以在一台计算机上解决的同一问题的艺术。每台计算机上都要执行**存储**和**计算**两个基本任务。

如果有无限的资源，那么可以设计一台计算机完成计算，但是很少人拥有无限资源，现实中，最佳实践是使用中端的通用硬件并使用**容错技术**将维护成本保持在较低水平。

### 2.1 Scalability

> 可拓展性是系统、网络或进程以有效的方式处理不断增长的工作量的能力，或者是扩大其规模以适应这种增长的能力。

- **规模可拓展性**：添加更多节点应该使系统线性更快​​；增加数据集不应增加延迟。
- **地理可拓展性**：应该可以使用多个数据中心来减少响应用户查询所需的时间，同时以某种合理的方式处理跨数据中心的延迟。
- **管理可拓展性**：添加更多节点不应增加系统的管理成本（例如管理员与机器的比率）。

一个可扩展的系统是指随着规模的增加仍能满足其用户需求的系统。我们需要特别关心性能和可用性这两个方面。

### 2.2 Performance（latency）

> 性能是指计算机系统完成的有用工作量与其所使用的时间和资源相比的特征。可能会涉及：
> - 短响应时间（低延迟）
> - 高吞吐量
> - 低的计算资源利用率

针对这些方面优化都需要权衡，例如，系统可以通过处理更大的工作批次来提高吞吐量，从而减少操作开销。权衡则是由于批处理而导致单个工作单元的响应时间变长。

延迟指的是从某事开始到发生之间的一段时期，即是事件发生与产生可见影响之间的时间。在分布式系统中，存在一个无法克服的最小延迟：光速限制了信息传播的速度，硬件执行一次操作都会产生最小的延迟成本。

### 2.3 Availability（fault tolerance）

> 可用性是系统处于正常运行状态的时间比例。如果用户无法访问系统，则称该系统不可用。分布式系统采用一堆不可靠的组件，并在它们之上构建一个**可靠**的系统。主要是通过**容错技术**来保证的。

### 2.4 What prevents us

分布式系统受到两个物理因素的约束：
- 节点数量（随着所需存储和计算能力的增加而增加）
- 节点之间的距离（信息最多以光速传播）

独立节点数量的增加会增加系统发生故障的可能性（降低可用性并增加管理成本）；

独立节点数量的增加会增加节点之间通信的需求（随着规模的增加而降低性能）；

地理距离的增加会增加远程节点之间通信的最小延迟（降低某些操作的性能）。

### 2.5 Abstractions and models

抽象通过消除与解决问题无关的现实世界方面使事情更易于管理。模型以精确的方式描述分布式系统的关键属性。下一章将讨论许多类型的模型：
- 系统模型（异步、同步）
- 故障模型（崩溃-故障、分区、拜占庭）
- 一致性模型（强一致性、最终一致性）

### 2.6 Design techniques：partition and replicate 分区与复制

抽象通过消除与解决问题无关的现实世界方面使事情更易于管理。模型以精确的方式描述分布式系统的关键属性。

有两种可应用于数据集的基本技术。它可以分为多个节点（**分区**）以允许更多并行处理。它还可以复制或缓存在不同的节点上，以减少客户端和服务器之间的距离并提高容错能力（**复制**）。下图中的 A 和 B 被划分为独立的集合，而 C 被复制到多个位置。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250212132639.png)


#### 2.6.1 分区

分区是将数据集划分为较小的不同独立集合以减少数据集增长的影响，因为每个分区都是数据的子集。
- 分区通过限制要处理的数据量并将相关数据定位在同一分区中来提高性能。
- 分区通过允许分区独立故障来提高可用性，增加在牺牲可用性之前需要故障的节点数量。

#### 2.6.2 复制

复制是在多台机器上制作相同数据的副本；这允许更多的服务器参与计算。是抵抗延迟的主要方式。
- **提高性能**：通过在多台机器上复制相同的数据，允许更多的服务器参与计算，从而减少延迟。
- **增强可用性**：复制通过创建数据的额外副本提高了可用性，增加了在牺牲可用性之前需要失败的节点数量。

复制也带来了新的挑战。
- **同步问题**：多个独立的副本需要保持一致性，确保数据在不同机器上同步。
- **一致性模型的选择**：一致性模型决定了如何保证数据的同步与一致性，并影响系统的可用性与延迟。

>**强一致性**指的是在分布式系统中，所有节点的状态在任何时刻都是一致的。当一个写操作完成后，所有后续的读操作都能看到这个更新，且不会返回过时的数据。它通常通过锁或同步机制来确保，保证了数据的一致性，但代价是可能会引入较高的延迟。强一致性确保了数据的准确性，但在网络故障或高延迟环境下可能会影响系统的可用性。
  **弱一致性**则表示系统在某些时间点可能存在不同步的状态，允许节点之间的数据在短时间内处于不一致的状态。即便某个节点的更新没有被立即同步到其他节点，系统仍然认为是正常的，最终一致性通常在这种情况下得到保证。弱一致性强调高可用性和性能，通常适用于对一致性要求不高、容忍暂时数据不一致的场景，如社交媒体应用、缓存系统等。

## 3 Up and down the level of abstraction

在本章中，我们将上下探索抽象层次，查看一些不可能性结果（CAP 和 FLP），然后为了性能再返回较低层次。

抽象本质上是虚假的，因为每种情况都是独一无二的，但是抽象使得世界变得可以管理。

### 3.1 A system model

分布式系统的一个关键特性是分布式，即分布式系统中的程序：
- 在独立节点上并行的运行
- 通过网络连接（连接可能引入非确定性和消息丢失）
- 没有共享内存或共享时钟

> **系统模型**：关于分布式系统所实现的环境和设施的一组假设。

一个健壮的系统模型是那种做出最弱假设的模型。另一方面，也可以做出强有力的假设来创建一个易于推理的系统模型。

### 3.2 Nodes

节点是计算和存储的主机，具有：
- 执行程序的能力
- 将数据存储到易失性内存和稳定状态的能力（内存/硬盘）
- 一个时钟（可能准确也可能不准确）

节点执行**确定性算法**：局部计算、计算后的局部状态以及发送的消息唯一地由**接收到的消息**和**接收消息时的局部状态**决定。

大多数系统假设的故障模型都是**崩溃故障模型**，即：**节点只能通过崩溃来发生故障，并且可能在稍后某个时间点恢复。**

> **拜占庭容错**：假设节点可以通过任意方式的不当行为来失败，也就是说节点除了会失效，也有可能变成恶意节点。

### 3.3 Communication links

通信链路将各个节点相互连接，并允许消息在两个方向上传送。许多讨论分布式算法的书籍假设每个节点对之间存在单独的链路，这些链路为消息提供 FIFO（先入先出）顺序，只能传递已发送的消息，并且发送的消息可能会丢失。但一般来说，最好**将网络视为不可靠的，并且容易出现消息丢失和延迟。**

**网络分区**：节点还在运行但是网络发生了故障，这种情况下，消息坑你会丢失或延迟，但是每个分区的节点可能对于某些客户端还是可以访问的，因此必须与**崩溃**的节点区别对待。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250212134851.png)
### 3.4 Timing / ordering assumptions

物理分布的一个后果是每个节点以独特的方式体验世界，因为信息只能以光速传播，如果节点之间的距离不同，那么消息就是会以不同的时间到达。

> **同步系统模型**：进程按步调一致地执行；消息传输延迟有一个已知的上限；每个进程都有一个准确的时钟。
> **异步系统模型**：没有定时假设。进程以独立的速度执行；消息传输延迟没有上限；没有可用的时钟

当然，假设同步系统模型并不特别现实。现实世界的网络会遇到故障，消息延迟也没有严格的上限。现实世界中的系统最多最多是部分同步的，在许多入门书籍中遇见同步系统多只是因为它们在分析上更容易。

### 3.5 consensus problem

共识问题指的是几台计算机达成共识，即它们都统一某个值，更正式的说：
- **协议**：每个正确的进程必须达成同一值。
- **完整性**：每个正确的进程至多决定一个值，并且如果它决定某个值，那么这个值必须是由某个进程提出的。
- **终止**：所有进程最终都会做出决定。
- **有效性**：如果所有正确的进程提议相同的值 V，则所有正确的进程决定 V。

共识问题是许多分布式系统的核心，我们希望获得分布式系统的可靠性和性能，而不必处理分布带来的后果，解决共识问题使得可以解决几个相关且更高级的问题，如原子广播和原子提交。

FLP 不可能性结果是第一个不可能性结果，特别对于设计分布式算法的人来说非常重要。第二个是 CAP 定理，它是一个相关的结果，更适用于实践者——即那些需要在不同系统设计之间做出选择的人，但他们并不直接参与算法的设计。

### 3.6 FLP 不可能结果

FLP 不可能结果是说，在异步系统中，即使消息永远不会丢失，最多只有一个进程可能失败，并且它只能通过崩溃（停止执行）来失败，也不存在解决共识问题的（确定性）算法”。

FLP 不可能性结果表明，在异步系统中，如果即使一个节点可能失败，则无法通过 **确定性一致性算法** 保证达成一致。这一结果为分布式系统设计提供了理论上的限制，促使了实际中使用 **部分同步** 或 **概率性技术** 来解决一致性问题的算法的出现，如 **Paxos**、**Raft** 等，这些算法在容错设置下仍能有效地保证共识的达成。

### 3.7 CAP 定理

CAP 定理描述了分布式系统中在三个关键属性（**一致性**、**可用性**、**分区容忍性**）之间的权衡关系，指出在一个分布式系统中，最多只能同时满足其中的两个属性，而不能同时满足三个属性。

> **一致性**：要求在分布式系统中，所有节点在同一时间看到的数据是相同的。换句话说，所有操作都是同步的，即所有的数据更改在系统的所有节点之间即时同步，任何节点在读取数据时都能获取到最新的更新。
> **可用性**：要求系统始终对用户提供响应，尽管该响应可能并不是最新的值。也就是说，每次客户端请求数据时，系统会保证返回一个有效的响应，无论该请求是否可以访问到最新的数据。
> **分区容忍性**：系统能够容忍网络分区（即系统的不同节点之间的通信失败）并依然保持正常运行。当系统的某些节点由于网络问题而无法相互通信时，系统仍然能够继续提供服务并进行数据存储和更新。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250212141309.png)

- CA：