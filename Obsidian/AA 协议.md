# AA 协议

主动认证（Active Authentication）是电子护照（ePassport）系统中的一种可选安全机制，旨在防止芯片被克隆或替换，确保芯片的真实性和完整性。与被动认证（PA）不同，PA主要验证数据未被篡改，而AA专注于检测芯片是否为原始芯片。本报告详细概述了AA协议的概述、参数声明、协议流程和实施细节，基于国际民航组织（ICAO）Doc 9303标准以及相关研究和实践。为了防止电子护照芯片被克隆或替换，AA被设计为一种“主动”机制，这意味着它需要芯片与读卡器进行交互，通过挑战-响应协议验证芯片的真实性。AA不是强制性的，不同国家在是否实施AA以及使用的加密算法上存在显著差异。

## 1 参数声明

AA协议涉及以下关键参数，这些参数是验证过程中所需的输入和输出：

- **随机挑战（Challenge）：**
  由读卡器生成的一个随机数，用于发送给芯片以进行签名验证。

- **响应（Response）**：电子护照芯片根据挑战值生成的动态响应，响应的生成依赖于私钥或其他密钥材料。

- **芯片的私钥（Chip's Private Key）：**
  存储在ePassport芯片上的私钥，用于对挑战进行签名。这是芯片的唯一标识，确保其不可克隆。

- **芯片的公钥（Chip's Public Key）：**
  对应于芯片私钥的公钥，通常存储在文档安全对象（SOD）中，或在某些实现中存储在其他数据组中（如DG14或DG15）。该公钥由发行机构签名，确保其可信。

- **文档安全对象（SOD，Document Security Object）：**
  SOD是一个数据结构，包含所有相关数据组的哈希值，并可能包括芯片的公钥，用于AA。它由发行机构的私钥签名。

- **文档签名者证书（DSC，Document Signer's Certificate）：**
  DSC包含发行机构的公钥，用于验证SOD的签名。它由国家签名证书机构（CSCA）签发，通常存储在DG15中。

验证过程的输出是布尔值，表示芯片是否通过了真实性检查。

## 2 协议流程

AA 协议的详细步骤如下，基于标准智能卡通信协议 ISO/IEC 7816-4 的 INTERNAL AUTHENTICATE 命令：

**初始化与密钥准备**：

- 在护照发行时，发证机构为每一本护照生成一个唯一的密钥对（公钥和私钥）。

- 公钥存储在护照芯片内，通常通过证书链的形式与发证机构的根证书相绑定。私钥用于动态生成认证响应。

- 发证机构会使用该私钥对护照中的敏感数据（如持有者信息）进行签名，但该签名与PA协议不同，它并不直接用于验证数据的完整性。

1. **读取并验证SOD：**
   - 读卡器通过NFC或接触式接口从ePassport芯片读取SOD。
   - 使用从DSC中提取的公钥验证SOD的签名，确保SOD未被篡改且由发行机构签发。这一步类似于PA的验证过程。

2. **提取芯片的公钥：**
   - 从SOD或相关数据组中提取芯片的公钥。需要注意的是，在某些实现中，芯片的公钥可能存储在SOD中，而在其他实现中可能在单独的数据组（如DG14）中。

3. **生成并发送挑战：**
   - 读卡器生成一个随机挑战（通常为8字节的随机数），并通过安全通道发送给芯片。终端生成一个随机数，通常为 8 字节，作为挑战数据。这一步确保验证过程具有随机性，难以预测。例如，终端可能生成随机数如“12345678”（实际为二进制数据）。

4. **芯片签名挑战并返回响应：**
   - 芯片使用其私钥对接收到的挑战进行签名。签名过程通常使用RSA或ECDSA算法，具体取决于芯片的配置。
   - 芯片通过支持的命令（如INTERNAL AUTHENTICATE）返回签名的结果。

5. **验证签名：**
   - 读卡器使用从SOD中提取的芯片公钥验证签名的有效性。
   - 芯片的公开密钥需通过被动认证（Passive Authentication）预先获取并验证其真实性。
   - 如果签名验证成功，说明芯片的私钥与公钥匹配，芯片被认为是真实的和原始的。

6. **结论：**
   - 如果所有步骤成功，AA验证通过，芯片被确认未被克隆或替换。
   - 否则，验证失败，可能表示芯片已被篡改或为克隆芯片。

## 3 实现细节

AA的实施涉及多个技术方面，具体取决于ICAO Doc 9303的规范和各国的选择：

- **加密算法：**
  ICAO标准允许使用多种加密算法，包括但不限于：
  - 签名算法：RSA（通常使用ISO/IEC 9796-2方案1）或ECDSA。
  - 哈希算法：与签名算法相关的哈希函数，如SHA-1或SHA-256。
  不同国家可能选择不同的算法组合，这导致AA的实施在全球范围内存在显著差异。

- **密钥管理和信任存储：**
  - 芯片的私钥在制造过程中被写入芯片，并通过硬件保护机制确保其安全性和不可提取性。
  - 芯片的公钥由发行机构签名并存储在SOD中，读卡器需要通过CSCA的公钥验证DSC，然后通过DSC验证SOD，确保公钥的可信性。
  - 读卡器需要维护一个信任存储库，包含所有相关CSCA证书，以建立信任链。

- **命令和接口：**
  - AA通常通过ISO/IEC 7816-4定义的INTERNAL AUTHENTICATE命令实现。
  - 挑战长度通常为8字节，这限制了输入数据的长度，可能影响某些高级应用。

- **实际实施中的挑战：**
  - 由于不同国家的算法和证书选择，读卡器需要支持多种加密方案。
  - 一些较旧的ePassport可能不支持AA，这可能导致克隆检测失败。
  - 实施中需要确保读卡器能够处理CSCA证书的更新和撤销。

生成挑战随机数并发送认证请求

```python
def internal_authenticate(connection, RND_IFD):
    # 发送 INTERNAL AUTHENTICATE 命令，传入 RND_IFD
    # 返回芯片的签名数据
```

读取 EF.DG15 获取公钥

```python
EF_DG15, BAC_data = select_DG15(connection, BAC_data)
Kpu = EF_DG15.hex().upper()
```

验证签名

```python
def Verify_AA_RSA_M(KPu, S):
    # 使用芯片的公钥 KPu，验证签名数据 S
    # 解密签名，验证包含的随机数是否与 RND_IFD 匹配
```

认证结果

```python
if do_AA(connection, BAC_data) == True:
    print("AA 认证通过！")
else:
    print("AA 认证失败！")
```

以下表格总结了AA协议的关键参数和步骤：

| **参数/步骤**                 | **描述**                         |
| ------------------------- | ------------------------------ |
| 随机挑战（Challenge）           | 由读卡器生成的随机数，用于发送给芯片以进行签名验证。     |
| 芯片的私钥（Chip's Private Key） | 存储在芯片上的私钥，用于对挑战进行签名，确保芯片唯一性。   |
| 芯片的公钥（Chip's Public Key）  | 存储在SOD或相关数据组中，由发行机构签名，确保可信。    |
| 文档安全对象（SOD）               | 包含数据组哈希值和可能包括芯片公钥，签名由发行机构私钥签名。 |
| 文档签名者证书（DSC）              | 包含发行机构公钥的证书，由CSCA签发，用于验证SOD签名。 |
| 步骤1：读取并验证SOD              | 读卡器读取SOD并使用DSC公钥验证其签名。         |
| 步骤2：提取芯片公钥                | 从SOD或相关数据组中提取芯片的公钥。            |
| 步骤3：生成并发送挑战               | 读卡器生成随机挑战并发送给芯片。               |
| 步骤4：芯片签名挑战                | 芯片使用其私钥对挑战进行签名并返回。             |
| 步骤5：验证签名                  | 读卡器使用芯片公钥验证签名的有效性。             |
| 步骤6：结论                    | 如果签名有效，芯片被确认为真；否则失败。           |
|                           |                                |
|                           |                                |
|                           |                                |

主动认证（AA）是电子护照安全机制的重要组成部分，通过挑战-响应协议确保芯片的真实性和防克隆能力。尽管其实现灵活且依赖于PKI，但不同国家的算法选择和实施差异可能影响全球互操作性。读卡器需要维护信任存储库并支持多种加密算法，以确保有效验证。