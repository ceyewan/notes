# 异步 BFT 共识中的灵活进步

## 1 摘要

拜占庭容错（BFT）共识协议正成为区块链的一个有吸引力的解决方案。由于大多数区块链系统部署在广域网（WANs）上，每个节点代表其实体进行操作，部分同步的 BFT 协议依赖于网络同步来选举单个领导者，可能不太适合。相比之下，异步协议没有这样的时间假设。现有的异步协议在灵活性和性能方面都面临着挑战。

针对实现异步 BFT 协议的适应性，我们提出了一种新的范式来连接排序和一致性组件。在新范式中，节点可以更灵活地提出和提交区块，以适应我们生产环境中的各种工作负载。为了提高性能，我们提出了 SuperMA，一种高效的多值一致性协议。在最佳情况下，SuperMA 可以在三个消息延迟内终止，实现最佳延迟。我们进一步提出了 MyTumbler，一种基于时间戳的状态机复制协议。MyTumbler 通过我们的新范式得到增强，并使用 SuperMA 作为其一致性组件。在广域网云集群上的大规模实验证明了 MyTumbler 适用于广泛的场景。

## 2 引言


拜占庭容错（BFT）共识协议被认为是既适用于授权链也适用于非授权链的有希望解决方案[19, 39, 42, 47, 79]。BFT 协议的一大类是部分同步和基于领导者的[25, 27, 29, 43, 55, 83]，其中单个节点（即领导者或主节点）负责提出和排序客户端请求。

随着区块链系统采用率的快速增长[3-5, 10]，其底层共识协议面临着以下新挑战。首先，大多数区块链应用部署在广域网（WANs）上，那里网络延迟可能很高且不可预测。其次，在授权设置中节点数量从几十到几百[19, 66, 80]，而在非授权设置中从几百到几千（甚至更多）[13, 42]。第三，每个节点可能仅为其客户提供服务，可能不希望将区块生成委托给其他节点。这需要一种高效、可扩展且无领导者的协议。

面对区块链系统中的挑战，部分同步协议可能不适用。首先，调整广域网中的最大网络延迟Δ可能是一个棘手的问题[7, 38]。Δ值过小可能导致连续的领导者角色变更，而Δ值过大则会导致从故障中恢复的时间更长。在我们使用 PBFT[27]变体作为共识层时，领导者角色变更在我们的跨境金融应用中发生的频率比不发生要高。其次，单个领导者可能成为性能瓶颈[54, 80]。针对区块链部署，一些基于领导者的协议会主动轮换领导者角色[25, 83]，尽管当某些节点出现故障时，它们在性能上会显著下降（参见第 6.4 节的评估结果）。

与同步协议[20, 22, 33, 37, 44, 68]不同，异步协议不依赖于时间假设，可以以更平等的方式进行。每个节点都平等地行动，并自行提出请求，而不是将任务委托给领导者。每个提议要么被确认，要么被取消，由利用随机化来规避 FLP 不可行性[40]的协议决定。更有趣的是，异步协议还实现了所谓的响应性特征[83]，这意味着系统总是以实际网络延迟的速度前进。尽管这是区块链的一个更有希望的方向，但现有的协议仍然存在两个具体问题：

- 每个节点在每个共识实例中都必须参与区块提议，即使该节点此刻没有提议请求；如果系统处于轻负载或不平衡负载状态，这种情况就会发生，这在现实世界的许可型区块链应用中很常见。

- 绕过 FLP 不可解性，在协议的临界路径上放置一个掷币阶段（即随机化），这可能会在大型部署中大大增加时间复杂度[44]。

我们观察到现有的异步协议使用固定槽位范式，为每个节点预先分配一个共识槽位。这不仅是一种资源浪费，而且容易引入提案之间的竞争：考虑到有 𝑓 个节点可能出现故障，异步协议允许 𝑛 − 𝑓 个节点快速推进系统[41]，但这可能会意外地终止慢速节点的提案。相反，我们旨在构建一个系统，
- 当只有一或几个节点在某一时刻提出建议时，可以快速前进；并且，
- 大多数节点提出时，可以放慢速度以适应更多提案。

朝着这个方向，我们提出了灵活推进，一种允许节点自适应地推动系统前进的新范式，以满足我们许可式区块链应用中的各种工作负载。我们进一步提出了 MyTumbler，这是一种基于时间戳的状态机复制（SMR）协议，通过灵活推进范式得到增强。时间戳排序允许每个节点以更精确的方式定位其提案，而不是竞争相同的序列号。在我们的新范式下MyTumbler 是第一个同时实现以下两个特性的异步 BFT SMR 协议：(1)每个节点可以在有挂起请求时自行提出提案（与仅领导者可以提出提案的基于领导者的协议相反）；以及(2)每个节点只有在有挂起请求时才需要提出提案（与固定槽位的异步协议相反，其中每个节点都有义务提出提案）。

为了实现低延迟，我们观察到只有在正确节点对提案有不同意见时，才需要在协议中引入随机化。我们提出了 SuperMA，一种高效的多值一致性协议。SuperMA 利用承诺机制在常见情况下绕过随机化，因此只需三个通信阶段即可确定性地终止。当正确节点对某个提案有不同的看法时，SuperMA 仍然可以通过抛硬币阶段来解决平局。

最终，我们实现了 MyTumbler（使用 SuperMA）并在跨越 4 个大陆、最多 100 个节点的公共云集群上进行了大规模实验。我们还把 SuperMA 整合到 Ben-Or、Kelmer 和 Rabin（BKR）的经典框架中[23]，这是 HBBFT[68]和其他异步协议[37, 63, 82]的核心组件。我们将我们的协议与三种最先进的部分同步和异步协议进行了比较，即在部分同步下 HotStuff[83]，以及在异步下 BKR 和 Tusk[33]。我们的评估结果表明，通过 SuperMA 改进后，BKR-SuperMA 在客户端感知的延迟上实现了高达一个数量级的降低。与 BKR-SuperMA 相比，MyTumbler 进一步将峰值吞吐量提高了 2 倍以上，在非平衡或轻负载下实现了更低的延迟，并适应了来自遥远节点的提案。

## 3 系统模型

我们专注于区块链或状态机复制（SMR）问题，其解决方案是一个容错的消息传递系统，以强一致性方式执行请求。我们假设总共有 𝑛 个节点，其中最多有 𝑓 （< 𝑛/3）个节点可能表现出拜占庭故障，即由对手控制的任意行为。一个例外是，对手无法破坏我们在本文中使用的加密方案，包括公钥签名、抗碰撞哈希函数和门限签名（用于掷硬币阶段）。我们假设每个节点都有一对私钥和公钥，并且事先知道其他节点的公钥。我们用 ⟨𝑚⟩ 表示由节点 𝑖 签名的消息 𝑚。我们定义忠实遵循协议且不崩溃的节点为正确节点，其余为拜占庭节点。

客户端发出请求并将它们发送到节点。正确的节点通过批量处理接收到的请求来生成区块提议。一般来说，区块链系统或 SMR 协议旨在通过为每个提案分配一个位置，使其满足与其他已提交提案位置相关的线性化[48]。然后，正确节点以确定性的方式执行已提交提案中的请求。换句话说，节点以这种方式执行客户端发送的请求：
- （安全）如果 𝐸𝑆 和 𝐸𝑆 分别是任意时刻两个正确节点 𝑖 和 𝑗 的历史执行序列，那么 𝐸𝑆 是 𝐸𝑆 的前缀，或者反之亦然；
- （活动性）任何由正确客户端发出的请求最终都会被每个正确节点执行。

可靠信道。每个节点对都通过一个可靠信道连接，即任何两个正确节点之间的消息最终都会被送达。通信是异步的，即两个正确节点之间的消息可以任意时间被接收方接收，并且可以顺序错乱。

物理时钟。关于我们的协议（MyTumbler），我们假设每个节点都配备了本地物理时钟。正确节点之间的时钟是松散同步的。这可以通过外部 NTP 服务器[1]、GPS 或内置时钟同步协议[84]实现。正如我们稍后将会看到的，时钟同步假设既不影响我们系统的安全性也不影响其活性，尽管它可能会影响效率。

## 4 背景与动机

我们的许可型区块链特点。我们首先描述我们在生产系统中遇到的几个典型场景。许可型区块链通常针对异构环境部署，在这种环境中，不同节点对之间的消息延迟以及不同节点的负载（和/或容量）很可能是不均衡的。每个节点代表其实体（例如，公司或组织）参与分布式账本的维护。这与传统 SMR 协议的设置有显著不同，在传统 SMR 协议中，每个节点都被假设平等地行动，并且具有相等的工作负载和/或容量。


首先，不平衡的工作负载出现在，例如，我们的跨境汇款服务中。有一些电子钱包节点处理来自客户的许多货币转账，而流动性提供者节点（通常是银行）发出较少的请求以进行市场操作。其次，在地理分布部署中通常会发现延迟偏差，其中一些节点距离其他节点较远。例如，我们的跨境金融应用在全球范围内包含数十个节点。绝大多数节点位于一个大陆，而其余的分布在其他大陆。第三，研究人员通常倾向于提高峰值性能，但在轻负载下保持稳定的性能（尤其是客户感知的延迟）也可能是一个合理的目标。例如，在我们的 B2B 电子发票应用中，请求发行频率较低，大约每秒几笔交易。针对上述讨论的场景，既不是基于领导者的协议也不是异步协议能完美满足我们的需求。
![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250209230037.png)
图 1. 当 n=4（f=1）时，BKR [23, 68] 的执行流程。节点 0 的请求 req 因节点 0 与其他节点之间网络缓慢而被其他节点中止。

部分同步协议中的问题。许多部分同步协议基于领导者，领导者角色分配给一个固定的节点[27, 43, 79]或主动轮换[25, 83]。在任何给定的时间点，只有一个节点可以充当指定的领导者。其他（可能是远程的）节点应该知道领导者的位置并将它们的缓存请求传播给它。简而言之，此类协议在提出建议方面具有专门的角色。


多领导者变体[18, 32, 69, 80]将领导者角色分配给每个节点，以便每个节点都可以提出自己的提案，更好地利用其计算资源和带宽。多领导者协议可以被视为并行运行 n 个并发单槽共识实例。即使某些节点目前没有缓存的请求，它们也必须提出一个空提案，以便快速推进系统。此外，在地理复制的情况下，用于选举领导者（或多领导者协议中的协调者）的时间假设可能存在问题。


异步协议问题。我们首先简要介绍 Ben-Or、Kelmer 和 Rabin（BKR）[23]提出的经典框架。BKR 是多个异步 SMR 协议的核心组件[37, 63, 68, 82]。BKR 的执行流程如图 1 所示。每个 BKR 实例包含𝑛个可靠的广播（RBC）实例和𝑛个随机的二进制协议（BA）实例，每个实例对应一个节点。RBC 允许提议者将其提议传播给其他人，而 BA 决定提议是否可以提交。RBC 确保一致性和完备性，即所有正确节点要么交付相同的消息，要么都陷入停滞。RBC 在故障提议者的情况下不保证终止，因此使用 BA 实例来终止可能未完成的 RBC。具体来说，如果一个节点在 RBC 中交付了消息𝑚，它将 1 输入到 BA 中。当𝑛−𝑓个 BA 实例输出 1 时，节点将 0 输入到其余没有输入的 BA 实例中，以防某些𝑓个提议者是故障的。由于 BA 可以在每个正确节点输入的情况下终止，因此每个 BA 实例的输出可以告诉是否提交了提议。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250209230115.png)

表 1. 不同类型共识协议的比较。“强制”表示每个节点预先分配了一个协议槽位，必须用提案填充。“专用”表示在某一时刻只有一个节点负责填充槽位。


总结来说，RBC 将多值协议简化为二元协议，而 BA 用于终止。


在考虑部署到我们的生产系统时，像使用 BKR 这样的异步协议仍面临两个具体问题：(1)如何更好地适应所有类型的工作负载；以及(2)如何快速达成一致（例如，在 BKR 中完成 RBC 和 BA）。

对于第一个问题，BKR 和其他异步协议要求每个节点都要提出一个提案，即使节点没有待处理请求时也要提出一个空提案。在轻负载或不平衡的工作负载下，这是一种资源浪费，并且 n-f 个快速节点可能会抑制 f 个慢速节点的提案，即使它们的提案被取消（例如，参见图 1）。如果我们使用像 SuperMA 这样的快速一致性协议，这个问题会进一步放大。

对于第二个问题，BKR 的当前实现由于通信阶段数量众多而存在大量开销。Bracha [24] 的 RBC 由三个通信阶段组成。至于 BA 子协议，Mostéfaoui 等人 [71] 提出了一个很好的候选方案，该方案在最佳情况下也需要三个通信阶段。此外，Mostéfaoui 等人的 BA 将掷硬币（即随机化）放在关键路径上，这使得整个 BKR 过程的最佳延迟难以实现 [44]。其他优化协议 [16, 33, 44, 52]，虽然在期望中实现了 O(1)的时间复杂度，但仍然将随机化放在执行路径上，从而阻碍了快速终止。

现有协议为领导者或每个节点预先分配一个固定槽位，因此具有指定的角色（专用）或要求每个节点（强制）提出提案，如表 1 所示。与固定槽位范式相反，我们旨在实现一种能够优雅适应不同场景的方法。

## 5 MyTumbler

我们自上而下地描述我们的方法，即在本节中我们介绍了灵活进步范式和 MyTumbler，而在第 5 节中我们介绍了 SuperMA。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250209230241.png)

图 2. 按逻辑序列号排序的提案的灵活进步的高级结构。

### 5.1 灵活晋升范式

我们首先研究 SMR 协议如何整合排序和一致性（即单槽共识）组件。


SMR 协议通过排序和执行新发布的提案进行。我们说一个提案 B 在位置𝜙（B）处被提交，如果正确节点已就执行 B 在𝜙（B）处达成一致。那些提交的提案在达成一致后是完全排序的。位置𝜙（B）可以是序列号[27, 68]，DAG 中的轮数或高度[20, 33]，或者 MyTumbler 中的时间戳。我们说排序组件将每个提案分配到一个位置。

协议组件确保不会有两个不同的提案在同一位置被提交。然而，立即执行已提交的提案是不安全的。如果且仅当 𝐵 已提交并且每个已提交的 𝐵（𝐵）< 𝜙（𝐵）的 𝐵 都已执行，正确的节点可以安全地执行 𝐵 中的请求。通过连续执行新提交的块，系统（即状态机）前进。

SMR 的主要问题之一是，如何知道之前的所有已提交提案。在固定槽位范式下，这个问题很容易回答：每个槽位都必须填入一个提案。然而，缺点很明显。即使一个节点没有请求，它也必须在槽位中提出一些内容。

实际上，正确的节点只需要知道何时可以执行一个（已提交的）提案，但不需要在每个槽位中填充一个提案。从协议的角度来看，我们观察到只有在节点多数独家支持提案𝐵的情况下，提案𝐵才能在𝜙(𝐵)处被提交。例如，在 PBFT[27]中，一个提案只有在 n-f 个节点为其发送了准备（或提交）消息时才能被提交。在这种情况下，拥有 f 个拜占庭节点的对手无法找到另一个多数节点声称他们支持𝐵或否认他们支持𝐵。

在新范式下，我们通过要求每个节点明确“传递”位置来抽象正确节点前进的方式。这一想法受到法定多数交集（为了保证安全性）以及任何法定多数节点都必须能够推动系统前进的事实（为了保证在异步情况下的活性）的启发。[41]


我们的范式的高级结构在图 2 中给出。为了继续进行并使新提交的提案可执行，每个节点持续传递新的位置
为了使新提交的提案可执行 𝜙 (𝐵)，意味着节点承诺不支持任何小于 𝜙 (𝐵) 的提案。一旦有 Q 个节点通过了 𝜙 (𝐵)，正确节点知道在 𝜙 (𝐵) 之前发布的新提案不能被超过 𝑛 − |Q| + 𝑓 个节点支持。对于协议组件，我们假设只有当 Q 个节点支持提案时，提案才能被提交。如果 Q 和 Q 在 𝑓 + 1 个节点上相交，那么一个正确节点同时属于两个组。这样的节点不应同时通过 𝜙 (𝐵) 并随后支持 𝜙 (𝐵) 之前的提案。因此，正确节点可以安全地执行所有在 𝜙 (𝐵) 之前提交的提案。为了简单起见，本文中我们假设对称信任，即 |Q| = |Q| = 𝑛 − 𝑓 = 2𝑓 + 1。我们得到以下引理：


引理 1. 如果有 𝑛 − 𝑓 个节点声称他们没有支持提案 𝐵，并且承诺未来也不会支持，那么 𝐵 不能被提交。

使用通行机制，整个系统的速度由每个节点传递新位置的速度决定。
直观上，如果只有一个节点有挂起的请求（例如，在负载不平衡或轻负载下），正确的节点应迅速达成一致并使提案可执行，从而实现低延迟。此外，此类提案不应被终止，因为在现有的异步协议中，提出空提案的节点可能会抑制实际的工作负载。另一方面，当大多数节点提出时，系统应减慢速度并容纳更多提案，从而实现高吞吐量。

这两种看似矛盾的模式（快和慢）可以通过通行机制自适应和无缝切换（见§4.2）。为了更好地适应特定模型，可以进一步细化限制，例如考虑顺序公平性[53, 84]。设计者只需指定何时可以传递位置以及批准提案的条件。

最终问题是，如果一些正确节点支持它，而另一些已经通过了它的位置，如何确定一个提案是被提交还是被废弃。引入协议组件来解决这种歧义。在以下内容中，我们抽象出一个可以方便地用于我们范式的协议组件。

ARBC 的抽象。多值协议组件可以抽象为可取消的可靠广播（ARBC）。
原始. 形式上，ARBC 实例有一个专门的提议者𝑝。ARBC 有三个外部输入。首先，提议者输入并广播一个消息𝑚。其次，每个节点可以输入一个𝐸𝑁 𝐷𝑂𝑅𝑆𝐸信号，意味着该节点已收到提案并同意支持它。第三，每个节点可以输入一个𝐴𝐵𝑂𝑅𝑇信号，意味着该节点试图中止提案。至于输出，每个节点决定一个消息𝑚或⊥，意味着它不发送任何内容。以下属性必须成立：
- 协议：如果两个正确的节点决定，它们决定相同的值（要么是消息 𝑚，要么是 ⊥）。
- 
- 强有效性：如果某些正确节点决定 𝑚 ≠ ⊥，则 𝑚 被一个由 |Q| = 𝑛 − 𝑓 个节点组成的多数派所支持。此外，如果提议者正确且没有正确节点输入 ABORT 信号，那么每个正确节点都决定 𝑚 ≠ ⊥，并且 𝑚 由提议者发送。
- 
- 条件终止：如果每个正确的节点输入了 𝐴𝐵𝑂𝑅𝑇 信号，每个正确的节点都会做出决定。
- 
- 总而言之：如果一个正确节点做出决定，最终每个正确节点都会做出决定。


在收到提案 𝐵 在 𝜙 (𝐵) 处后，如果节点尚未通过 𝜙 (𝐵)，则节点在 ARBC 中支持它。请注意，每个节点可能既支持又（稍后）尝试中止 𝐵，以防一些正确的节点已经通过了 𝜙 (𝐵)。强有效性属性针对我们的范例进行了定制，因为不应有任何过时的提案被提交。至于条件终止，当所有正确的节点都通过了 𝜙 (𝐵) 时，它们将通过输入 ABORT 信号来终止所有在 𝜙 (𝐵) 之前的实例。在第 5 节中，我们给出了 SuperMA，ARBC 的一个高效实例化。在本节中，我们使用 ARBC 抽象来说明 MyTumbler。

### 5.2 简述 MyTumbler

