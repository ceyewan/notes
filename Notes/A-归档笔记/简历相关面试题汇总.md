面试官您好！我叫廖明秋，来自湖南衡阳，是武汉大学电子信息专业的在读硕士研究生，本科毕业于武汉大学。非常荣幸能够有机会参加今天的面试，感谢面试官的时间，期待与您交流。

我主要使用 Golang，熟悉 C++、Python，并且对微服务、云原生开发有浓厚的兴趣。具备扎实的计算机基础，尤其在分布式系统、数据库等方向有深入学习和实践。通过这些理论学习和实践研究，我不仅掌握了理论知识，还积累了丰富的工程实践经验。

在生活中，我热爱运动，长期坚持健身，培养了毅力和自律。同时，我积极参与科研竞赛和学校活动，提升了技术深度与团队协作能力，并通过技术博客分享学习心得和项目经验。

我的优势在于对技术原理的深入探索和较强的工程实践能力，同时具备强烈的自驱力和责任感。非常期待能有机会加入贵公司，并与优秀的团队共同成长。谢谢！

## 1 分布式微服务即时通讯系统

面试官你好，第一个项目是我最近做的一个分布式的微服务即时通讯系统，支持高并发、低延迟和高可用性。

首先，这个系统采用了四层架构，分别是 API 接入层、逻辑处理层、任务调度层和长连接层，不同层次分别处理不同的内容，层级之间使用 etcd 来进行服务发现，使用 gRPC 和消息队列进行通信。

API 接入层是使用 GIN 框架和 JWT 构建的一个轻量级 Web 服务，为用户提供注册、登录、登出、权限验证等 HTTP 服务，接收到请求后，该层并不直接处理业务逻辑，而是将请求通过 RPC 调用转发给逻辑处理层。

逻辑处理层对外提供 RPC 服务，内部主要负责接收 API 接入层的用户登录、认证请求。此外，还需要出来来自长连接层的消息推送、状态变更。对于一条消息推送，逻辑处理层会将其处理后，为每一个消息通过分布式 ID 算法提交一个唯一的 ID，将其发送到消息队列中。此外，长连接层监控到有用户的上线和下线时，会将上线下线消息和对应的房间号发送到逻辑处理层，逻辑处理层使用 Redis 作为缓存，维护每一个房间的在线人数和成员信息，还会维护用户 ID 到长连接层实例 ID 的一个映射关系。

任务调度层当前分为两个消费者组从消息队列里获取消息，一个消费者组确保消息的及时投递，从消息队列里实时的消费消息后，根据消息是单聊消息还是群发消息，将其立即投递到对应的长连接层。第二个消费者组异步的从消息队列里读取消息，将消息内容持久化的写入到 MySQL 数据库中，确保消息的可靠性。

最后是长连接层，这一层直接面向用户，通过 Websocket 协议与用户建立持久的双向通信，当用户通过 API 接入层成功登录后，就会与长连接层连接 Websocket 连接。为每个 ws 连接分配两个协程，分别处理用户的发送消息和读取消息。用户发送的消息会被发送到逻辑处理层进行处理，从任务调度层获取到消息后，通过对应用户的 ws 长连接的写协程发送给用户。

为了提高系统的可拓展性和可靠性，采用了 etcd 作为服务发现中心，所有的服务实例均可实现动态扩缩容。最终达到了 5wQPS 的一个消息吞吐量和 50ms 的一个消息延时。

**下面我将以一条单聊消息的发送流程为例，串联起这四个层面：**

1. 用户在客户端发送一条消息，这条消息通过 HTTP 请求发送到 **API 接入层**。
2. **API 接入层** 接收到请求后，会调用 **LogicRPC** 服务（部署在 **逻辑处理层**），将消息内容、发送者和接收者信息传递给 **逻辑处理层**。
3. **逻辑处理层** 接收到消息后，首先进行必要的鉴权和业务逻辑处理，然后生成一个全局唯一的分布式消息 ID，并将该消息写入消息队列。同时，**逻辑处理层** 可能会通过查询 **Redis** 获取接收者的在线状态。
4. **任务调度层** 中的 **实时推送消费者组** 监听到新的消息后，会将其消费，并根据接收者的用户 ID，通过 **ConnectRPC** 调用相应的 **长连接层** 实例。
5. **长连接层** 接收到来自 **Task 层** 的推送请求后，会查找与接收者用户 ID 关联的 WebSocket 连接，并将消息通过该连接实时推送给用户的客户端。
6. 与此同时，**任务调度层** 中的 **消息持久化消费者组** 也会消费该消息，并将其异步地写入 **MySQL** 数据库进行持久化存储。

通过这样的分层设计和技术选型，我们的系统能够支持 **5W+ 的每秒查询率 (QPS)**，并保证消息投递延迟稳定在 **50 毫秒** 以内，同时具备秒级的故障恢复能力，能够高效地满足大规模用户的实时通讯需求。

Q：为什么要实现四层架构？你有什么考量？
1. 职责分离与模块化
2. 性能优化与高可用性
3. 开发与部署灵活
4. 后续扩展，如 Task 层增加消息批量处理、延迟投递、消息审计监控功能；Logic 层增加消息撤回、已读回执功能。

Q：如何确保消息唯一的投递？

- **使用 MurmurHash 哈希消息内容**，将 `userID + hash` 作为 Redis 的 key，并设置过期时间。
- **检查 Redis 中的重复 key**，如果存在，则判定为重复消息，拒绝投递。
- **生成分布式唯一 ID**，使用雪花算法为消息生成唯一 ID，确保消息在分布式系统中的唯一性。
- **投递到支持消息去重的消息队列**，如 Kafka 或 RabbitMQ 的幂等性生产者，配置消息的唯一 ID，防止重复投递。
- **增加幂等性检查**，在处理消息前，检查 MySQL 中是否已记录该消息 ID，确保消息只被处理一次。
- **结合 Redis 和消息队列**，通过双重机制确保消息的唯一投递和幂等性处理。

Q：有哪些应对高并发、提高容错率的办法？

- etcd 服务动态注册和发现，k8s 弹性伸缩
- 健康检查：心跳机制、HTTP 健康检查接口
- 熔断降级：当服务调用失败率达到阈值时，触发熔断，直接返回降级结果（默认值）
- 令牌桶限流：限制单位时间内的请求量，超出限制的请求被拒绝或排队。
- 负载均衡策略：一致性哈希、结合服务监控选择最佳服务实例来提供服务
- 服务监控、日志分析（普罗米修斯、ELK 等）：实时监控系统性能，分析日志定位问题。
- 消息队列：将操作异步化，减少请求响应时间，流量削峰。

**ELK** 是一个流行的日志管理和分析技术栈，由三个开源工具组成：

1. **Elasticsearch**：分布式搜索和分析引擎，用于存储和快速检索日志数据。
2. **Logstash**：数据收集和处理管道，用于接收、解析和转换日志数据。
3. **Kibana**：数据可视化工具，用于在 Web 界面中展示和分析日志数据。

Q：性能瓶颈分析？

1. 消息的反复序列化与反序列化
2. 内存、CPU 资源的竞争、IO 吞吐量
3. RPC 调用的性能瓶颈，流式调用、负载均衡

Q：项目难点？
1. 本项目的主要难点是同时维护服务级别和实例级别两种不同粒度的 RPC 连接抽象，在底层结合 etcd 实现用户无感的负载均衡和动态扩缩容的服务发现，用户只用获取一个单一的 gRPC 连接对象即可享受自动化的服务治理能力。第一套机制（ServiceDiscovery）通过自定义 etcd resolver 和 gRPC 负载均衡策略，将多实例的动态管理完全封装在连接对象内部，业务代码只需像使用普通 gRPC 连接一样发起调用，底层自动完成实例选择、连接复用和故障转移；第二套机制（ServiceInstanceConnManager）则通过维护实例级连接映射表，为需要定向通信的场景提供精准控制能力。两套机制共享 etcd 的监听通道但独立管理连接池，既通过服务抽象层实现了 " 面向服务 " 的透明调用，又通过实例管理层保留了 " 面向实例 " 的精细控制，形成互补的弹性架构。这种设计的关键在于通过 etcd 的实时事件通知机制保持两种抽象层状态的一致性，确保负载均衡连接和定点连接都能及时响应集群拓扑变化。从负载均衡器里面获取的是底层网络连接，代表与服务器的 TCP 连接；然后用户基于这个连接创建一个客户端接口，并使用。

Q：高可用的难点？
