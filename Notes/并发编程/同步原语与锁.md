在 Go 语言中，同步原语是用于协调多个 goroutine 之间并发操作的工具。Go 提供了多种同步原语，包括 `Mutex`、`RWMutex`、`WaitGroup`、`Once` 和 `Cond` 等。这些原语帮助开发者实现线程安全的数据访问和 goroutine 的同步。

## 1 基本概念

**并发与同步**：在并发编程中，多个 goroutine 可能同时访问共享资源，导致数据竞争（Data Race）。同步原语的作用是确保在某一时刻只有一个 goroutine 可以访问共享资源，从而避免数据竞争。
**锁**：锁是一种同步机制，用于控制对共享资源的访问。Go 提供了多种锁的实现，如 `Mutex` 和 `RWMutex`。

## 2 Mutex（互斥锁）

互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：

- 如果互斥锁处于初始化状态，会通过置位 `mutexLocked` 加锁；
- 如果互斥锁处于 `mutexLocked` 状态并且在普通模式下工作，会进入自旋，执行 30 次 `PAUSE` 指令消耗 CPU 时间等待锁的释放；
- 如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；
- 互斥锁在正常情况下会通过 `runtime.sync_runtime_SemacquireMutex` 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；
- 如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式。

互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：

- 当互斥锁已经被解锁时，调用 `sync.Mutex.Unlock` 会直接抛出异常；
- 当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 `mutexLocked` 标志位；
- 当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 `sync.runtime_Semrelease` 唤醒对应的 Goroutine。

Go 语言的 sync.Mutex 互斥锁实现基于 **自旋锁** 和 **信号量**，并结合了 **两种模式（正常模式和饥饿模式）** 来优化锁的性能，以提高吞吐量和减少锁竞争导致的延迟。

> [!NOTE] 两种模式
> **正常模式（公平竞争）**：Goroutine 争夺锁，获胜者直接获取锁；等待者进入自旋，如果失败就进入信号量等待。
> **饥饿模式（FIFO）**：锁直接转交给等待队列中的 Goroutine。避免新的 Goroutine 反复竞争抢占锁，导致长时间饥饿。
> **切换规则**：等待时间超过 1ms 就会进入饥饿模式；当前 Goroutine 是唯一等待者或等待时间短于 1ms 就退出饥饿模式。

```go
type Mutex struct {
    state int32  // 互斥锁的状态（包含锁标志位、自旋次数、等待者数量等信息）
    sema  uint32 // 信号量，用于 Goroutine 的调度
}
```

state 是互斥锁的核心状态，它使用多个 **位标志** 来表示不同的状态：

- mutexLocked (最低位)：锁的标志位，表示锁是否被持有；
- mutexWoken (次低位)：表示是否有 Goroutine 被唤醒；
- mutexStarving (第 3 低位)：表示是否处于 **饥饿模式**；
- mutexWaiterShift (剩下 29 位)：存储等待者的数量（高位存储）。

sema 是一个信号量，Go 通过 **信号量机制** 来阻塞和唤醒 Goroutine。

当一个 Goroutine 试图获取 `sync.Mutex` 时，会执行 `Lock()` 方法，首先，尝试直接加锁，如果 `state == 0`，则使用 CAS（Compare-And-Swap）操作将 mutexLocked 标志位置 1，直接加锁成功；否则，进入 `lockShow()` 处理流程。

```go
func (m *Mutex) Lock() {
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        return
    }
    m.lockSlow()
}
```

进入 lockSlow() 后，会尝试 **自旋** 和 **信号量阻塞** 以减少线程切换的开销。如果锁被持有但没有进入饥饿模式，Goroutine 会先 **自旋等待**（执行 30 次 PAUSE 指令，消耗 CPU 时间）自旋适用于 **轻量竞争场景**，避免 Goroutine 立即进入休眠，提高性能。如果自旋后仍然无法获取锁，那么 Goroutine 会进入等待；如果等待时间超过 **1ms**，则 **切换到饥饿模式**。通过 runtime.SemacquireMutex() 让 Goroutine **休眠**，等待持有锁的 Goroutine 唤醒它。

## 3 RWMutex（读写锁）

## 4 WaitGroup

## 5 Once

## 6 Cond

## 7 小结

Go 的同步原语提供了强大的工具来管理并发和共享资源的访问。以下是各原语的主要特点：

- `Mutex`：用于互斥访问共享资源。
- `RWMutex`：用于读写分离的场景。
- `WaitGroup`：用于等待一组 goroutine 完成。
- `Once`：用于确保某个操作只执行一次。
- `Cond`：用于在特定条件下唤醒等待的 goroutine。

这些原语的实现基于 Go 运行时的调度器、原子操作和等待队列，确保了高效和线程安全的并发控制。在实际开发中，应根据具体场景选择合适的同步原语，以避免数据竞争和死锁问题。
