在 Go 语言中，同步原语是用于协调多个 goroutine 之间并发操作的工具。Go 提供了多种同步原语，包括 `Mutex`、`RWMutex`、`WaitGroup`、`Once` 和 `Cond` 等。这些原语帮助开发者实现线程安全的数据访问和 goroutine 的同步。

## 1 基本概念

**并发与同步**：在并发编程中，多个 goroutine 可能同时访问共享资源，导致数据竞争（Data Race）。同步原语的作用是确保在某一时刻只有一个 goroutine 可以访问共享资源，从而避免数据竞争。
**锁**：锁是一种同步机制，用于控制对共享资源的访问。Go 提供了多种锁的实现，如 `Mutex` 和 `RWMutex`。

## 2 Mutex（互斥锁）

Go 语言的 sync.Mutex 互斥锁实现基于 **自旋锁** 和 **信号量**，并结合了 **两种模式（正常模式和饥饿模式）** 来优化锁的性能，以提高吞吐量和减少锁竞争导致的延迟。

> [!NOTE] 两种模式
> **正常模式（公平竞争）**：Goroutine 争夺锁，获胜者直接获取锁；等待者进入自旋，如果失败就进入信号量等待。
> **饥饿模式（FIFO）**：锁直接转交给等待队列中的 Goroutine。避免新的 Goroutine 反复竞争抢占锁，导致长时间饥饿。
> **切换规则**：等待时间超过 1ms 就会进入饥饿模式；当前 Goroutine 是唯一等待者或等待时间短于 1ms 就退出饥饿模式。

```go
type Mutex struct {
    state int32  // 互斥锁的状态（包含锁标志位、自旋次数、等待者数量等信息）
    sema  uint32 // 信号量，用于 Goroutine 的调度
}
```

state 是互斥锁的核心状态，它使用多个 **位标志** 来表示不同的状态：

- `mutexLocked` (最低位)：锁的标志位，表示锁是否被持有；
- `mutexWoken` (次低位)：表示是否有 Goroutine 被唤醒；
- `mutexStarving` (第 3 低位)：表示是否处于 **饥饿模式**；
- `mutexWaiterShift` (剩下 29 位)：存储等待者的数量（高位存储）。

sema 是一个信号量，Go 通过 **信号量机制** 来阻塞和唤醒 Goroutine。

### 2.1 加锁 (Lock()) 过程

当一个 Goroutine 试图获取 sync.Mutex 时，会执行 Lock() 方法：

1. **尝试快速加锁（CAS 操作）**
    - 如果 state == 0（即锁当前未被持有），则使用 **CAS（Compare-And-Swap）** 操作尝试将 mutexLocked 置 1。
    - 若 CAS 成功，表示加锁成功，直接返回。
    - 若 CAS 失败（表示锁已被持有），进入 **慢路径 (lockSlow())** 处理流程。

```go
func (m *Mutex) Lock() {
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        return // 快速加锁成功
    }
    m.lockSlow() // 进入慢路径
}
```

2. **慢路径 (lockSlow())**

    进入 lockSlow() 后，Goroutine 会经历**自旋等待、自旋失败后进入休眠、饥饿模式切换**等步骤，以减少线程切换的开销。

    1. **自旋等待**（适用于轻度竞争）
        - 如果锁已被持有，但系统未进入饥饿模式，则 Goroutine 先**自旋等待**，执行 30 次 PAUSE 指令，以减少 CPU 竞争和线程切换。
        - **如果短时间内锁被释放，Goroutine 可以避免进入休眠状态，提高性能。**
    2. **进入等待队列**（适用于中等竞争）
        - 如果自旋结束后仍无法获取锁，则 Goroutine 增加 state 中的**等待者计数 (waiter count)**，然后调用 `runtime.SemacquireMutex()` 进入**休眠**，等待锁的持有者主动唤醒。
        - **如果 Goroutine 在等待超过 1ms，互斥锁将切换到** **饥饿模式**，优先将锁直接交给等待队列中的 Goroutine，避免新来的 Goroutine 反复竞争锁资源。

```go
func (m *Mutex) lockSlow() {
    if shouldSpin() { // 短暂自旋尝试获取锁
        spinWait()
    }
    // 自旋失败，进入等待队列
    atomic.AddInt32(&m.state, 1<<mutexWaiterShift)
    runtime.SemacquireMutex(&m.sema)
}
```

### 2.2 解锁 (Unlock()) 过程

解锁操作相对简单，主要流程如下：

1. **基本解锁操作**
    - 检查 state 是否包含 mutexLocked，如果锁已经被释放，则直接触发异常。
    - 清除 mutexLocked 标志位，表示锁已释放。
2. **处理等待队列**
    - 如果当前锁处于 **饥饿模式**：直接将锁的所有权 **转交给队列中等待时间最长的 Goroutine**，由它来设置 mutexLocked 标志位，并继续执行。
    - 如果锁处于 **正常模式**：若没有等待者，直接返回；若有等待者，则通过 `runtime.Semrelease()` 唤醒等待队列中的 Goroutine，**但不直接转交锁**，让它们重新竞争。

```go
func (m *Mutex) Unlock() {
    newState := atomic.AddInt32(&m.state, -mutexLocked) // 清除锁标志位
    if newState & mutexStarving == 0 && newState >> mutexWaiterShift == 0 {
        return // 无等待者，直接返回
    }
    // 存在等待者，释放信号量，唤醒一个 Goroutine，第二个参数控制
    runtime.Semrelease(&m.sema, newState&mutexStarving != 0, 1)
}
```

### 2.3 互斥锁的等待队列管理

Go 运行时使用**信号量 (sema) 作为 Goroutine 的等待队列**，并遵循 **FIFO（先进先出）** 原则，保证**最早进入等待队列的 Goroutine 会被优先唤醒**。

- **在正常模式下**，等待队列的 Goroutine 需要重新竞争锁。
- **在饥饿模式下**，锁会直接转交给等待队列中的最早进入者，避免竞争开销。

```go
// runtime.Semrelease 负责释放信号量，并决定是否直接交给等待者
runtime.Semrelease(&m.sema, isStarvingMode, 1)
```

## 3 RWMutex（读写锁）

sync.RWMutex 是 Go 语言中的**读写互斥锁**，用于控制并发访问资源。相较于 sync.Mutex，它允许多个 Goroutine 同时获取**读锁**（共享访问），但同一时刻最多只能有**一个 Goroutine 持有写锁**（独占访问）。

```go
type RWMutex struct {
	w           Mutex  // 复用互斥锁提供的能力
	writerSem   uint32 // 写等待信号量
	readerSem   uint32 // 读等待信号量
	readerCount int32  // 当前持有读锁的 Goroutine 数量
	readerWait  int32  // 等待写锁的 Goroutine 数量
}
```

### 3.1 获取写锁（Lock()）

当 Goroutine 需要写入资源时，它会调用 Lock() 申请写锁：

1. **获取互斥锁**：调用 rw.w.Lock()，其他写操作会被阻塞。
2. **阻止新的读操作**：
    - `readerCount -= rwmutexMaxReaders`，设定一个大负数，确保后续的 RLock() 失败，从而阻止新的读锁。
    - 计算当前仍持有的读锁数 r，若 `r != 0`，说明仍有 Goroutine 持有读锁。
3. **等待读锁释放**：
    - readerWait 记录当前写锁的等待数量。
    - 调用 `runtime_SemacquireMutex(&rw.writerSem, false, 0)`，进入休眠，直到所有 RUnlock() 释放读锁后被唤醒。

```go
func (rw *RWMutex) Lock() {
    rw.w.Lock()  // 获取底层互斥锁，阻塞其他写操作
    r := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    if r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {
        runtime_SemacquireMutex(&rw.writerSem, false, 0) // 等待所有读操作完成
    }
}
```


## 4 WaitGroup

## 5 Once

## 6 Cond

## 7 小结

Go 的同步原语提供了强大的工具来管理并发和共享资源的访问。以下是各原语的主要特点：

- `Mutex`：用于互斥访问共享资源。
- `RWMutex`：用于读写分离的场景。
- `WaitGroup`：用于等待一组 goroutine 完成。
- `Once`：用于确保某个操作只执行一次。
- `Cond`：用于在特定条件下唤醒等待的 goroutine。

这些原语的实现基于 Go 运行时的调度器、原子操作和等待队列，确保了高效和线程安全的并发控制。在实际开发中，应根据具体场景选择合适的同步原语，以避免数据竞争和死锁问题。
