缓存与数据库一致性问题是指在使用缓存（如 Redis）和数据库（如 MySQL）协同工作时，由于两者数据更新不同步，可能导致读取到的数据不一致的情况。这种问题在高并发场景下尤为常见，因为缓存通常用于提升读取性能，而数据库负责持久化存储数据的完整性和准确性。当数据发生变更时，如果缓存和数据库的更新操作没有协调好，就可能出现用户读取到旧数据（脏数据）或数据缺失的情况。

## 1 Cache-Aside 旁路缓存模式

Cache-Aside 是一种常见的缓存模式，其核心思想是让应用程序**直接与缓存和数据库进行交互**，而不是由缓存系统来负责数据的加载和写入。应用程序需要自己来管理缓存的读写操作。

- **读流程**：先读缓存，缓存未命中则读数据库并回填缓存。
- **写流程**：直接更新数据库，然后**失效化**缓存中对应的条目。

高并发下可能短暂不一致，例如在数据库更新成功后，到缓存失效化完成之间，如果此时有新的读取请求，仍然可能读取到旧的缓存数据。这是一个短暂的不一致窗口。

### 1.1 先删缓存后更新库

- 用户 A 删除缓存。
- 用户 B 发起读请求，缓存未命中。
- 用户 B 从**旧的**数据库（在用户 A 更新之前）读取数据。
- 用户 B 将**旧的**数据写入缓存。
- 用户 A 更新数据库为新值。
- **结果：** 数据库是新值，但缓存中却是旧值，导致数据不一致。

### 1.2 先更新库后删缓存

- 用户 A 更新数据库为新值。
- 用户 A 删除缓存。
- 在用户 A 删除缓存之前，用户 B 发起读请求，此时缓存中可能是旧值（如果之前有缓存）。用户 B 读取到旧值。
- 用户 B 基于旧值进行操作，并可能更新数据库（基于旧值计算）。
- 用户 A 的删除缓存操作完成。

## 2 Cache Proxy 缓存代理模式

缓存代理模式是一种结构型设计模式，它在客户端和实际的数据源（通常是数据库或后端服务）之间引入了一个缓存层作为代理。客户端不直接与数据源交互，而是通过缓存代理来访问数据。缓存代理负责处理缓存的逻辑，例如检查缓存是否存在、从缓存中获取数据、将数据写入缓存以及在必要时将请求转发给后端数据源。

- **读流程**：应用直接操作缓存代理，缓存层自行同步数据库。
- **写流程**：应用直接操作缓存代理，缓存代理的写入操作有：
    - **Write-Through (写穿透):** 缓存代理先将数据更新到后端数据源，更新成功后再更新自己的缓存。
    - **Write-Back (写回):** 缓存代理先将数据更新到自己的缓存，然后异步地将更新写入后端数据源。
    - **Write-Around (写绕过):** 缓存代理直接将写请求转发给后端数据源，不更新自己的缓存。这种策略通常用于不经常读取的数据。
    - **Invalidate (失效化):** 缓存代理更新后端数据源后，将自己缓存中对应的条目标记为失效，下次读取时会从后端重新加载。

## 3 延迟双删策略

延迟双删策略是一种在更新数据库和缓存时，为了尽可能保证数据一致性而采用的一种方法。它通过两次删除缓存的操作，并引入一个短暂的延迟，来尝试解决并发读写场景下可能出现的缓存与数据库不一致问题。
- **删除缓存**：当接收到更新数据的请求时，首先要删除缓存中对应的 Key。这样做是为了防止后续的读请求直接读取到旧的缓存数据。
- **更新数据库**：在删除缓存之后，执行数据库的更新操作，将最新的数据写入数据库。
- **延迟后再次删除缓存**：这是延迟双删策略的关键步骤。在完成数据库更新后，并不立即结束，而是会等待一个预设的时间（延迟时间），然后再执行一次删除缓存的操作。

延迟双删策略的主要目的是解决以下并发场景中可能出现的脏数据回填问题，延时时间通常设置为业务读操作耗时（从缓存未命中开始，到从数据库读取数据并最终写入缓存的整个过程所需要的时间）+ 缓冲时间。

## 4 基于消息队列的异步更新

基于消息队列的异步更新是另一种常见的解决缓存与数据库一致性问题的有效方法。通过引入消息队列作为中间件，将数据库的更新操作和缓存的更新操作解耦，实现最终一致性。
- **更新数据库：** 当应用程序需要更新数据时，首先直接更新数据库。
- **发送消息到消息队列：** 数据库更新成功后，应用程序（或者一个专门监听数据库变更的服务）向消息队列发送一条消息，该消息通常包含更新的数据标识（例如，记录的 ID）以及可能需要更新的具体内容。
- **消费者监听并更新缓存：** 一个或多个消费者服务监听消息队列中的消息。当收到与数据更新相关的消息时，消费者会根据消息中的信息，从数据库中读取最新的数据，然后更新缓存。

基于消息队列的异步更新策略通过以下方式来解决一致性问题：

- **解耦操作：** 数据库的更新和缓存的更新是异步进行的，它们之间没有直接的依赖关系。这避免了同步更新可能导致的延迟和失败风险。
- **保证最终一致性：** 虽然在数据库更新后到缓存更新完成之间可能存在短暂的不一致，但通过消息队列的可靠传递和消费机制，最终缓存会更新为与数据库一致的状态。
- **提高系统吞吐量：** 数据库更新操作完成后即可响应客户端，缓存的更新在后台异步进行，不会阻塞主流程，从而提高了系统的整体吞吐量。
- **削峰填谷：** 在高并发写入场景下，消息队列可以起到缓冲的作用，平滑数据库和缓存的更新压力。

## 5 场景化选择

1. **最终一致性场景（多数业务适用）**
    - **方案**：Cache-Aside + 延迟双删 + Binlog 兜底。
    - **Cache-Aside：** 应用程序负责缓存读写，实现简单，按需加载，减轻缓存压力。
    - **延迟双删：** 通过短暂延迟后的二次删除，降低并发读写场景下脏数据回填的概率，保证最终一致性。
    - **Binlog 兜底：** 利用数据库 Binlog 监听变更，在极端情况下（如延迟双删失败、消息丢失等），可以通过消费 Binlog 异步更新缓存，作为最终的数据一致性保障。
2. **强一致性场景（如金融账户）**
    - **方案**：分布式锁 + 同步写缓存。
    - **分布式锁：** 在更新数据库和缓存时，使用分布式锁保证同一数据在同一时刻只能被一个请求修改，避免并发竞争导致的数据不一致。
    - **同步写缓存：** 在更新数据库成功后，立即同步更新缓存，确保缓存中的数据与数据库保持强一致。牺牲了一定的写入性能，但保证了数据的实时准确性。
3. **高并发写场景（如秒杀库存）**
    - **方案**：Write-Behind + 合并写操作。
    - **Write-Behind (Write-Back)：** 应用程序只更新缓存，缓存服务将更新的数据暂时存储起来，并定期或在特定条件下批量异步同步到数据库。极大地提高了写入性能，适用于对最终一致性要求较高但对写入性能要求极高的场景。
    - **合并写操作：** 在将缓存数据同步到数据库之前，可以将对同一数据的多次写操作合并成一次，减少数据库的写入次数，进一步提升性能。但需要注意数据丢失的风险，通常需要结合持久化等机制保证可靠性。

> [!NOTE] Binlog
> Binlog（Binary Log，二进制日志）是 MySQL 数据库中非常重要的一个日志文件，它记录了数据库执行的所有**修改**操作（包括 INSERT、UPDATE、DELETE 等语句）的事件。注意，Binlog 记录的是逻辑上的操作事件，而不是物理上的数据变化。在**主从复制**、数据恢复时常用。
> Canal 模拟了 MySQL 主从复制的流程，将自己伪装成一个 MySQL 的 Slave（从服务器），向 MySQL Master（主服务器）发送请求获取 Binlog 日志。通过解析 Binlog 日志，Canal 可以实时地获取到 MySQL 数据库的变更信息。
> Canal 的主要目的是将 MySQL 的数据变更实时地同步到其他系统，例如当数据库数据发生变化时，Canal 可以实时通知缓存系统（如 Redis、Memcached）更新缓存，保持缓存与数据库的数据一致性。
