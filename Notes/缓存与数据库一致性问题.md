缓存与数据库一致性问题是指在使用缓存（如 Redis）和数据库（如 MySQL）协同工作时，由于两者数据更新不同步，可能导致读取到的数据不一致的情况。这种问题在高并发场景下尤为常见，因为缓存通常用于提升读取性能，而数据库负责持久化存储数据的完整性和准确性。当数据发生变更时，如果缓存和数据库的更新操作没有协调好，就可能出现用户读取到旧数据（脏数据）或数据缺失的情况。

## 1 Cache-Aside 旁路缓存模式

Cache-Aside 是一种常见的缓存模式，其核心思想是让应用程序**直接与缓存和数据库进行交互**，而不是由缓存系统来负责数据的加载和写入。应用程序需要自己来管理缓存的读写操作。

- **读流程**：先读缓存，缓存未命中则读数据库并回填缓存。
- **写流程**：直接更新数据库，然后**失效化**缓存中对应的条目。

高并发下可能短暂不一致，例如在数据库更新成功后，到缓存失效化完成之间，如果此时有新的读取请求，仍然可能读取到旧的缓存数据。这是一个短暂的不一致窗口。

## 2 Cache Proxy 缓存代理模式

缓存代理模式是一种结构型设计模式，它在客户端和实际的数据源（通常是数据库或后端服务）之间引入了一个缓存层作为代理。客户端不直接与数据源交互，而是通过缓存代理来访问数据。缓存代理负责处理缓存的逻辑，例如检查缓存是否存在、从缓存中获取数据、将数据写入缓存以及在必要时将请求转发给后端数据源。

- **读流程**：应用直接操作缓存代理，缓存层自行同步数据库。
- **写流程**：应用直接操作缓存代理，缓存代理的写入操作有：
    - **Write-Through (写穿透):** 缓存代理先将数据更新到后端数据源，更新成功后再更新自己的缓存。
    - **Write-Back (写回):** 缓存代理先将数据更新到自己的缓存，然后异步地将更新写入后端数据源。
    - **Write-Around (写绕过):** 缓存代理直接将写请求转发给后端数据源，不更新自己的缓存。这种策略通常用于不经常读取的数据。
    - **Invalidate (失效化):** 缓存代理更新后端数据源后，将自己缓存中对应的条目标记为失效，下次读取时会从后端重新加载。

## 3 延迟双删策略

**场景一：先删除缓存，再更新数据库，但更新数据库失败。** 此时缓存为空，但数据库中是旧数据，导致不一致。
**场景二：先更新数据库，再删除缓存，但删除缓存失败。** 此时数据库是新数据，但缓存中是旧数据，导致不一致。

- **步骤**：
    1. 删除缓存。
    2. 更新数据库。
    3. 延迟后再次删除缓存（通过消息队列或定时任务）。
- **目的**：消除并发读导致的脏数据回填。
- **延迟时间**：通常设置为业务读操作耗时 + 缓冲时间（如 500ms）。
