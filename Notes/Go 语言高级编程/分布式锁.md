分布式锁是一种用于在分布式系统中协调多个节点对共享资源的访问的机制，确保在高并发场景下数据的一致性和系统的正确性。它的作用是防止多个节点同时修改共享资源，避免数据竞争和不一致问题。常见应用包括任务调度、分布式事务和资源抢占。

---

## **什么是分布式锁？**

分布式锁是一种同步机制，用于在分布式系统中为多个节点提供互斥访问共享资源的能力。与单机环境下的锁（如 `Mutex`）类似，分布式锁的目标是确保多个节点在同一时间只能有一个节点对某个资源进行操作。

在分布式系统中，由于多个节点可能同时尝试访问或修改同一资源（如数据库记录、文件等），如果不加以控制，可能会导致数据竞争、数据一致性问题或资源冲突。分布式锁通过引入一个全局的锁机制，确保只有一个节点能够成功获取锁，从而避免这些问题。

---

## **分布式锁的作用**

1. **保证数据一致性**：
   - 在分布式环境中，多个节点可能同时对同一资源进行修改。分布式锁可以确保只有一个节点可以修改资源，从而避免数据不一致问题。
   - 示例：多个节点同时更新库存时，分布式锁可以防止超卖现象。

2. **防止资源冲突**：
   - 在高并发场景下，多个节点可能同时访问竞争性资源（如文件、数据库记录）。分布式锁可以防止资源竞争导致的冲突。
   - 示例：多个节点同时写入同一文件时，通过分布式锁确保只有一个节点可以写入，避免数据损坏。

3. **任务调度和唯一执行**：
   - 在任务调度系统中，某些任务需要确保只被执行一次。分布式锁可以用来保证任务的唯一执行。
   - 示例：定时任务调度器在多个节点上运行时，分布式锁可以防止同一任务被多个节点重复执行。

4. **实现分布式事务**：
   - 在分布式系统中，分布式锁可以用来协调多个节点的操作，确保分布式事务的一致性。

---

## **简单例子说明分布式锁的使用**

以下是两个常见的分布式锁使用场景及其实现方式：

### **例子 1：防止库存超卖**

在电商系统中，多个用户可能同时购买同一件商品。如果没有分布式锁，可能会导致库存被超卖。

**问题**：
- 商品库存为 1，但两个用户同时下单，最终库存可能变成 -1。

**解决方案**：
使用 Redis 的 `SETNX` 命令实现分布式锁，确保只有一个节点可以修改库存。

**代码示例**：

````go
package main

import (
    "fmt"
    "sync"
    "time"

    "github.com/go-redis/redis"
)

func purchaseItem(client *redis.Client, itemID string) {
    lockKey := fmt.Sprintf("lock:%s", itemID)
    stockKey := fmt.Sprintf("stock:%s", itemID)

    // 尝试获取锁
    lock, err := client.SetNX(lockKey, 1, time.Second*5).Result()
    if err != nil || !lock {
        fmt.Println("Failed to acquire lock, try again later")
        return
    }
    defer client.Del(lockKey) // 释放锁

    // 获取库存
    stock, err := client.Get(stockKey).Int64()
    if err != nil || stock <= 0 {
        fmt.Println("Out of stock")
        return
    }

    // 扣减库存
    client.Set(stockKey, stock-1, 0)
    fmt.Println("Purchase successful, remaining stock:", stock-1)
}

func main() {
    client := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
    client.Set("stock:item1", 1, 0) // 初始化库存

    var wg sync.WaitGroup
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            purchaseItem(client, "item1")
        }()
    }
    wg.Wait()
}
````

**运行结果**：
- 第一个 goroutine 成功扣减库存，输出 "Purchase successful, remaining stock: 0"。
- 第二个 goroutine 获取锁失败或发现库存不足，输出 "Out of stock"。

---

### **例子 2：任务唯一执行**

在分布式定时任务系统中，多个节点可能同时尝试执行同一任务（如发送通知）。需要确保任务只被执行一次。

**问题**：
- 多个节点同时执行任务，可能导致重复发送通知。

**解决方案**：
使用 ZooKeeper 的分布式锁，确保只有一个节点可以执行任务。

**代码示例**：

````go
package main

import (
    "time"

    "github.com/samuel/go-zookeeper/zk"
)

func main() {
    // 连接到 ZooKeeper
    conn, _, err := zk.Connect([]string{"127.0.0.1"}, time.Second)
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    // 创建分布式锁
    lock := zk.NewLock(conn, "/task_lock", zk.WorldACL(zk.PermAll))

    // 获取锁
    if err := lock.Lock(); err != nil {
        panic(err)
    }
    println("Lock acquired, executing task")

    // 执行任务
    time.Sleep(5 * time.Second)

    // 释放锁
    if err := lock.Unlock(); err != nil {
        panic(err)
    }
    println("Task completed, lock released")
}
````

**运行结果**：
- 第一个节点成功获取锁并执行任务，其他节点阻塞等待锁释放。

---

## **总结**

分布式锁是分布式系统中解决资源竞争和数据一致性问题的重要工具。通过 Redis 的 `SETNX` 和 ZooKeeper 的分布式锁，可以实现不同场景下的锁机制。选择合适的分布式锁方案需要根据业务需求、并发量和性能要求进行权衡。
