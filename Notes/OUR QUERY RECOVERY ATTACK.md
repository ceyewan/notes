在本节中，我们描述针对 CS 方案的查询重建攻击。我们首先突出攻击中利用的主要泄漏组件，然后介绍攻击的总体思想并给出伪代码。

## 1 显著的泄漏组件

我们的攻击利用了方案的以下泄漏组件：

1. **初始路径的长度**：攻击的目标是恢复查询的初始路径。初始路径的长度（或 $\text{ipLen}_i = |\text{initpath}(q_i)|$）对于攻击者限制其对初始路径的猜测范围非常有用。

2. **查询响应量**：查询响应量（或 $\text{vol}_i = |\text{DB}(\text{initpath}(q_i))|$）可以从叶节点交集模式中推断出来。这使攻击者能够提取初始路径在数据库中的频率信息。

3. **查询之间的字符相等性**
   - 从叶节点交集模式中，攻击者可以发现两个查询是否以相同的字符开头。这可以通过以下方式实现：
     - 考虑后缀树中的查询 $q_1 = "ell"$ 和 $q_2 = "elp"$。攻击者得知两个查询都访问了节点 $N_3$。这只有在两个查询的前两个字符相同时才可能发生。
     - 注意，共享字符的数量被泄漏，因为两个查询的初始路径长度比节点 $N_3$ 路径上的字符串长度多 1。
     - 我们用 $\text{charEq}(i, j) = k$ 表示 $q_i$ 和 $q_j$ 有 $k$ 个共同的字符。在上述示例中，$\text{charEq}(1, 2) = 2$。
   - 查询之间的字符相等性可以被攻击者用来进一步优化对查询的猜测。

### 1.1 泄漏信息提取

上述泄漏组件可以直接从执行 CS 方案的记录中推导出来。以下是具体的提取方法。

#### 1.1.1 **提取初始路径的长度**

回顾一下，对于查询 $q$，客户端向服务器发送 $F_{\text{sk}_1}(q[1, 1]), \dots, F_{\text{sk}_1}(q[1, |q|])$。
服务器找到最大的 $m$，使得 $F_{\text{sk}_1}(q[1, m])$ 存在于加密数据库中。由于 $m$ 的值在构造中等于初始路径的长度，服务器可以从记录中直接得知初始路径的长度。

---

#### 1.1.2 **提取查询响应量**

在搜索的最后一步，假设与查询匹配的最长初始路径是 $N$。
此时，客户端将检索 $L[\text{leafpos}(N)], \dots, L[\text{leafpos}(N) + \text{num}(N) - 1]$（最终方案中使用了其置换版本）。
检索的叶节点数量等于 $\text{num}(N)$，即与 $N$ 匹配的索引数量。这使服务器能够直接得知查询响应量。

---

#### 1.1.3 **提取查询之间的字符相等性**

为简单起见，考虑查询 $q_i$ 和 $q_j$。
对于 $q_i$，客户端计算并发送给服务器的 PRF 值为 $F_{\text{sk}_1}(q_i[1, 1]), \dots, F_{\text{sk}_1}(q_i[1, |q_i|])$。
对于 $q_j$，这些值为 $F_{\text{sk}_1}(q_j[1, 1]), \dots, F_{\text{sk}_1}(q_j[1, |q_j|])$。
关键在于，如果 $q_i$ 和 $q_j$ 有非空的公共前缀，即存在 $k \geq 1$ 满足 $q_i[1, k] = q_j[1, k]$，那么两个查询的前 $k$ 个 PRF 值会相同。
因此，服务器可以通过比较客户端发送的 PRF 值直接得知查询之间的字符相等性。

---

### 1.2 泄漏表示

在我们的攻击中，我们处理上述泄漏信息，并将加密查询表示为由整数组成的令牌列表。如果两个加密查询中出现相同的令牌，则意味着两个查询中对应的字符是相同的。例如，对于 $q_1 = "ell"$ 和 $q_2 = "elp"$，由于 $\text{charEq}(1, 2) = 2$，我们可以将加密版本的查询分别表示为 $(1, 2, 3)$ 和 $(1, 2, 4)$。我们的攻击随后尝试将令牌映射到查询中使用的字母表。

值得注意的是，我们感兴趣的加密查询的长度仅与原始查询的初始路径一样长。这是因为服务器根据设计只能获取有关初始路径的信息。

在下面的攻击描述中，我们使用以下符号：
- 我们滥用符号并将 $e_{q_i}$ 表示为 $(tk_{i,1}, \dots, tk_{i,m_i})$，其中 $m_i$ 是查询 $q_i$ 的初始路径长度。
- 我们用 $|\text{DB}(e_{q_i})|$ 表示查询 $q_i$ 的（初始路径的）查询响应量。

根据上述符号，攻击的泄漏输入简单地表示为令牌序列的集合 $(tk_{i,1}, \dots, tk_{i,m_i})_{i=1}^l$，其中 $l$ 是查询的次数，以及其对应的查询响应量 $(vol_i)_{i=1}^l$，其中 $vol_i = |\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))|$。

## 2 Our Attack

根据上述泄漏信息，我们设计了一种推断攻击，试图恢复与令牌对应的字母表，从而恢复查询的初始路径。

### 2.1 核心思想

我们的攻击包含三个核心组件：

1. **确定候选集（Candidate Set）**
   首先，我们需要为每个加密查询确定我们想要进行的猜测集合，这称为加密查询的候选集。在高层次上，借助一些辅助信息，我们可以利用初始路径的长度和查询响应量来排除每个加密查询中不太可能的猜测。随后，我们可以利用查询之间的字符相等性泄漏进一步缩小候选集的大小。

2. **建立统计模型**
   一旦为所有加密查询获得候选集，我们需要构建一个统计模型来衡量对加密查询的猜测与观察到的泄漏信息的匹配程度。为此，我们使用泊松分布（Poisson distribution）来建模子字符串出现的次数，其中分布的参数由一些辅助数据决定。接着，我们计算在给定观察到的泄漏组件的情况下，某一猜测的可能性（似然值）。

3. **高效搜索算法**
   最后，我们需要使用一种高效的算法，在可能的猜测集合中进行搜索，找到基于统计模型最可能的猜测。

通过这三个步骤，我们能够有效地利用泄漏信息恢复查询的初始路径。
