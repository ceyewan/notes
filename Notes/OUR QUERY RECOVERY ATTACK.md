在本节中，我们描述针对 CS 方案的查询重建攻击。我们首先突出攻击中利用的主要泄漏组件，然后介绍攻击的总体思想并给出伪代码。

## 1 显著的泄漏组件

我们的攻击利用了方案的以下泄漏组件：

1. **初始路径的长度**：攻击的目标是恢复查询的初始路径。初始路径的长度（或 $\text{ipLen}_i = |\text{initpath}(q_i)|$）对于攻击者限制其对初始路径的猜测范围非常有用。

2. **查询响应量**：查询响应量（或 $\text{vol}_i = |\text{DB}(\text{initpath}(q_i))|$）可以从叶节点交集模式中推断出来。这使攻击者能够提取初始路径在数据库中的频率信息。

3. **查询之间的字符相等性**
   - 从叶节点交集模式中，攻击者可以发现两个查询是否以相同的字符开头。这可以通过以下方式实现：
     - 考虑后缀树中的查询 $q_1 = "ell"$ 和 $q_2 = "elp"$。攻击者得知两个查询都访问了节点 $N_3$。这只有在两个查询的前两个字符相同时才可能发生。
     - 注意，共享字符的数量被泄漏，因为两个查询的初始路径长度比节点 $N_3$ 路径上的字符串长度多 1。
     - 我们用 $\text{charEq}(i, j) = k$ 表示 $q_i$ 和 $q_j$ 有 $k$ 个共同的字符。在上述示例中，$\text{charEq}(1, 2) = 2$。
   - 查询之间的字符相等性可以被攻击者用来进一步优化对查询的猜测。

### 1.1 泄漏信息提取

上述泄漏组件可以直接从执行 CS 方案的记录中推导出来。以下是具体的提取方法。

#### 1.1.1 **提取初始路径的长度**

回顾一下，对于查询 $q$，客户端向服务器发送 $F_{\text{sk}_1}(q[1, 1]), \dots, F_{\text{sk}_1}(q[1, |q|])$。
服务器找到最大的 $m$，使得 $F_{\text{sk}_1}(q[1, m])$ 存在于加密数据库中。由于 $m$ 的值在构造中等于初始路径的长度，服务器可以从记录中直接得知初始路径的长度。

---

#### 1.1.2 **提取查询响应量**

在搜索的最后一步，假设与查询匹配的最长初始路径是 $N$。
此时，客户端将检索 $L[\text{leafpos}(N)], \dots, L[\text{leafpos}(N) + \text{num}(N) - 1]$（最终方案中使用了其置换版本）。
检索的叶节点数量等于 $\text{num}(N)$，即与 $N$ 匹配的索引数量。这使服务器能够直接得知查询响应量。

---

#### 1.1.3 **提取查询之间的字符相等性**

为简单起见，考虑查询 $q_i$ 和 $q_j$。
对于 $q_i$，客户端计算并发送给服务器的 PRF 值为 $F_{\text{sk}_1}(q_i[1, 1]), \dots, F_{\text{sk}_1}(q_i[1, |q_i|])$。
对于 $q_j$，这些值为 $F_{\text{sk}_1}(q_j[1, 1]), \dots, F_{\text{sk}_1}(q_j[1, |q_j|])$。
关键在于，如果 $q_i$ 和 $q_j$ 有非空的公共前缀，即存在 $k \geq 1$ 满足 $q_i[1, k] = q_j[1, k]$，那么两个查询的前 $k$ 个 PRF 值会相同。
因此，服务器可以通过比较客户端发送的 PRF 值直接得知查询之间的字符相等性。

---

### 1.2 泄漏表示

在我们的攻击中，我们处理上述泄漏信息，并将加密查询表示为由整数组成的令牌列表。如果两个加密查询中出现相同的令牌，则意味着两个查询中对应的字符是相同的。例如，对于 $q_1 = "ell"$ 和 $q_2 = "elp"$，由于 $\text{charEq}(1, 2) = 2$，我们可以将加密版本的查询分别表示为 $(1, 2, 3)$ 和 $(1, 2, 4)$。我们的攻击随后尝试将令牌映射到查询中使用的字母表。

值得注意的是，我们感兴趣的加密查询的长度仅与原始查询的初始路径一样长。这是因为服务器根据设计只能获取有关初始路径的信息。

在下面的攻击描述中，我们使用以下符号：
- 我们滥用符号并将 $e_{q_i}$ 表示为 $(tk_{i,1}, \dots, tk_{i,m_i})$，其中 $m_i$ 是查询 $q_i$ 的初始路径长度。
- 我们用 $|\text{DB}(e_{q_i})|$ 表示查询 $q_i$ 的（初始路径的）查询响应量。

根据上述符号，攻击的泄漏输入简单地表示为令牌序列的集合 $(tk_{i,1}, \dots, tk_{i,m_i})_{i=1}^l$，其中 $l$ 是查询的次数，以及其对应的查询响应量 $(vol_i)_{i=1}^l$，其中 $vol_i = |\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))|$。

## 2 Our Attack

根据上述泄漏信息，我们设计了一种推断攻击，试图恢复与令牌对应的字母表，从而恢复查询的初始路径。

### 2.1 核心思想

我们的攻击包含三个核心组件：

1. **确定候选集（Candidate Set）**
   首先，我们需要为每个加密查询确定我们想要进行的猜测集合，这称为加密查询的候选集。在高层次上，借助一些辅助信息，我们可以利用初始路径的长度和查询响应量来排除每个加密查询中不太可能的猜测。随后，我们可以利用查询之间的字符相等性泄漏进一步缩小候选集的大小。

2. **建立统计模型**
   一旦为所有加密查询获得候选集，我们需要构建一个统计模型来衡量对加密查询的猜测与观察到的泄漏信息的匹配程度。为此，我们使用泊松分布（Poisson distribution）来建模子字符串出现的次数，其中分布的参数由一些辅助数据决定。接着，我们计算在给定观察到的泄漏组件的情况下，某一猜测的可能性（似然值）。

3. **高效搜索算法**
   最后，我们需要使用一种高效的算法，在可能的猜测集合中进行搜索，找到基于统计模型最可能的猜测。

通过这三个步骤，我们能够有效地利用泄漏信息恢复查询的初始路径。

### 2.2 确定候选集

定义候选集 $\text{CandSet} : \mathbb{N}^* \to \mathcal{P}(\Sigma^*)$，它将令牌序列映射到所有可能字符串的子集。我们的目标是为每个加密查询找到候选集，并尽可能缩小候选集的大小，以便后续的搜索过程更加高效。

---

#### 2.2.1 攻击中的步骤

1. **频率分析**
   在攻击的第一步中，我们依赖于频率分析。假设存在一些辅助信息 $\text{Aux} : \Sigma^* \to \mathbb{R}$，其中 $\text{Aux}(s)$ 表示攻击者对查询 $s$ 的预期查询响应量。攻击者可以简单地设置：

   $$
   \text{CandSet}((tk_{i,1}, \dots, tk_{i,m_i})) = \{ s : |s| = m_i \land \left| |\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))| - \text{Aux}(s) \right| < \epsilon \cdot \sqrt{|\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))|} \}
   $$

   其中 $\epsilon$ 是某个阈值。这正是我们在攻击中所采用的方法。我们将在第 5 节中描述如何通过真实世界数据集的实验确定阈值 $\epsilon$。

2. **问题与解决方案**
   上述步骤的问题在于，生成的候选集通常非常大（大小在 $10^3$ 左右甚至更多）。对于 $l$ 个查询，搜索空间大约为 $10^{3l}$，这使得在空间上的高效搜索变得不可行。因此，我们引入了一种方法，在运行攻击的主要算法之前，先对搜索空间进行修剪。

---

#### 2.2.2 修剪算法的核心思想

修剪算法的核心思想是，针对每个令牌（而不是整个令牌序列）的候选集进行分析，利用这些候选集确定每个令牌最可能的字符。这些字符随后可以用于修剪候选集。

#### 2.2.3 示例

考虑以下候选集：

- 对于令牌序列 $(1, 2, 3)$，有 $\text{CandSet}((1, 2, 3)) = \{"ell", "ali"\}$。
- 对于令牌序列 $(1, 2, 4)$，有 $\text{CandSet}((1, 2, 4)) = \{"elp", "bob"\}$。

从中可以得出，令牌 1 对应的字符最可能是 "e"，因为它出现在两个候选集中。这使得我们可以将候选集修剪为：

- $\text{CandSet}((1, 2, 3)) = \{"ell"\}$
- $\text{CandSet}((1, 2, 4)) = \{"elp"\}$

一个可能的复杂性在于，真实查询可能未包含在候选集中（因为观察到的查询响应量与子字符串的预期频率偏差过大）。因此，我们采用一种软决策过程，即使某些字符未出现在所有候选集中，它们仍可能被视为可能的字符。

### 2.3 初始化数组与修剪过程

我们初始化一个数组 $\text{Arr} : \mathbb{N} \times \Sigma \to \mathbb{N}$，将令牌和字母表中的字符映射到一个整数。这个数组被初始化为所有可能的令牌 - 字符对，且值设置为零。

---

#### 2.3.1 修剪过程

1. **记录字符出现频率**
   对于每个观察到的令牌序列 $(tk_{i,1}, \dots, tk_{i,m_i})$，我们统计候选集 $\text{CandSet}((tk_{i,1}, \dots, tk_{i,m_i}))$ 中每个位置出现的字符。对于令牌序列中的每个令牌 $tk$ 和对应位置出现的每个字符 $c$，我们将 $\text{Arr}(tk, c)$ 的值加 1。

2. **创建映射**
   在所有令牌序列的处理完成后，我们创建一个映射 $\text{TokenCandSet} : \mathbb{N} \to \mathcal{P}(\Sigma)$，将每个令牌映射到字母表的一个子集。对于令牌 $tk$，$\text{TokenCandSet}(tk)$ 被设置为字符集合 $c$，其中 $\text{Arr}(tk, c)$ 的值是 $\text{Arr}(tk, \cdot)$ 中最大的 $t$ 个值之一。

3. **处理相同最大值的情况**
   如果有多个字符共享最大的值，则将所有具有最大值的字符加入 $\text{TokenCandSet}(tk)$。

4. **修剪候选集**
   映射 $\text{TokenCandSet}$ 随后可以用于修剪 $\text{CandSet}$。这一过程会重复进行，直到 $\text{CandSet}$ 在修剪过程中不再变化为止。

---

### 2.4 算法 --- 确定候选集

该算法用于识别加密查询的候选明文字符串集合。它通过初步过滤和逐步修剪的方法，结合辅助分布（Aux）和查询响应量，最终确定每个令牌序列对应的候选明文集合。

---

#### 2.4.1 **算法的输入与输出**

- **输入**：
  - $(\text{vol}_i)_{i=1}^l$：查询响应量（即每个查询返回的数据库记录数）。
  - $(tk_{i,1}, \dots, tk_{i,m_i})_{i=1}^l$：从加密查询中提取的令牌序列。
  - $\text{Aux}$：辅助分布，提供可能的明文字符串及其频率。

- **输出**：
  - $\text{CandSet} : \mathbb{N}^* \to \mathcal{P}(\Sigma^*)$：将每个令牌序列映射到可能的明文字符串集合。

---

#### 2.4.2 **主函数：`Candidate_Set`**

1. **初始化候选集**：
   - 创建一个空的候选集映射 $\text{CandSet}$。

2. **初步过滤**：
   - 遍历所有查询序列 $(tk_{i,1}, \dots, tk_{i,m_i})$，根据查询响应量 $\text{vol}_i$ 和辅助分布 $\text{Aux}$ 进行初步过滤：

     $$
     \text{CandSet}((tk_{i,1}, \dots, tk_{i,m_i})) = \{ s \in \text{Aux} \mid |s| = m_i \land |\text{vol}_i - \text{Aux}(s)| \leq \epsilon \cdot \sqrt{\text{vol}_i} \}
     $$

     这里 $\epsilon$ 是控制误差的阈值。

3. **修剪候选集**：
   - 调用函数 `Trim_Candidates` 对候选集进行修剪，进一步缩小候选集的大小。

4. **迭代修剪**：
   - 重复调用 `Trim_Candidates`，直到候选集 $\text{CandSet}$ 在修剪过程中不再发生变化。

5. **返回候选集**：
   - 返回最终的 $\text{CandSet}$。

---

#### 2.4.3 **修剪函数：`Trim_Candidates`**

1. **初始化数组 $\text{Arr}$**：
   - 创建一个二维数组 $\text{Arr} : \mathbb{N} \times \Sigma \to \mathbb{N}$，用于统计每个令牌与字符的匹配频率。初始值为零。

2. **统计字符频率**：
   - 遍历每个令牌序列 $(tk_{i,1}, \dots, tk_{i,m_i})$ 和候选字符串 $\text{cand} \in \text{CandSet}((tk_{i,1}, \dots, tk_{i,m_i}))$：
     - 对于候选字符串中每个位置的字符 $c$，增加 $\text{Arr}(tk_{i,j}, c)$ 的值。

3. **生成令牌候选字符集**：
   - 初始化一个空的映射 $\text{TokenCandSet} : \mathbb{N} \to \mathcal{P}(\Sigma)$。
   - 对每个令牌 $tk$，根据 $\text{Arr}(tk, \cdot)$ 的值降序排序，选择频率最高的前 $t$ 个字符作为 $\text{TokenCandSet}(tk)$。
   - 如果有多个字符的频率相同且超出 $t$ 个，则将这些字符全部加入 $\text{TokenCandSet}(tk)$。

4. **修剪候选集**：
   - 遍历候选集 $\text{CandSet}$，保留满足以下条件的候选字符串：
     - 字符串的每个字符都属于对应令牌的候选字符集合 $\text{TokenCandSet}$。

5. **返回修剪后的候选集**：
   - 返回修剪后的 $\text{CandSet}'$。

#### 2.4.4 **主函数**

```plaintext
1. 初始化候选集 CandSet 为一个空映射。
2. 遍历每个查询序列，根据查询响应量和辅助分布进行初步过滤，生成候选集。
3. 调用 Trim_Candidates 函数对候选集进行修剪。
4. 重复修剪过程，直到候选集不再变化。
5. 返回最终的候选集。
```

#### 2.4.5 **修剪函数**

```plaintext
1. 初始化统计数组 Arr 为零。
2. 遍历每个查询序列和候选字符串，统计字符频率。
3. 根据统计结果生成令牌候选字符集 TokenCandSet。
4. 使用 TokenCandSet 修剪候选集，保留符合条件的字符串。
5. 返回修剪后的候选集。
```

---

#### 2.4.6 **关键点解析**

1. **初步过滤**：
   - 利用辅助分布和查询响应量，快速排除不可能的候选字符串，显著减少搜索空间。
2. **修剪过程**：
   - 基于字符频率的统计，进一步缩小候选集大小，确保每个令牌只匹配最可能的字符。
3. **迭代修剪**：
   - 修剪过程是递归的，直到候选集不再变化为止，确保结果的稳定性。
4. **处理相同频率的字符**：
   - 在字符频率相同时，算法会将这些字符全部纳入候选字符集，避免遗漏潜在的正确字符。

---

### 2.5 **观察到的泄漏的统计模型**

给定候选集 $\text{CandSet}$，攻击者可以开始对查询初始路径的明文进行猜测 $\text{guess} : \mathbb{N}^* \to \Sigma^*$。然而，我们需要衡量每个猜测的质量，以便选择最佳猜测作为攻击的输出。为此，我们使用泊松分布对查询的响应量进行建模。这些单独的分布结合在一起，形成所有查询的联合分布。随后，我们应用标准统计技术，将联合分布转化为似然函数。

---

### 2.6 **猜测的一致性**

需要注意的是，在上述攻击的描述中，猜测是针对每个查询单独进行的。这意味着可能出现以下情况：

$$
\text{guess}((1, 2, 3)) = \text{"elp"} \quad \text{和} \quad \text{guess}((1, 2, 4)) = \text{"bob"}
$$

即使我们知道这两个查询的前两个字符必须相同。

在我们的攻击中，我们选择以迭代的方式进行猜测，并跟踪我们对单个令牌所做的猜测。新的猜测可以覆盖旧的猜测。具体来说，对于上述示例，我们会先进行猜测 $\text{guess}((1, 2, 3)) = \text{"elp"}$，然后进行 $\text{guess}((1, 2, 4)) = \text{"bob"}$。由于第二次猜测覆盖了对令牌 1 和 2 的猜测，它将 $\text{guess}((1, 2, 3))$ 改为 $\text{"bop"}$。

这种方法允许我们在保持令牌一致性的同时进行猜测，但可能会导致查询的猜测次优。我们认为这不是一个主要问题，因为次优猜测会产生较低的似然分数，而优化算法（在后续描述中）不太可能接受这些猜测。

---

### 2.7 **最大化似然函数**

我们使用模拟退火（Simulated Annealing）方法 [61] 来最大化似然函数。对应的伪代码可以在算法 2 中找到（其中的评分函数 $\text{score()}$ 就是前面数学上描述的似然函数）。该过程涉及以下五个主要子程序：

1. **`Initial_solution(CandSet)`**
   该算法以候选集 $\text{CandSet}$ 作为输入，并输出一个猜测 $\text{guess}$，作为模拟退火的初始解。

2. **`Neighbour(guess, CandSet)`**
   该算法以当前猜测 $\text{guess}$ 和候选集 $\text{CandSet}$ 作为输入，并输出一个接近 $\text{guess}$ 的新猜测 $\text{guess}'$。

3. $score(guess, (tki,1, \dots, tki,mi)_{i=1}^l, (voli)_{i=1}^l, \text{Aux})$
   该算法以以下输入计算得分 $\text{sc}$：
   - 猜测 $\text{guess}$
   - 查询的令牌列表 $(tki,1, \dots, tki,mi)_{i=1}^l$
   - 查询响应量 $(voli)_{i=1}^l$
   - 辅助分布 $\text{Aux}$
   输出为一个得分 $\text{sc}$。

4. **`Cooling(T)`**
   该算法以温度 $T$ 作为输入，并输出一个新的温度 $T'$。

5. **`Accept_prob(sc, sc', T)`**
   该算法以两个分数 $\text{sc}$ 和 $\text{sc}'$，以及温度 $T$ 作为输入，根据输入和一定的随机性输出 0 或 1。

---

### 2.8 模拟退火的完整过程

1. **初始化**：运行 `Initial_solution(CandSet)` 获取初始猜测 $\text{guess}$。
2. **温度初始化**：设置初始温度 $T$。
3. **迭代过程**：在固定的迭代次数内，重复以下步骤：
   - 调用冷却子程序 `Cooling(T)` 获取新的温度 $T'$。
   - 计算当前猜测的邻居 $\text{guess}'$（通过 `Neighbour(guess, CandSet)`）。
   - 计算新猜测的得分 $\text{sc}'$（通过 $score(guess', (tki,1, \dots, tki,mi)_{i=1}^l, (voli)_{i=1}^l, \text{Aux})$）。
   - 计算当前猜测的得分 $\text{sc}$。
   - 调用 `Accept_prob(sc, sc', T)` 获取输出 0 或 1：
     - 如果输出为 0，则保持当前猜测不变，进入下一次迭代。
     - 如果输出为 1，则用新猜测 $\text{guess}'$ 替换当前猜测 $\text{guess}$，进入下一次迭代。

### 2.9 算法 2：基于模拟退火的攻击过程

该算法通过模拟退火（Simulated Annealing）方法，优化对加密查询中令牌的猜测，最终输出一个最优的猜测结果。以下是对算法各部分的详细解读：

---

#### 2.9.1 **输入**

- **查询响应量** $(voli)_{i=1}^l$：记录加密查询的响应量。
- **令牌序列** $(tki,1, \dots, tki,mi)_{i=1}^l$：从加密查询中提取的令牌序列。
- **候选集** $\text{CandSet}$：每个令牌可能的候选值集合。
- **辅助分布** $\text{Aux}$：用于计算得分的辅助信息。
- **最大迭代次数** $\text{itermax}$：模拟退火的迭代次数。

---

#### 2.9.2 **输出**

- 一个猜测函数 $\text{guess} : \mathbb{N} \to \Sigma$，表示对加密查询中令牌的最终猜测。

---

#### 2.9.3 **初始化**

- 调用 `Initial_solution(CandSet)` 函数，生成初始猜测 $\text{guess}$。
- 初始化温度 $T$。

#### 2.9.4 **迭代优化**

在固定的迭代次数 $\text{itermax}$ 内，重复以下步骤：
1. **冷却**：调用 `Cooling(T)` 函数，更新温度 $T'$。
2. **生成邻居解**：调用 `Neighbour(guess, CandSet)` 函数，生成当前猜测 $\text{guess}$ 的邻居解 $\text{guess}'$。
3. **计算得分**：
   - 对当前猜测 $\text{guess}$ 计算得分 $\text{sc}$。
   - 对邻居猜测 $\text{guess}'$ 计算得分 $\text{sc}'$。
4. **接受或拒绝邻居解**：
   - 调用 `Accept_prob(sc, sc', T)` 函数，根据概率决定是否接受邻居解。
   - 如果接受，则更新当前猜测 $\text{guess} = \text{guess}'$。

#### 2.9.5 **输出结果**

- 返回最终的猜测 $\text{guess}$。

---

#### 2.9.6 **1. `Initial_solution(CandSet)`**

- 功能：生成初始猜测 $\text{guess}$。
- 过程：
  1. 初始化空猜测 $\text{guess} = \{\}$。
  2. 遍历候选集中每个令牌序列 $(tki,1, \dots, tki,mi)$：
     - 从候选集中随机选择一个候选值 $\text{cand}$。
     - 将 $\text{cand}$ 中的每个值赋给对应的令牌 $tki,j$。
  3. 返回初始猜测 $\text{guess}$。

---

#### 2.9.7 **2. `Neighbour(guess, CandSet)`**

- 功能：生成当前猜测的邻居解 $\text{guess}'$。
- 过程：
  1. 初始化邻居解 $\text{guess}' = \text{guess}$。
  2. 从候选集中随机选择一个令牌序列 $(tki,1, \dots, tki,mi)$。
  3. 从该令牌序列的候选值集合中随机选择一个候选值 $\text{cand}$。
  4. 更新邻居解 $\text{guess}'$ 中对应的令牌值。
  5. 返回邻居解 $\text{guess}'$。

---

#### 2.9.8 $score(guess, (tki,1, \dots, tki,mi)_{i=1}^l, (voli)_{i=1}^l, \text{Aux})$

- 功能：计算当前猜测 $\text{guess}$ 的得分 $\text{sc}$。
- 输入：
  - 当前猜测 $\text{guess}$。
  - 查询的令牌序列 $(tki,1, \dots, tki,mi)_{i=1}^l$。
  - 查询响应量 $(voli)_{i=1}^l$。
  - 辅助分布 $\text{Aux}$。
- 输出：一个评分 $\text{sc}$，用于衡量猜测的质量。

---

#### 2.9.9 **4. `Cooling(T)`**

- 功能：更新温度 $T$。
- 输出：新的温度 $T'$，通常根据冷却策略逐渐降低温度。

---

#### 2.9.10 **5. `Accept_prob(sc, sc', T)`**

- 功能：根据概率决定是否接受邻居解。
- 过程：
  1. 计算接受概率：

     $$
     P = \exp\left(\frac{\text{sc}' - \text{sc}}{T}\right)
     $$

  2. 生成一个范围在 [0, 1] 的随机数 $\text{rand}(0, 1)$。
  3. 如果 $P > \text{rand}(0, 1)$，则返回 1（接受邻居解）；否则返回 0（拒绝邻居解）。

---

#### 2.9.11 **算法特点**

1. **随机性与全局优化**：模拟退火通过随机性避免陷入局部最优解，逐步逼近全局最优解。
2. **温度控制**：通过冷却策略逐步降低温度，减少随机扰动，逐步收敛到最优解。
3. **灵活性**：算法可以适配不同的候选集和评分函数，具有较强的通用性。

---
