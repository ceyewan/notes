## 1 垃圾回收算法

### 1.1 背景：为什么要 GC

在程序运行过程中，**动态分配的内存**（如堆内存）需要手动管理。如果内存未正确释放，会导致内存泄漏；如果过早释放，会导致悬空指针。手动管理内存容易出错，尤其是在复杂的程序中。

垃圾回收器（Garbage Collector, GC）自动管理内存，识别并回收不再使用的对象，从而减少内存泄漏和悬空指针问题，提高开发效率和程序稳定性。

GC 会引入额外的运行时开销（如 CPU 和内存占用），并可能导致程序暂停（**Stop-The-World**, STW）。因此，GC 的设计需要在性能和内存管理之间权衡。

### 1.2 标记 - 清扫算法（Mark-Sweep）

- **标记阶段**：从根对象（如全局变量、栈上的引用）开始，遍历所有可达对象，标记为 " 存活 "。
- **清扫阶段**：扫描整个内存空间，将未被标记的对象（即不可达对象）回收，释放其内存。
- **特点**：简单，但会产生内存碎片（回收后空闲内存不连续）。

### 1.3 标记 - 压缩算法（Mark-Compact）

- **标记阶段**：与标记清扫相同，标记所有存活对象。
- **压缩阶段**：将所有存活对象移动到内存的一端，挤出中间的空隙，剩余空间变为连续的空闲内存。
- **特点**：解决了内存碎片问题，但移动对象增加了额外开销。

### 1.4 半空间复制算法（Semi-Space Copying）

- 将内存分为两个相等的半空间（From 和 To），每次只使用一个半空间。
- 当 From 空间满时，将存活对象复制到 To 空间（复制过程中整理顺序），然后清空 From 空间，交换 From 和 To 的角色。
- **特点**：无碎片，适合存活对象少的场景，但浪费一半内存。

### 1.5 引用计数方法（Reference Counting）

- 为每个对象维护一个计数器，记录被引用的次数。
- 每次新增引用时计数加 1，引用失效时减 1；当计数为 0 时，对象被回收。
- **特点**：实现简单，回收及时，但无法处理循环引用（两个对象互相引用，计数永不为 0）。

## 2 并发三色标记法

### 2.1 三色标记法

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250313164755.png)
三色标记法由 Dijkstra 提出，属于一种标记清扫算法：

- 所有的对象分为三种颜色；
- **白色**：尚未访问的对象，可能为垃圾；
- **灰色**：已访问但其引用的对象还未完全检查的对象（中间状态）；
- **黑色**：已访问且所有引用的对象都已检查完毕的对象（确定存活）。

**工作流程**：
1. 从根对象（如全局变量、栈变量）开始，标记为灰色。
2. 每次从灰色集合中取出一个对象，检查其引用的所有对象：
    - 将引用的对象标记为灰色（加入灰色集合）；
    - 将当前对象标记为黑色（检查完成）。
- 重复此过程，直到灰色集合为空。
- 最后，白色对象即为不可达的垃圾，可以回收。

### 2.2 并发垃圾回收

Go 语言引入了并发垃圾回收机制，允许用户协程（Mutator）和后台的 GC 协程并发运行。这一设计显著提高了程序的响应性，减少了 " 停止世界 "（Stop-The-World, STW）的暂停时间，尤其是在高并发、低延迟需求的场景下。然而，并发带来的复杂性也引入了一些挑战，如漏标、多标和内存碎片问题。

#### 2.2.1 漏标问题

**漏标问题**是指在并发执行时，部分存活对象未被正确标记为 " 黑色 " 或 " 灰色 "，被误认为是 " 白色 "（垃圾），从而被错误回收。这会导致程序访问无效内存，引发崩溃或数据丢失。

在三色标记法中，GC 协程逐步扫描对象图时，用户协程可能同时修改对象引用。如果没有适当的同步机制，可能破坏三色不变性（即黑色对象不能指向白色对象）。例如：

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250313171952.png)

- 初始状态：对象 A（黑色）被扫描完成；此时对象 B 是灰色，还未完成扫描；C 是白色；
- 用户协程建立 A 指向对象 C 的引用，B 删除指向对象 C 的引用；
- GC 未察觉这一变化，扫描不到 C，最后 C 仍为白色，最终被回收。

Go 使用**写屏障（Write Barrier）** 解决漏标问题。当用户协程修改引用时，写屏障确保新引用的对象被标记为灰色，避免其被错误回收。这增加了少量运行时开销，但保证了正确性。

#### 2.2.2 多标问题

**多标问题**是指部分垃圾对象被错误标记为存活（灰色或黑色），导致 GC 未及时回收它们。相比漏标，多标的影响较小，仅会推迟垃圾回收，增加内存占用，但在高吞吐量场景下可能累积为问题。

多标通常发生在用户协程快速创建和丢弃临时对象时，GC 标记过程未能及时跟上。例如：
- 一个对象在标记开始时被引用（灰色），但在标记完成前引用被移除。
- 由于并发性，GC 未更新其状态，该对象被误认为存活。

多标不会导致程序错误，仅影响内存使用效率。Go 的 GC 通过后续周期逐步清理这些对象，问题可自愈，因此通常不视为严重问题。

#### 2.2.3 内存碎片问题

三色标记法本质上是**标记 - 清扫（Mark-Sweep）** 算法的一种改进，因此无法避免内存碎片问题。回收后，未使用的内存块可能分散在堆中，形成外部碎片，降低内存分配效率。

Go 采用 **TCMalloc（Thread-Caching Malloc）** 内存分配器，按对象大小将其分配到预定义的 **spanClass** 中：

- 小对象（<32KB）：按大小分级（如 8B、16B、32B 等），分配到固定大小的 span。
- 大对象（>32KB）：直接分配连续内存。
- 回收时，span 内的空闲块可重用，减少外部碎片。

因此，通过 spanClass 分类，分散的内存被限制在 span 内部，外部碎片问题得以缓解。此外，由于 span 大小固定，小对象可能浪费部分空间，但这种开销可控，且远小于外部碎片的影响。

> [!NOTE] Slab Allocater
> TCMalloc 的思想类似于 Linux 内核的 Slab Allocator，后者也按大小划分缓存（如 kmalloc-32、kmalloc-64），高效管理内存。Go 的实现更专注于用户态的高并发场景。

### 2.3 为什么不使用分代 GC

**分代 GC** 将对象分为年轻代（Young Generation）和老年代（Old Generation），基于 " 大部分对象生命周期短 " 的假设，对年轻代采用高效的复制算法（如半空间复制），对老年代使用标记 - 清扫或标记 - 压缩。这种方法在 Java 和 .NET 中常见，但 Go 选择不使用分代 GC，主要原因如下：

1. **内存逃逸**：内存逃逸是指在编译期间，Go 编译器通过静态分析确定某些变量的生命周期超出了当前函数的作用域，因此无法安全分配在栈上，必须 " 逃逸 " 到堆上，由垃圾回收器管理。
2. **栈回收**：在 Go 中，每个 goroutine 拥有独立的栈空间，用于存储局部变量和函数调用信息。当 goroutine 退出或函数返回时，其栈上的内存会被自动回收。这种回收机制无需 GC 干预，效率极高。

Go 通过逃逸分析和栈回收替代了分代 GC 的年轻代功能，配合并发三色标记法管理堆上对象。这种设计既保持了低延迟，又避免了分代 GC 的复杂性和潜在 STW 开销，完美契合 Go 的高并发、低复杂性目标。

## 3 混合写屏障机制

漏标问题的核心在于并发垃圾回收中，三色标记法的标记过程可能因对象引用关系的动态变化而失效。具体来说，漏标发生在以下情况：一个已扫描完成的黑色对象（标记为存活且不再检查）指向了一个白色对象（尚未标记，可能被视为垃圾），而该白色对象此前被某个灰色或白色对象删除引用。归纳为两点：
1. **黑色对象指向白色对象**：违反了三色标记的基本假设。
2. **灰色或白色对象删除了对白色对象的引用**：导致该白色对象失去从根可达的路径，面临被误回收的风险。

为解决漏标问题，提出了一套基于 " **强弱三色不变式** " 的理论框架，用于约束对象引用关系，确保标记过程的正确性：

1. **强三色不变式**
    - **定义**：禁止黑色对象直接引用白色对象。
    - **作用**：直接破坏 " 黑色对象指向白色对象 " 的情况（即漏标条件 1），确保任何白色对象在被黑色对象引用前必须先被标记为灰色（待检查状态）。
    - **实现方式**：在引用建立时介入保护机制。
2. **弱三色不变式**
    - **定义**：允许黑色对象引用白色对象，但要求存在一条从某个灰色对象出发的可达路径通向该白色对象。
    - **作用**：间接破坏漏标条件 1 和 2 的联动，即通过保留可达性，确保白色对象不会因引用删除而被误判为垃圾。
    - **实现方式**：在引用删除时介入保护机制。

强弱不变式分别从不同角度解决漏标，提供灵活的实现选择，实际应用中常结合具体屏障机制。

### 3.1 插入写屏障

**插入写屏障**是一种在对象引用创建时触发的保护机制，类似于回调函数，在特定动作（如建立新引用）完成前执行预设操作。

当用户协程试图让一个黑色对象指向一个白色对象时，插入写屏障会先触发，将目标白色对象标记为灰色（加入待扫描队列），然后再建立引用关系。这样，白色对象在被引用前已被置灰，避免了漏标。

**目标**：实现**强三色不变式**，确保黑色对象无法直接引用白色对象。

### 3.2 删除写屏障

**删除写屏障**是一种在对象引用删除时触发的保护机制，旨在防止因引用断开导致的漏标。当用户协程从某个对象（可能是灰色或白色）移除对下游白色对象的引用时，删除写屏障会先触发，将该白色对象标记为灰色（加入待扫描队列），然后再执行删除操作。这样，即使上游引用断开，白色对象仍通过灰色状态保留可达性，避免被误回收。

**目标**：实现**弱三色不变式**，确保白色对象在失去上游引用时仍能保持可达性。

### 3.3 混合写屏障

虽然插入写屏障和删除写屏障都能单独解决漏标问题，但它们在性能和实现复杂度上存在明显缺陷：

1. **插入写屏障（Dijkstra 屏障）的问题**：
    - **栈操作开销大**：为了确保正确性，插入屏障需要对堆和栈的所有写操作进行拦截。但栈上的写操作（尤其是频繁的局部变量修改）会导致大量屏障触发，严重影响性能。
    - **需要 STW（Stop-The-World）**：在标记结束时，必须重新扫描栈来捕获栈上可能新增的引用，这会导致较长的停顿时间。

2. **删除写屏障（Yuasa 屏障）的问题**：
    - **浮动垃圾较多**：删除屏障会保守地将被删除引用的对象标记为存活，即使这些对象实际上已经不可达，导致更多对象存活到下一轮 GC。
    - **无法处理新增引用**：如果黑色对象新增了一个对白色对象的引用，删除屏障无法捕获这种情况，必须结合其他机制（如重新扫描）。

**混合写屏障的核心目标**：在避免漏标的前提下，减少对栈操作的侵入性，并降低浮动垃圾的数量，从而在性能和正确性之间取得平衡。

Go的混合写屏障结合了插入写屏障和删除写屏障的核心思想，具体规则如下：

1. **写操作触发屏障**：当堆上的对象指针被修改时（即写操作发生），触发混合写屏障。    
2. **对新引用执行插入屏障**：将新指向的对象（即写入的指针目标）标记为灰色（存活）。
3. **对旧引用执行删除屏障**：将被覆盖的旧指针指向的对象也标记为灰色（存活）。