libp2p 是一个去中心化网络框架，旨在简化分布式点对点（P2P）应用程序的构建。它通过提供一套模块化的网络组件，帮助开发者解决构建大规模、可靠和高效的 P2P 系统中的各种挑战。libp2p 使得开发者可以在多种传输协议、内容发现机制和身份验证方式中选择最适合的方案，从而构建高效、安全且具可扩展性的去中心化应用。

> [!NOTE] P2P
> P2P（Peer-to-Peer）网络是一种分布式网络架构，在这种架构中，所有参与节点（或设备）在网络中都是对等的，具备相同的权利和能力来提供服务、共享资源或交换信息。与传统的客户端-服务器（C/S）模型不同，P2P 网络没有中心化的服务器，所有节点既可以作为客户端也可以作为服务器。

## 1 Key Concepts

### 1.1 Transport

libp2p 使开发者能够灵活选择适合其应用需求的传输协议。传输协议位于网络栈的底层，libp2p 支持 TCP 和 QUIC 等协议，后者是一种基于 UDP 构建的高效传输协议，特别适合低延迟应用。当两个对等节点在互联网上建立连接时，它们将使用这些传输协议进行数据交换。

### 1.2 Stream Multiplexing

为了优化资源使用并减少高开销的连接建立操作，libp2p 支持流复用（stream multiplexing）。这意味着在同一个底层连接上，libp2p 可以并行地传输多种类型的数据。流复用通过将物理连接分解为多个逻辑流（每个流处理一种特定的数据类型）来实现，从而显著提高了网络通信效率。

### 1.3 NAT Traversal

在 P2P 网络中，节点通常处于 NAT 后面，这使得直接建立连接变得困难。libp2p 提供了几种 NAT 穿越机制，例如 NAT 打洞（hole punching）和中继（relay）。这些方法可以帮助节点绕过 NAT 限制，使得它们能够与其他节点建立直接连接，无论它们处于私有网络中的哪个位置。

### 1.4 Protocols

libp2p 提供了一个高度模块化的协议体系，允许开发者定义和使用各种协议进行数据交换。每个协议在 libp2p 中通过一个唯一的协议标识符来表示，这些协议可以是针对不同类型数据的处理规则。例如，两个对等节点 A 和 B 之间的通信可能会包括多个协议，其中 A 打开一个用于协议 xxx 的流，B 则为该协议创建处理器来接收并管理消息。通过这种机制，libp2p 支持多种数据格式和协议的并行处理。

### 1.5 Peer Identity

在去中心化的 P2P 网络中，每个节点必须具有唯一的身份。libp2p 通过对等节点 ID 来实现这一点，该 ID 是从对等节点的私钥派生出来的 multihash（多重哈希）标识符。该身份标识符是网络中对等节点的唯一证明，用于确保节点的身份在通信过程中得到验证。

### 1.6 Addressing

libp2p 使用一种称为“多地址”（multiaddress）的寻址机制，允许节点通过多个协议栈进行通信。多地址不仅仅是 IP 地址，它还可以包括传输协议、端口号以及其他上下文信息，确保节点在复杂的网络拓扑中能够正确定位。例如，一个多地址可能类似于：

```
/ip4/127.0.0.1/tcp/8080/http/my-image.png
```

这表示一个运行在本地机器（IP: 127.0.0.1）上、使用 TCP 协议、监听端口 8080 并提供 HTTP 服务的资源。

### 1.7 Security

libp2p 默认提供加密连接，确保所有节点之间的通信都是安全的。在 libp2p 中，对等节点的身份通过私钥生成的公钥进行验证，因此每个对等节点的连接都能得到加密保护。这种安全机制有效地防止了中间人攻击和未经授权的访问，保证了点对点通信的保密性和完整性。

### 1.8 Publish/Subscribe

libp2p 提供了一个高效的发布/订阅（Pub/Sub）系统，允许对等节点基于主题进行消息传递。在这种机制中，主题是用于分类和分发消息的抽象。每个主题类似于一个消息桶，节点可以订阅自己感兴趣的主题，从而接收到相关的消息。

## 2 Connecting Peers

在 libp2p 中，建立对等节点之间的连接是其核心操作之一。整个过程涉及从节点标识和寻址到协议协商、连接保护和多路复用等多个方面。以下是 libp2p 节点连接过程的详细介绍。

### 2.1 Understanding Nodes

在 libp2p 网络中，**节点**（Node）指的是网络中的单个对等体（peer），通常代表网络中的一台计算机或设备。每个节点通过与其他节点的直接连接来交换数据。通过 libp2p，节点可以作为发送者和接收者进行双向通信。

例如，以下代码片段展示了如何使用 libp2p 的默认设置创建一个节点：

```go
host, err := libp2p.New()
```

每个节点不仅需要能够唯一标识，还需要能够准确定位其他节点以建立连接。libp2p 使用 **多地址（Multiaddress）** 和 **对等标识符（Peer Identifiers）** 来分别标识节点的位置和身份。

### 2.2 Peer Identity

在 libp2p 网络中，每个节点都有一个唯一的 **peer ID**，它由节点的公钥派生而来。具体而言，peer ID 是一个 **multihash**，它实际上是公钥经过哈希处理后的结果。

-   如果公钥的字节长度超过 42 字节，libp2p 会将公钥哈希化生成 peer ID。
-   如果公钥的字节长度小于或等于 42 字节，则 peer ID 本身就是公钥，哈希函数为 **identity hash**，即输出的摘要与输入完全一致。

这种基于公钥派生的身份机制确保了每个对等节点在网络中的唯一性和不可伪造性。

### 2.3 Multiaddress

为了在 libp2p 网络中定位节点，**多地址（Multiaddress）** 机制应运而生。多地址是 libp2p 中用于描述节点位置的一个重要概念。多地址可以包含多种信息，如节点的 IP 地址、端口号以及传输协议类型（TCP、UDP、QUIC 等），甚至是 DNS 地址或加密连接的描述。

多地址的主要优势在于它的**自描述性**：只要你看到一个多地址，你就能知道这个地址涉及哪些网络协议和连接细节。

### 2.4 Establishing a connection

在 libp2p 中，节点之间的连接是通过一系列的协议协商来完成的。这一过程被称为 **连接引导**（connection bootstrapping）。连接引导的关键步骤包括：

-   **握手**：初始化与对等节点的连接，验证双方是否具备必要的协议支持。
- **安全协议协商**：确保连接的安全性，通常通过协商加密协议（如 TLS 或 Noise 协议）来保护数据传输。
- **流复用协议**：协商流复用器，允许在同一连接上同时传输多个不同类型的数据流。

需要注意的是，libp2p 强制要求所有连接都必须经过加密，并且支持流复用。未加密或未复用的连接是不可用的。

### 2.5 Handshake

连接引导过程中的第一步是 **握手**，它确保了两个对等节点能够成功建立连接并且理解彼此所支持的协议。具体来说，libp2p 使用 **multistream-select** 协议来进行版本协商。

握手的过程如下所示：
```
# Request: Do you understand "/multistream/1.0.0"?
> /multistream/1.0.0

# Response: I do.
+ /multistream/1.0.0
```

通过这种方式，节点能够确认对方是否支持多流协议（multistream），从而为后续的协议协商做准备。
### 2.6 Security

在握手成功后，两个对等节点将协商安全协议，以确保连接是加密的并且数据传输安全。libp2p 会根据预定的优先级依次尝试不同的加密协议。例如，首先尝试使用 **TLS**，如果对方不支持 TLS，则切换到 **Noise** 协议。

安全协议的协商示例如下：
```
# Request: Do you understand "/tls/1.0.0"?
> /tls/1.0.0

# Response: I do not
+ na

# Request: Do you understand "/noise/1.0.0"?
> /noise/1.0.0

# Response: I do
+ /noise/1.0.0
```

这种多层协议的选择机制确保了连接始终能够得到合适的加密保护。
### 2.7 Multiplexer

连接保护后，libp2p 会继续协商一个 **多路复用器协议**，这一协议允许在单一连接上承载多个逻辑流。每个流都代表了一个特定的协议数据交换，例如 DHT 操作或 ping 请求。

这种流复用的机制使得 libp2p 能够在同一连接上同时处理不同类型的数据交互，大大提高了效率。每个流会被分配一个唯一的 **流 ID**，这样即便是同一连接上的数据也能被正确区分和处理。

以下是一个流复用的示意图，展示了在同一连接上同时处理不同协议的数据流：

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217104752.png)

### 2.8 Negotiating protocols

一旦连接建立，节点将交换支持的 **应用协议**。每个协议都通过协议标识符进行标识，并且需要经过 **multistream-select** 协议的协商过程。协议标识符会发送给对等方，若对方不支持某个协议，则会返回 **na**（Not Available）响应。

当某个协议被接受后，libp2p 会为该协议分配一个 **处理器（Handler）**，用于管理该协议的数据流和交换。这样，不同的应用协议可以在同一连接上并行处理。
### 2.9 Peer Discovery

除了通过 peer ID 唯一标识对等节点外，libp2p 还需要通过 **对等发现（Peer Discovery）** 来查找网络中的其他节点。libp2p 提供了两种接口来实现这一目标：**Advertiser** 和 **Discoverer**。

- **Advertiser** 允许节点将自己的服务公开到网络中，通常通过广播自己的协议支持情况。
- **Discoverer** 则帮助节点找到其他对等节点，常见的实现方法包括 **mDNS** 和 **Kademlia DHT**。Kademlia DHT 用于在 IPFS 网络中发现对等节点，而 mDNS 则用于局域网中的对等节点发现。

> [!NOTE] mDNS
> mDNS（Multicast DNS，多播域名系统）是一种零配置的局域网设备发现协议。它允许在同一局域网内的节点通过多播 DNS 记录相互发现，无需用户手动配置网络。
> 
> 在 **libp2p** 中，mDNS 的主要目标是实现 **本地网络内的节点发现**，从而简化节点间的连接过程。其工作原理大致如下：
> 
> 1. **节点启动或网络变更时**：节点会发送一个查询请求，寻找局域网内的其他节点。
> 2. **查询响应**：每个节点会响应查询请求，并将自身的相关信息发送给查询方。
> 3. **多播机制**：mDNS 使用多播的方式广播 DNS 查询和响应，使局域网内的所有节点都能接收到这些消息。

## 3 The Distributed Hash Table

### 3.1 Introduction

在 libp2p 中，**Kademlia 分布式哈希表（DHT）** 用于 **对等节点发现** 和 **内容路由**。简而言之，DHT 是一种去中心化的键值存储系统，其中每条记录表示一个 key -> value 映射。DHT 中的记录分布在整个网络中，每个对等节点持有部分记录。

当需要查找某个特定记录时，系统并没有集中式的目录服务；相反，必须通过向网络中的其他对等节点查询来完成查找。这个查询过程并非随机进行，而是通过 **距离度量** 来引导，确保高效地找到目标记录。

### 3.2 The Distance Metric

DHT 中的核心操作是根据 **键**（key）来检索对应的 **值**（value）。为了决定哪些对等节点负责哪些键，DHT 使用 **距离度量**，通过对键和对等节点 ID 进行哈希处理并使用 **异或（XOR）** 操作来计算距离。距离的计算公式如下：

```
distance(key_id, peer_id) = XOR(key_id, peer_id)
```

该距离值是逻辑距离而非物理距离，它通过 XOR 计算生成一个数值，表示两个 ID 之间的距离。例如，如果 distance(key1, peer9) = 4，表示 peer9 对等节点与 key1 键之间的距离为 4。

XOR 距离度量帮助 DHT 确定键与对等节点之间的接近程度，从而实现对键的高效路由和存储。虽然 XOR 距离的数学解释较为复杂，但它在保证 DHT 的去中心化和扩展性方面至关重要。
### 3.3 The Routing Table

每个节点在 DHT 中维护一个 **路由表**，这个路由表记录了与本节点 ID 距离最接近的对等节点。为了加速查找过程，路由表将对等节点划分为多个 **桶**，每个桶包含距离本节点 ID 特定距离范围内的对等节点。离本节点 ID 更近的桶包含的对等节点较多。

这种基于距离的组织方式，使得节点能够快速找到与特定键最接近的对等节点。如果一个节点无法存储某个键，它通常能够返回一个接近该键的节点列表，帮助继续查找目标节点。Kademlia DHT 确保每个节点只存储与自己 ID 接近的键，因此每个节点的存储负载与其 ID 的位置密切相关。
### 3.4 DHT Operations

libp2p DHT 基于 Kademlia 协议，提供了若干核心操作，这些操作实现了键值存储和对等节点发现。主要操作包括：

- `FIND_NODE` : 根据给定的键，查找与该键最接近的对等节点。该操作用于查找目标键。
- `PUT_VALUE` : 在 DHT 中添加一个 key -> value 映射。值将被存储在离该键最近的节点上。
- `GET_VALUE` : 根据给定的键，查找并返回对应的值。该操作通过查找与键最接近的节点来获取值。
- `ADD_PROVIDERS` : 在网络中公告某个节点正在提供特定键的值。此操作用于内容广告。
- `GET_PROVIDERS` : 查找哪些对等节点正在提供特定键对应的值。此操作用于内容的发现。

### 3.5 Find the Closest Nodes

**FIND_NODE** 操作返回与给定键最接近的 k 个节点。

该操作利用路由表来寻找离目标键最接近的节点。具体来说，DHT 计算每个节点与目标键之间的距离（即通过 XOR 距离函数），然后选取距离最小的节点。为确保高效查询，使用参数 k 来限制返回的节点数量。例如，当 k = 4 时，系统只会返回离目标键最近的四个节点。

查询过程如下：

4. **Peer 1** 维护着与它最近的对等节点列表。
5. 执行 **FIND_NODE(key1)** 操作，计算每个节点与 key1 的距离，选取离目标键最近的 k 个节点（例如，选取与键距离最近的 2 个节点）。
### 3.6 Value Storage

在 DHT 中存储值时，使用 **PUT_VALUE** 操作。首先，DHT 会为键计算一个 ID，并根据该键 ID 与对等节点 ID 的距离来确定哪个节点负责存储该键。

存储过程如下：

6. **Peer 1** 想要存储一个新键。它首先执行 **FIND_NODE(key)** 操作，找到离该键最近的 k 个节点。
7. 在找到离键最接近的节点后，节点继续查询其邻近节点，直到找到最接近该键的节点。
8. 节点将该键值对存储在最接近的节点上。

由于每个节点只存储与自己 ID 最接近的键，因此有可能存在多个节点存储相同的键。这种冗余性提高了系统的可用性，但也可能导致一致性问题，因此需要适当的验证策略。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217113531.png)
### 3.7 Value Retrieval

为了检索某个特定键的值，使用 **GET_VALUE** 操作。该操作的过程是通过多轮迭代，在网络中查找存储该键的节点。

检索过程如下：

9. **Peer 1** 发起 **FIND_NODE(key1)** 操作。
10. 它查询与键最接近的节点（如 Peer 2 和 Peer 3），计算每个节点与键之间的距离，选出最接近的节点。
11. 该过程继续向网络中的邻近节点发起请求，直到找到存储该键的节点（例如 Peer 10）。
12. **Peer 10** 返回与该键对应的值。

由于可能有多个节点存储相同的键，因此可能会遇到值不一致的情况，这时需要验证策略来保证值的正确性。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217121142.png)
### 3.8 Advertising Content

除了通过 **GET_VALUE** 操作检索值，DHT 还提供了 **ADD_PROVIDER** 和 **GET_PROVIDERS** 操作，用于内容的广告和查找。这些操作对于分布式文件系统（例如 IPFS）尤其重要。

- **ADD_PROVIDER**：此操作由一个节点发起，用来宣布该节点正在提供特定内容（如 CID）。默认情况下，该记录在 24 小时后过期。
- **GET_PROVIDERS**：此操作查询哪些对等节点正在提供某个特定内容。

在 IPFS 中，**GET_PROVIDERS** 用于查找哪些节点提供特定的文件（由 CID 标识），而 **GET_VALUE** 是一种通用的 Kademlia 协议操作，用于查询存储在 DHT 中的任意键值。

## 4 Publish/Subscribe

发布/订阅（Pub/Sub）是一种通信模式，允许对等节点仅接收感兴趣的特定类型消息。发布者将消息发送到一个特定的主题，而订阅该主题的对等方将接收相关消息。

例如，在一个聊天应用中，名为 music 的聊天组可以被多个用户订阅，当有用户向该组发送消息时，只有订阅了该组的用户才能接收到消息。

libp2p 中的发布/订阅模型允许对等节点订阅并发布特定主题的消息。与传统的消息队列系统（如 Kafka）类似，但 libp2p 实现了去中心化的发布/订阅机制。其主要协议实现包括 **Floodsub** 和 **Gossipsub**。

### 4.1 FloodSub

**Floodsub 协议**是 libp2p 发布/订阅模型的初始实现，其设计理念简单且直接。

在 **Floodsub** 中，发布的消息会被广播到所有与发布者连接的对等节点。每个订阅者节点都会接收到这些消息，无论其是否对该消息感兴趣。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250217124340.png)

Floodsub 机制的实现非常**简单**，不涉及复杂的消息路由或过滤。由于消息会传播到网络中的所有节点，因此系统在网络条件不稳定时依然能够保证消息传递的**可靠性**。Floodsub 的消息传播方式具有天然的**抗审查特性**，因为消息会迅速遍布整个网络，任何单个节点或审查者都很难阻止消息的传递。

但是，Floodsub 会将每条消息发送到所有连接的节点。这意味着，某些节点可能会多次接收到相同的消息，造成**带宽和资源的浪费**。例如，在上图中，Peer 4 会接收到两次相同的消息。
### 4.2 Gossipsub

Gossipsub 协议的主要目标是 **减少消息传递过程中的带宽消耗**。通过优化消息交换的方式，降低网络中的数据冗余。

- **全消息连接**（Full-message peers）：对等节点交换完整的消息内容。
- **仅元数据连接**（Metadata-only peers）：对等节点只交换消息的元数据（如消息标识符），不传递完整的消息内容。

- **Grafting**（嫁接）：当一个仅元数据连接的节点（metadata-only peer）决定接收完整的消息时，它会转变为全消息连接（full-message peer）。通常这种情况发生在该节点对某个消息感兴趣，并且该消息对它有用。
- **Pruning**（修剪）：当一个全消息连接的节点（full-message peer）接收到过多不相关的消息时，它会转变为仅元数据连接（metadata-only peer）。这种转换有助于减少无关消息带来的带宽浪费。

节点连接的全消息对等节点的数量取决于 **网络对等度 D**，该参数可以根据需求进行自定义，影响节点间的连接数量和网络的消息传播效率。

## 5 Protocols

在 libp2p 中，协议是基于 libp2p 核心抽象构建的通信协议，它们利用 libp2p 提供的各种功能，如传输、对等身份验证、寻址等。libp2p 协议的设计允许对等方之间建立灵活且高效的通信，并支持自定义协议的扩展和实现。

### 5.1 What a libp2p Protocol

#### 5.1.1 Protocol IDs

libp2p 中的协议由一个唯一的字符串标识符进行标记。在节点建立连接时，协议协商过程中会使用此协议 ID。通常，协议 ID 采用类似路径的结构，并在路径的最后部分包含版本号。不过，协议 ID 的形式是灵活的，开发者可以根据需要定义。

```
/my-app/amazing-protocol/1.0.1
```

这个结构表明，协议的名称为 amazing-protocol，版本为 1.0.1，且由 my-app 使用。
#### 5.1.2 Handler functions

在 libp2p 中，为了处理传入的连接请求，应用程序需要向交换机（swarm）或更高级别的接口（如 Go 的 Host 接口）注册协议处理函数。当一个连接的流请求一个特定的协议 ID 时，libp2p 会根据协议 ID 选择适当的处理函数来响应请求。

- 在注册时，可以将协议 ID 与处理函数绑定。这样，当连接的流匹配到该协议时，处理函数会被自动调用。
- 可以选择使用匹配函数注册处理程序，以实现协议 ID 的模糊匹配。比如，可以仅匹配协议的主版本号，而忽略次版本号和修订号。
#### 5.1.3 Binary streams

libp2p 协议依赖的通信媒介是双向的二进制数据流。这些流具有以下特性：

- **双向传输**：每一方都可以在流中读取和写入数据，且数据按写入顺序读取。
- **半关闭状态**：流可以进入“半关闭”状态，即一方关闭写入但保持读取开放，或关闭读取但保持写入开放。
- **背压支持**：在流的传输过程中，流的接收方可以通过背压机制防止过多数据的拥堵，确保不会被写入方过度发送数据。

libp2p 在流的传输上还会处理底层的多路复用与安全性问题，这对于协议的开发者是透明的，协议开发者仅需关注协议语义的实现。

### 5.2 Protocol Negotiation

协议协商是 libp2p 协议交换的关键部分。当一个对等节点请求建立新流时，它会发送一个希望使用的协议 ID。接收方将通过检查其注册的协议 ID 来确定是否支持该协议。如果支持，接收方将回显相同的协议 ID，表明双方可以使用该协议进行通信。

如果接收方不支持请求的协议，它会关闭流连接，发起方可以尝试使用其他协议或协议版本。这一过程确保双方能够达成协议，并在协议匹配的情况下建立通信。

#### 5.2.1 协议 ID 和版本匹配

在 libp2p 中注册协议时，您可以使用两种方法来匹配协议 ID。

第一种方法是提供一个协议 ID 和一个处理函数。当接收到的流的协议 ID 与注册的协议 ID 完全匹配时，处理函数会被调用。

#### 5.2.2 使用匹配函数

第二种方法允许使用匹配函数进行更灵活的协议 ID 匹配。在这种情况下，您需要提供协议 ID、协议匹配函数和处理函数三个参数。

- 当接收到的流的协议 ID 不完全匹配时，libp2p 会调用所有已注册的匹配函数。如果任何一个匹配函数返回 true，则会调用与之关联的处理函数。

这种方法为开发者提供了更多的灵活性，可以定义适合应用程序需求的协议匹配逻辑。例如，可以根据版本号或协议的语义主版本进行模糊匹配。
#### 5.2.3 拨号特定协议

当节点发起对远程对等方的拨号请求时，它会发送希望使用的协议 ID。远程节点根据其协议匹配逻辑判断是否接受该协议。

- 如果远程对等方不支持请求的协议，它会关闭流并拒绝连接。发起方可以选择尝试使用其他协议或协议版本。
- 如果需要，可以在拨号时提供多个协议 ID，而不是单一的协议 ID。在这种情况下，libp2p 会依次尝试每个协议 ID，直到找到一个匹配的协议。这样可以确保双方能够在多种协议版本之间协商，以选择最合适的协议进行通信。

例如，在支持多个版本的协议时，发起方可以首先尝试最新版本，如果远程对等方尚未支持最新版本，则会回退到旧版本进行连接。

### 5.3 Core libp2p Protocols

除了开发 libp2p 应用程序时自定义的协议外，libp2p 还定义了多个基础协议，旨在实现核心功能。这些协议为对等网络中的节点间通信提供了必要的协议层支持，确保了网络的稳定性与高效性。

#### 5.3.1 Common patterns

在 libp2p 协议的实现中，所有消息传递都采用协议缓冲区（Protocol Buffers, Protobuf）作为标准数据序列化格式，定义了清晰的消息模式。所有协议消息都在二进制有效载荷之前，附加了一个表示有效载荷长度的字段，该长度是以字节为单位的整数值。这个长度字段采用 Protobuf 中的 varint 编码格式（可变长度整数），确保消息长度可以根据实际需要动态调整，最大程度减少传输数据的冗余。

这种结构使得协议的消息传输更加高效，并能适应不同的网络环境，提升了 libp2p 在多种传输条件下的灵活性和兼容性。

#### 5.3.2 Ping

> [!NOTE] Protocol ID
> /ipfs/ping/1.0.0

libp2p 的 Ping 协议是一种基础的**存活性检查协议**，旨在评估两个节点之间的连接状态及其性能。不同于传统的 ICMP Ping 命令，libp2p Ping 协议仅适用于已建立的 libp2p 连接。该协议的核心作用是确认一个节点与另一个节点之间的通信路径是否畅通，并测量连接的延迟。

在实际工作中，发送 Ping 请求的节点会通过已经建立的 libp2p 连接打开一个新的流，并发送一个包含随机生成的 32 字节有效载荷的 Ping 消息。接收方会对该消息进行回显，原样返回发送的 32 字节数据。通过测量请求与响应之间的时延，发送方可以计算出该 libp2p 连接的往返延迟（RTT）。此外，该流可以被复用，以进行后续的 Ping 操作，极大地优化了存活性检测的效率。

#### 5.3.3 Identify

> [!NOTE] Protocol ID
> /ipfs/id/1.0.0

Identify 协议是 libp2p 网络中用于**节点身份识别和信息交换**的基础协议之一。通过该协议，对等方能够交换彼此的身份信息，特别是其公钥和已知的网络地址。该协议允许一个节点在与远程对等方建立的 libp2p 流中交换自身的相关信息，确保双方能够有效识别彼此，并确保后续的通信是安全和可信的。 

Identify 消息是通过 Protobuf 格式进行编码，包含了对等方的公钥信息（用于派生 PeerId）、协议版本以及其他可选的标识信息。特别地，Identify 消息还包含了 observedAddr 字段，记录了发送方在网络中观察到的远程对等体的公共地址。该字段对于 NAT（网络地址转换）穿越尤其重要，因为它允许节点比较其自己的地址认知与其他对等体所看到的地址之间的差异，从而帮助节点更准确地推断其 NAT 状态并优化连接。

#### 5.3.4 Identify/Push

> [!NOTE] Protocol ID
> /ipfs/id/push/1.0.0

Identify/Push 协议与 Identify 协议在功能上相似，主要区别在于消息的发送方式。Identify/Push 协议并非响应另一个节点的请求，而是主动推送节点的身份信息和网络地址。该协议通常在节点获取新地址、建立新的中继电路，或通过标准 Identify 协议从其他节点处得知自身的公共地址后，启动推送操作。

通过 Identify/Push，节点能够将自己的新地址推送至当前已知的所有对等节点，这不仅帮助节点之间更新路由表，还提高了网络中其他节点发现新地址的可能性。这一机制确保了 libp2p 网络的路由表始终保持最新，从而增强了整个网络的可扩展性和连通性。在动态变化的网络环境中，Identify/Push 协议起到了至关重要的作用，帮助节点适应网络拓扑的变化，增强了节点间的相互发现能力。


