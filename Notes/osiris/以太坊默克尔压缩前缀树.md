**MPT 树**（Merkle Patricia Trie）是一种结合了  **Merkle Tree**（默克尔树）和  **Patricia Tree**（压缩前缀树）特性的树形数据结构。它的核心目标是高效地存储、验证和检索键值对数据。

* **Merkle Tree**：通过哈希逐层构建的树结构，用于验证数据的完整性。
* **Patricia Tree**：一种压缩前缀树，通过合并单子节点路径来优化存储空间。

MPT 树的设计旨在同时实现  **空间优化**、**数据验证**  和  **高效的键值存储**。

## 1 基础数据结构

### 1.1 Trie 字典树

**Trie** 是一种用于存储关联数组的树形结构，键按字符逐层分割路径。

* 键的公共前缀共享路径，节省空间。
* 查询时间复杂度与键长相关（O(L)）。

### 1.2 Merkle Tree 默克尔树

**Merkle Tree** 是一种通过哈希逐层构建的二叉树，用于高效验证数据完整性。

* 叶子节点存储数据哈希，非叶节点存储子节点哈希的拼接哈希。
* 根哈希唯一标识整棵树的状态。

### 1.3 Patricia Tree 压缩前缀树

**Patricia Tree** 是 Trie 的优化版本，通过合并单子节点路径来减少树深度。

* 通过路径压缩（合并单分支节点）降低空间复杂度。
* 支持更高效的插入和删除操作。

> [!NOTE]
> 举个例子，用于直观的理解**合并单子节点路径**，左边是 Trie 中可能的结果，右边是 Patricia Tree 中对应的结构。
>
> ```
>       root                root
>      /    \              /    \
>     c       d          ca       do
>     /         \        /  \     /  \
> 	a           o      t    r   g    d
>   /  \        /  \
>  t    r     g    d
>  ```

MPT 树的设计结合了 Trie、Merkle Tree 和 Patricia Tree 的需求，旨在同时实现 **空间优化**、**数据验证** 和 **高效的键值存储**。MPT 树的诞生背景正是为了解决这三者的局限性。

## 2 MPT 树核心结构

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250216140934.png)

MPT 树包含四种节点类型：

1. **空节点（Null Node）**：表示空值或未初始化的节点。
2. **叶子节点（Leaf Node）**：存储键值对的最终存储单元，包含键的最后部分和值。
3. **扩展节点（Extension Node）**：一种快捷方式节点，用于表示共享前缀的压缩表示，并链接到下一个节点。
4. **分支节点（Branch Node）**：包含 16 个子分支和一个可选的 Value 值。

MPT 树使用 **Hex-Prefix（HP）编码** 来压缩键的表示，消除冗余字符，优化路径存储。每个节点的哈希值由其子节点哈希生成，根哈希唯一标识整棵树的状态。这一特性使得 MPT 树能够高效地验证数据的完整性。

> [!NOTE]
> 使用HP编码能够区分节点是扩展结点还是叶子节点，还能区分当前路径半字节长度的奇偶。对于拓展节点，如果是偶数个半字节，前缀就是 0x0，补充到偶数长度后是 0x00；如果是奇数个半字节，前缀是 0x1。如果是叶子节点，如果是偶数个半字节，前缀就是 0x2，补充到偶数长度后是 0x20；如果是奇数个半字节，前缀就是 0x3。

## 3 以太坊中的 Tries

以太坊中，每个区块头都存储了三种 Trie 结构的根：stateRoot、transactionRoot 和 receiptsRoot。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250216133348.png)

- **State Trie**：状态树/世界状态树表示的是账户地址与账户状态之间的映射关系。账户状态包括 Balance、Nonce、CodeHash 和 StorageRoot。其中 StorageRoot 是账户存储树（存储与账户相关的合约数据）的根。**根节点依赖于所有内部数据，其哈希值作为整个系统状态的唯一标识符。** 状态根（stateRoot）是状态树根节点的哈希值，它会在每次交易执行并提交后更新。
- **Transaction Trie**：交易树基于区块内的交易列表创建，交易树中特定交易的路径是根据该交易在区块中的位置来追踪的。一旦一个区块被挖出，交易在区块中的位置不会改变，因此交易树永远不会更新。
- **Receipt Trie**：收据树记录了成功执行的交易成果，包括交易状态码、使用的 gas、交易日志和布隆过滤器（一种用于快速查找日志的数据结构）。这里的键是区块中交易的索引，值是交易收据。收据树从不更新。

Trie 中的值通常由多个数据项组成，因此，使用编码技术可以将其转化为可以存储或通过网络传输的统一格式。以太坊使用的是递归长度前缀（RLP）编码。

> [!NOTE]
> 递归长度前缀编码（RLP，Recursive Length Prefix）是一种用于以太坊数据序列化的编码方式，主要用于将各种数据结构转换为字节流，以便在以太坊网络中传输或存储。RLP 的关键特点是递归和长度前缀，具体如下：
> 
> 1. **递归**：RLP 支持递归地编码复合数据结构，如数组或对象。每个数据元素可以是基本类型（如整数、字符串）或其他更复杂的结构（如列表）。递归地对这些数据结构进行编码，确保能够处理任意嵌套的情况。
> 2. **长度前缀**：RLP 编码时，在数据前面加上一个表示数据长度的前缀。这样，接收方可以准确知道如何解析数据。
> 
> RLP 比 JSON 更紧凑，因为它省略了额外的标识符（如 {} 和 []）。JSON 适合人类阅读，但会生成大量冗余的字符；RLP 的目标是高效的机器处理。
> RLP 比 Protobuf 更简单，结构更少，适用于区块链等需要高效数据存储和传输的场景。Protobuf 比 RLP 更适合复杂数据类型的传输。
> **gob** 是 Go 自带的二进制编码和解码格式，设计用于高效地在 Go 程序间传输和存储数据。它通过二进制形式将 Go 对象序列化为字节流，并且**支持保留 Go 语言的数据类型**，包括结构体、切片、映射等。

## 4 编码

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250216142425.png)

1. **Raw 编码**：这是原始的数据格式，通常是未经过任何加工的数据。例如，可能是交易数据、账户数据等，以原始字节的形式存储。
2. **Hex 编码**：Hex（十六进制）编码用于将原始字节数据转换为更易于人类理解和存储的字符串格式。它将每个字节映射为两位十六进制数字。该编码通常用于在 MPT 中存储哈希值和其他非字符串类型的数据。
3. **HP 编码**：HP 编码通常指的是高效压缩后的编码格式，它可能用于进一步压缩和优化数据的存储。根据上下文，这里可能是指在数据库中存储时应用的一种压缩和优化方案。MPT 结构中，每个节点可能会使用不同的编码方式来优化存储，减少存储空间。
4. **持久化到数据库**：这些编码后的数据最终会被存储到数据库中。在 MPT 中，根节点和每个交易或账户的数据都会被编码后存入数据库，保持结构的完整性。
5. **从数据库中读取**：在查询时，从数据库中读取这些经过编码的数据，并按照相应的解码方式进行解码，还原为原始数据。

**RLP（Recursive Length Prefix）** 编码在以太坊中扮演着非常重要的角色，它用于序列化数据结构。RLP 编码在 MPT 的操作中起到了以下几个关键作用：

1. **数据序列化**：在存储数据（例如交易、账户信息等）时，需要将复杂的数据结构转换成字节流以便存储或传输。RLP 是以太坊中主要的序列化格式，用于将数据结构（如列表和字典）转换为固定格式的字节串。这样的数据序列化保证了即使数据结构复杂，它也能以紧凑、高效的方式进行存储。
2. **支持可变长度**：RLP 支持递归地对嵌套的列表进行编码，适应不同长度的数据。这样可以高效处理数据大小变化的问题。每个元素的长度都被记录，这样可以轻松地解析和反序列化数据。
3. **在 MPT 中应用**：RLP 编码被用来处理 MPT 中的键值对数据存储。例如，当存储某个交易或账户信息时，RLP 会首先对这些信息进行编码，然后将编码后的数据存储在 MPT 的节点中。在查询时，相应的数据会先从数据库中取出，然后通过 RLP 解码还原出原始的数据结构。
4. **保证一致性与兼容性**：RLP 编码是以太坊生态中一个重要的标准，能够保证不同节点和不同系统之间数据的兼容性和一致性。这也意味着即使是不同的节点或不同的存储方式，它们依然能够通过 RLP 编码/解码保持数据的一致性。