## 1 Go Concurrency

### 1.1 并发基础概念

#### 1.1.1 什么是进程和线程？

- **进程**：程序的执行实例，包含至少一个线程。
- **线程**：执行指令的顺序流，一个进程可包含多个线程。
- **命令**：
    - UNIX 系统查看进程：`ps xau`
    - Windows 系统查看进程：`tasklist`

#### 1.1.2 并发与并行

- **并发**：程序的不同部分可以**无序或部分有序**地执行，但最终结果不受影响。
- **并行**：任务同时执行（需要多核 CPU 支持）。
- **区别**：并发是能力，可能包含并行，但并不等同。

---

### 1.2 并发常见问题

#### 1.2.1 数据竞争（Data Race）

- **定义**：多个线程同时访问共享变量且至少一个线程尝试修改，而没有同步机制。
- **检测工具**：使用 Go 的 race detector 工具，`go build -race`

#### 1.2.2 死锁（Deadlock）

- **定义**：多个线程相互等待对方释放资源，导致程序无法继续执行。
- **示例**：哲学家就餐问题，所有哲学家同时拿起右边的叉子，导致死锁。
- **解决**：避免循环依赖，使用超时机制等。

---

## 2 Go 并发工具

### 2.1 Goroutines

- **定义**：Go 中的轻量级线程，通过 `go` 关键字启动。
- **特点**：
    - 独立执行，不阻塞主线程；
    - 每个程序都有一个 `main goroutine`；
    - `go myFunction()`

### 2.2 Channels

- **定义**：用于 Goroutines 之间通信的**类型化管道**，即通道。
- **类型**：
  - 双向：`chan T`
  - 只发送：`chan<- T`
  - 只接收：`<-chan T`
- **缓冲区**：
  - 无缓冲：`make(chan int)`
    - 发送操作阻塞，直到接收方读取数据；
    - 可以用于进程间同步。
  - 有缓冲：`make(chan int, 3)`
    - 发送操作阻塞，直到缓冲区满。
- **操作**：
  - 发送数据：`ch <- value`
  - 接收数据：`value := <-ch`
  - 关闭通道：`close(ch)`

### 2.3 Select 语句

- **定义**：用于处理多个通道操作的选择器。
- **特点**：
  - **执行第一个非阻塞的通道操作**。
  - 如果所有通道阻塞，执行 `default` 分支（若存在）。
  - 空选择语句 `select {}` 会无限期地阻塞 goroutine。

### 2.4 WaitGroup

- **定义**：用于等待一组 Goroutines 完成的同步工具。
- **方法**：
  - 增加计数：`Add(n)`，启动协程前调用
  - 减少计数：`Done()`，协程结束前调用；
  - 阻塞等待：`Wait()`，主协程调用。

### 2.5 Mutex（互斥锁）

- **定义**：同步工具，确保同时只有一个 Goroutine 访问共享资源。
- **操作**：
  - 加锁：`mu.Lock()`
  - 解锁：`mu.Unlock()`
  - **Mutex hat** 是将互斥锁放在结构体被保护字段之上的编程模式。

---
