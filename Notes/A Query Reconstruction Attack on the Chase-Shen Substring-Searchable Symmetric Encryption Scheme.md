题目：**对 Chase-Shen 子串可搜索对称加密方案的查询重构攻击**

> [!NOTE] **子串可搜索对称加密 (Substring-SSE)**
>
> 子串可搜索对称加密是一种特殊的加密方法，它允许用户在加密数据中执行子串搜索，而无需解密整个数据。例如，假设一个文档被加密后存储在云端，用户可以使用关键字（如 "hello"）搜索所有包含该关键字的加密文档，而无需解密所有数据。

> [!NOTE] **查询重构攻击 (Query Reconstruction Attack)**
> 查询重构攻击是一种针对可搜索加密方案的攻击方法，核心在于利用**查询模式泄露**（Query Pattern Leakage）和**访问模式泄露**（Access Pattern Leakage）来推断用户的查询内容。攻击者通过观察用户的查询模式、加密数据的匹配结果以及其他相关信息，试图重建用户的查询内容。
> 1. 攻击者监听用户发送的加密查询。
> 2. 通过分析查询模式和返回结果（如哪些加密文档匹配了查询），逐步推断出查询的内容。
> 3. 最终可能还原出用户查询的明文信息，甚至进一步推断出加密数据的内容。
>
> **查询模式泄露**是指攻击者通过观察用户的查询行为（如查询的加密形式、查询的频率、查询之间的相似性等）获得关于查询内容的信息。
> **访问模式泄露**是指攻击者通过观察查询结果中哪些加密文档被匹配（即哪些加密数据被返回）来推断查询内容。

## 1 摘要

可搜索对称加密（Searchable Symmetric Encryption, SSE）允许对对称加密的数据库进行查询。为了实现实用的效率，SSE 方案会引入一定程度的信息泄露（leakage）；然而，这导致了泄露密码分析（leakage cryptanalysis）的可能性，即利用目标 SSE 方案的泄露信息发起密码分析攻击，从而破坏其数据和查询隐私性保障。在支持关键词查询或范围查询的 SSE 方案中，泄露密码分析已经被广泛研究，并且通常会导致严重后果。然而，对于子串 -SSE 方案（即支持加密数据上任意子串查询的 SSE 方案）的密码分析却几乎没有受到关注。这种忽视发生在子串 -SSE 方案与许多实际应用密切相关的情况下，例如在安全查询外包基因组数据库的背景中。此外，尽管 Chase 和 Shen 在近十年前（PoPETS '15）提出了第一个子串 -SSE 方案，但至今尚未对其进行密码分析。

在本文中，我们首次对 Chase 和 Shen 的子串 -SSE 方案进行了泄露密码分析。我们提出了一种新颖的基于推断的查询重构攻击，该攻击：(i) 利用其方案实际泄露信息的简化版本，以及 (ii) 假设了比 Chase 和 Shen 原本声称安全性时更弱的攻击模型。我们实现了这一攻击，并在两个真实世界的数据集上实验验证了其成功率和效率。我们的攻击以实际可行的效率实现了高查询重构率，并且能够平滑扩展到包含 10 万个字符串的大型数据集。

据我们所知，这是迄今为止对任何子串 -SSE 方案的第一个也是唯一一个查询重构攻击，同时也是第一个系统性泄露密码分析。

> [!NOTE] Title
> **泄露信息的简化版本**：攻击者并没有利用 Chase-Shen 方案中所有的泄露信息，而是只利用了其中的一部分（即 " 简化版本 "）。这意味着攻击者只需要获取最基本的泄露信息（比如部分查询模式或访问模式），而不需要完全掌握所有可能的泄露信息。
> **攻击模型**是指攻击者的能力范围和资源条件。它定义了攻击者可以做什么、不能做什么，以及攻击者掌握了哪些信息。设计加密方案时，研究者通常会假设一个攻击模型，并在该模型下证明加密方案的安全性。
> **更弱的攻击模型**：攻击者的能力比设计者原本假设的要低。攻击者掌握的信息比设计者原本假设的要少。换句话说，攻击者的条件更加受限，但即便如此，他们仍然能够成功攻击加密方案。这表明加密方案的安全性可能被高估了。

## 2 引言

 **可搜索对称加密（Searchable Symmetric Encryption, SSE）** 可搜索对称加密（SSE）是一种被广泛研究的密码学原语，它支持在对称加密的数据库上高效地执行查询操作。SSE 是安全存储即服务（storage-as-a-service）的关键技术之一，它允许客户端将大规模数据库安全地外包给（可能不可信的）第三方服务器进行存储和处理。SSE 的目标是在加密数据库上实现高效的查询处理，同时通过最小化泄露给服务器的信息来确保客户端的隐私。

文献中绝大多数 SSE 方案支持**单关键词查询**（即：在一个加密的文档集合中，每个文档都被标记了关键词，用户可以找到与目标关键词关联的所有文档集合）。相关研究包括 [6, 7, 11–13, 15, 26, 43, 60]。此外，支持对关键词集合进行更丰富布尔查询的 SSE 方案也被广泛研究 [9, 10, 40, 50, 56, 58]。其他研究则探讨了支持范围查询 [17–20] 的 SSE 方案，以及支持加密关系型数据库上的连接（join）和分组（group-by）查询的 SSE 方案 [17, 39, 41]。

---

**子串 -SSE** 本文关注于客户端需要在数据库中查询任意子串的应用场景，而不是预先确定的关键词。具体来说，**子串可搜索对称加密（substring-SSE）** 旨在支持以下查询功能：给定一个加密字符串（字符串由某个固定字母表中的字符组成），返回目标子串在该字符串中所有出现的位置。

一个典型的应用场景是：假设某医学研究实验室希望将受试者的基因组数据存储在云服务器上，同时允许研究人员发起子串查询以检测特定 DNA 序列的存在（例如，追踪癌症标记序列的存在，或确定某个可能有用的探针序列的稀有性）。在这种应用中，确保数据库和查询的隐私至关重要。支持任意子串查询的 SSE 方案可以为此提供解决方案。

将单关键词搜索的 SSE 直接改造为 substring-SSE 的简单方法是：将给定字符串的每个子串都建模为一个单独的关键词。然而，这种方法在实际中效率极低：对于长度为𝑛的字符串，所需关键词的数量将达到𝑂(𝑛2)。实现实际高效的子串 -SSE 更加具有挑战性。实际上，自 Chase 和 Shen 在 PoPETS'15 [14] 提出这一方向的开创性工作以来，仅有少数支持子串搜索的 SSE 方案被提出 [20, 36, 51]。其中，[14] 和 [51] 中的方案基于专门设计的加密数据结构，而 [20] 和 [36] 将子串查询分别建模为关键词查询和范围查询的特殊情况，并通过改造这些查询类型的 SSE 方案实现了子串搜索。

---

**SSE 中的泄露** 在 SSE 文献中，" 泄露 " 指的是服务器通过 SSE 操作可能获知的关于数据库或客户端查询的任何信息。尽管可以使用全同态加密（FHE）[24] 和隐私访问内存（Oblivious RAM, ORAM）[27, 28] 实现几乎无泄露的最优隐私 SSE，这些技术目前在计算和通信开销上过于昂贵，难以在实际规模上应用。因此，现有 SSE 设计通常选择在性能提升的同时，允许一定程度的信息泄露 [10, 13, 15]。一个典型的安全性证明通过基于模拟的安全模型表明，方案在运行过程中泄露的信息不会超过某个明确定义的泄露模式。

然而，这种方法并未回答一个关键问题：某个方案的泄露模式在实际中是否可以接受。这需要通过**泄露密码分析**来评估泄露的实际影响。泄露密码分析涉及开发具体的密码攻击，利用 SSE 方案的泄露信息破坏其某些安全性保证（如数据或查询隐私）。此类攻击也被称为泄露滥用攻击。从 Islam 等人的开创性工作 [37] 开始，泄露密码分析在关键词查询 SSE[2, 8, 16, 33, 34, 53–55, 59] 和范围查询 SSE[21, 30–32, 44–49, 52] 中得到了广泛研究。这些攻击通常利用 SSE 方案中常见的某种或多种泄露形式，例如：

1. **访问模式泄露**：暴露与查询匹配的结果集合；
2. **查询结果数量泄露**：暴露与查询匹配的结果数量；
3. **共现模式泄露**：暴露两个查询之间的公共结果数量；
4. **查询模式泄露**：暴露两个查询是否相同。

如今，泄露密码分析已成为 SSE 方案整体安全性评估的重要组成部分。

---

**substring-SSE 中的泄露** 据我们所知，之前的工作中没有对子串 -SSE 方案进行过任何泄露密码分析。尤其是，Chase 和 Shen 的开创性论文 [14] 缺乏这样的分析。我们注意到，尝试对子串查询的泄露进行密码分析会带来一些在关键词或范围查询 SSE 中不存在的新挑战。例如，关键词查询中的查询相等性泄露本质上是 " 全有或全无 " 的——两个关键词要么相同，要么不同。这种泄露在许多现有攻击中非常有用，因为它可以（非正式地说）过滤出与某个查询匹配的潜在关键词集合 [2, 8, 34]。然而，在子串查询的情况下，两个子串可能具有不同程度的重叠（即它们有多少个字符是相同的），这导致了更细粒度的查询相等性泄露，需要更高级的过滤方法。

此外，与关键词查询不同的是，关键词集合是预先确定的（即使是大型真实文档集合，关键词的数量通常也在数百万范围内），而任意子串查询来自一个显著更大的集合（例如，仅长度为 5 的字符串，其字符来自英文字母表，可能的字符串数量就超过十亿）。这限制了现有 SSE 方案分析技术的适用性。

鉴于这些新的挑战、缺乏先前的分析，以及此类分析在评估 SSE 方案实际安全性中的核心作用，我们认为对子串 -SSE 方案的泄露密码分析是一个值得关注的问题。

### 2.1 我们的贡献

我们对 Chase 和 Shen 在 PoPETS'15 [14] 提出的开创性子串 -SSE 方案（以下简称 CS 方案）进行了首次泄露密码分析。更具体地说，我们提出了一种针对 CS 方案的新型查询重建攻击（query reconstruction attack）。我们的攻击仅利用了 CS 方案完整泄露模式的简化版本（该泄露模式已在 [14] 中正式建立），并且在一个比 Chase 和 Shen 原本声称其方案安全性适用的攻击模型更弱的模型下进行。

我们实现了该攻击，并在两个真实世界的数据集上对其成功率和实际效率进行了实验验证——分别是**英文维基百科数据集**和来自**国家生物技术信息中心（NCBI）**的基因组数据集。

据我们所知，这是针对任何子串 -SSE 方案的首个查询恢复攻击，也是首个系统性泄露密码分析。我们选择 CS 方案作为分析对象，因为它是首个被提出的子串 -SSE 方案，并且在近十年内从未进行过泄露密码分析。对其他子串 -SSE 方案（如 [20, 36, 51]）的泄露进行密码分析也会很有趣；然而，我们相信，由于这些方案基于完全不同的设计原理，其泄露模式差异很大，每种方案都可能需要开发独特的密码分析技术。我们将对这些方案的（密码）分析作为一个有趣的开放问题。

### 2.2 技术概述

**CS 方案的非正式概述**：我们从 CS 方案的一个非常高层次的非正式描述开始，提供足够的细节以便对我们的攻击方法进行有意义的阐述。更详细的内容请参考第 3 节。

正如前文提到的，CS 方案基于**后缀树（suffix tree）**。后缀树是一种常用于在非加密数据上高效执行子串搜索的数据结构。在字符串 𝑠 的后缀树表示中，从根节点到每个其他节点的路径由一系列标记的边组成，这些边表示𝑠的一个唯一后缀。子串搜索基于以下关键观察：字符串𝑞是𝑠的子串当且仅当𝑞是𝑠某个后缀的前缀。因此，搜索𝑞在𝑠中的出现位置可以简化为从根节点到某个匹配节点的路径识别（即：从根节点到该节点的路径上的标记序列与𝑞匹配的节点）。

基于上述思想，CS 方案结合了基本的对称密钥密码学原语，设计了一种加密子串搜索过程。该过程允许在后缀树的加密表示中选择性地遍历某些边。总体上，CS 方案通过**键值字典（key-value dictionary）** 创建了这种加密表示。更具体地说：

- 后缀树中的每个节点𝑢都与一个伪随机密钥相关联，该密钥表示从根节点到𝑢的路径；
- 与之关联的值加密了节点𝑢的索引。

加密子串搜索的过程如下：

1. 计算与查询子串𝑞匹配的节点的伪随机密钥；
2. 在加密的键值存储中搜索匹配的密钥；
3. 如果找到匹配项，则检索并解密对应的索引。

我们再次强调，这是一种高度简化的 CS 方案描述，故意忽略了许多技术细节和优化。但这已经足够为我们的攻击方法提供一个高层次的概述。

---

**CS 方案的泄露** 我们的攻击依赖于 CS 方案泄露模式的三个子组件，这些子组件在 [14] 中已被建立。以下是这些泄露子组件的简化和非正式总结（详细内容请见第 4 节）：

1. **路径长度（Path Length）**：从根节点到任何查询子串𝑞匹配节点的路径长度（如果存在这样的匹配节点）。
2. **响应量（Response Volume）**：任何查询子串𝑞的匹配出现次数。
3. **公共前缀长度（Common Prefix Length）**：任意两个查询子串（𝑞, 𝑞′）之间最长公共前缀的长度。

我们特别指出，CS 方案的整体泄露模式远比上述子组件的组合要大得多。事实上，正如我们在第 4 节中讨论的，一个**被动攻击者**仅通过观察客户端与服务器在 CS 搜索协议执行期间交换的消息记录，就可以直接推导出上述泄露组件。换句话说，该攻击不仅可以由恶意服务器执行，还可以由任何能够观察客户端与服务器通信的恶意实体执行。
