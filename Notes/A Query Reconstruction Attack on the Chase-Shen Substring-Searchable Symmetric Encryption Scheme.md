题目：**对 Chase-Shen 子串可搜索对称加密方案的查询重构攻击**

> [!NOTE] **子串可搜索对称加密 (Substring-SSE)**
>
> 子串可搜索对称加密是一种特殊的加密方法，它允许用户在加密数据中执行子串搜索，而无需解密整个数据。例如，假设一个文档被加密后存储在云端，用户可以使用关键字（如 "hello"）搜索所有包含该关键字的加密文档，而无需解密所有数据。

> [!NOTE] **查询重构攻击 (Query Reconstruction Attack)**
> 查询重构攻击是一种针对可搜索加密方案的攻击方法，核心在于利用**查询模式泄露**（Query Pattern Leakage）和**访问模式泄露**（Access Pattern Leakage）来推断用户的查询内容。攻击者通过观察用户的查询模式、加密数据的匹配结果以及其他相关信息，试图重建用户的查询内容。
> 1. 攻击者监听用户发送的加密查询。
> 2. 通过分析查询模式和返回结果（如哪些加密文档匹配了查询），逐步推断出查询的内容。
> 3. 最终可能还原出用户查询的明文信息，甚至进一步推断出加密数据的内容。
>
> **查询模式泄露**是指攻击者通过观察用户的查询行为（如查询的加密形式、查询的频率、查询之间的相似性等）获得关于查询内容的信息。
> **访问模式泄露**是指攻击者通过观察查询结果中哪些加密文档被匹配（即哪些加密数据被返回）来推断查询内容。

## 1 摘要

可搜索对称加密（Searchable Symmetric Encryption, SSE）允许对对称加密的数据库进行查询。为了实现实用的效率，SSE 方案会引入一定程度的信息泄露（leakage）；然而，这导致了泄露密码分析（leakage cryptanalysis）的可能性，即利用目标 SSE 方案的泄露信息发起密码分析攻击，从而破坏其数据和查询隐私性保障。在支持关键词查询或范围查询的 SSE 方案中，泄露密码分析已经被广泛研究，并且通常会导致严重后果。然而，对于子串 -SSE 方案（即支持加密数据上任意子串查询的 SSE 方案）的密码分析却几乎没有受到关注。这种忽视发生在子串 -SSE 方案与许多实际应用密切相关的情况下，例如在安全查询外包基因组数据库的背景中。此外，尽管 Chase 和 Shen 在近十年前（PoPETS '15）提出了第一个子串 -SSE 方案，但至今尚未对其进行密码分析。

在本文中，我们首次对 Chase 和 Shen 的子串 -SSE 方案进行了泄露密码分析。我们提出了一种新颖的基于推断的查询重构攻击，该攻击：(i) 利用其方案实际泄露信息的简化版本，以及 (ii) 假设了比 Chase 和 Shen 原本声称安全性时更弱的攻击模型。我们实现了这一攻击，并在两个真实世界的数据集上实验验证了其成功率和效率。我们的攻击以实际可行的效率实现了高查询重构率，并且能够平滑扩展到包含 10 万个字符串的大型数据集。

据我们所知，这是迄今为止对任何子串 -SSE 方案的第一个也是唯一一个查询重构攻击，同时也是第一个系统性泄露密码分析。

> [!NOTE] Title
> **泄露信息的简化版本**：攻击者并没有利用 Chase-Shen 方案中所有的泄露信息，而是只利用了其中的一部分（即 " 简化版本 "）。这意味着攻击者只需要获取最基本的泄露信息（比如部分查询模式或访问模式），而不需要完全掌握所有可能的泄露信息。
> **攻击模型**是指攻击者的能力范围和资源条件。它定义了攻击者可以做什么、不能做什么，以及攻击者掌握了哪些信息。设计加密方案时，研究者通常会假设一个攻击模型，并在该模型下证明加密方案的安全性。
> **更弱的攻击模型**：攻击者的能力比设计者原本假设的要低。攻击者掌握的信息比设计者原本假设的要少。换句话说，攻击者的条件更加受限，但即便如此，他们仍然能够成功攻击加密方案。这表明加密方案的安全性可能被高估了。

## 2 引言

 **可搜索对称加密（Searchable Symmetric Encryption, SSE）** 可搜索对称加密（SSE）是一种被广泛研究的密码学原语，它支持在对称加密的数据库上高效地执行查询操作。SSE 是安全存储即服务（storage-as-a-service）的关键技术之一，它允许客户端将大规模数据库安全地外包给（可能不可信的）第三方服务器进行存储和处理。SSE 的目标是在加密数据库上实现高效的查询处理，同时通过最小化泄露给服务器的信息来确保客户端的隐私。

文献中绝大多数 SSE 方案支持**单关键词查询**（即：在一个加密的文档集合中，每个文档都被标记了关键词，用户可以找到与目标关键词关联的所有文档集合）。相关研究包括 [6, 7, 11–13, 15, 26, 43, 60]。此外，支持对关键词集合进行更丰富布尔查询的 SSE 方案也被广泛研究 [9, 10, 40, 50, 56, 58]。其他研究则探讨了支持范围查询 [17–20] 的 SSE 方案，以及支持加密关系型数据库上的连接（join）和分组（group-by）查询的 SSE 方案 [17, 39, 41]。

---

**子串 -SSE** 本文关注于客户端需要在数据库中查询任意子串的应用场景，而不是预先确定的关键词。具体来说，**子串可搜索对称加密（substring-SSE）** 旨在支持以下查询功能：给定一个加密字符串（字符串由某个固定字母表中的字符组成），返回目标子串在该字符串中所有出现的位置。

一个典型的应用场景是：假设某医学研究实验室希望将受试者的基因组数据存储在云服务器上，同时允许研究人员发起子串查询以检测特定 DNA 序列的存在（例如，追踪癌症标记序列的存在，或确定某个可能有用的探针序列的稀有性）。在这种应用中，确保数据库和查询的隐私至关重要。支持任意子串查询的 SSE 方案可以为此提供解决方案。

将单关键词搜索的 SSE 直接改造为 substring-SSE 的简单方法是：将给定字符串的每个子串都建模为一个单独的关键词。然而，这种方法在实际中效率极低：对于长度为𝑛的字符串，所需关键词的数量将达到𝑂(𝑛2)。实现实际高效的子串 -SSE 更加具有挑战性。实际上，自 Chase 和 Shen 在 PoPETS'15 [14] 提出这一方向的开创性工作以来，仅有少数支持子串搜索的 SSE 方案被提出 [20, 36, 51]。其中，[14] 和 [51] 中的方案基于专门设计的加密数据结构，而 [20] 和 [36] 将子串查询分别建模为关键词查询和范围查询的特殊情况，并通过改造这些查询类型的 SSE 方案实现了子串搜索。

---

**SSE 中的泄露** 在 SSE 文献中，" 泄露 " 指的是服务器通过 SSE 操作可能获知的关于数据库或客户端查询的任何信息。尽管可以使用全同态加密（FHE）[24] 和隐私访问内存（Oblivious RAM, ORAM）[27, 28] 实现几乎无泄露的最优隐私 SSE，这些技术目前在计算和通信开销上过于昂贵，难以在实际规模上应用。因此，现有 SSE 设计通常选择在性能提升的同时，允许一定程度的信息泄露 [10, 13, 15]。一个典型的安全性证明通过基于模拟的安全模型表明，方案在运行过程中泄露的信息不会超过某个明确定义的泄露模式。

然而，这种方法并未回答一个关键问题：某个方案的泄露模式在实际中是否可以接受。这需要通过**泄露密码分析**来评估泄露的实际影响。泄露密码分析涉及开发具体的密码攻击，利用 SSE 方案的泄露信息破坏其某些安全性保证（如数据或查询隐私）。此类攻击也被称为泄露滥用攻击。从 Islam 等人的开创性工作 [37] 开始，泄露密码分析在关键词查询 SSE[2, 8, 16, 33, 34, 53–55, 59] 和范围查询 SSE[21, 30–32, 44–49, 52] 中得到了广泛研究。这些攻击通常利用 SSE 方案中常见的某种或多种泄露形式，例如：

1. **访问模式泄露**：暴露与查询匹配的结果集合；
2. **查询结果数量泄露**：暴露与查询匹配的结果数量；
3. **共现模式泄露**：暴露两个查询之间的公共结果数量；
4. **查询模式泄露**：暴露两个查询是否相同。

如今，泄露密码分析已成为 SSE 方案整体安全性评估的重要组成部分。

---

**substring-SSE 中的泄露** 据我们所知，之前的工作中没有对子串 -SSE 方案进行过任何泄露密码分析。尤其是，Chase 和 Shen 的开创性论文 [14] 缺乏这样的分析。我们注意到，尝试对子串查询的泄露进行密码分析会带来一些在关键词或范围查询 SSE 中不存在的新挑战。例如，关键词查询中的查询相等性泄露本质上是 " 全有或全无 " 的——两个关键词要么相同，要么不同。这种泄露在许多现有攻击中非常有用，因为它可以（非正式地说）过滤出与某个查询匹配的潜在关键词集合 [2, 8, 34]。然而，在子串查询的情况下，两个子串可能具有不同程度的重叠（即它们有多少个字符是相同的），这导致了更细粒度的查询相等性泄露，需要更高级的过滤方法。

此外，与关键词查询不同的是，关键词集合是预先确定的（即使是大型真实文档集合，关键词的数量通常也在数百万范围内），而任意子串查询来自一个显著更大的集合（例如，仅长度为 5 的字符串，其字符来自英文字母表，可能的字符串数量就超过十亿）。这限制了现有 SSE 方案分析技术的适用性。

鉴于这些新的挑战、缺乏先前的分析，以及此类分析在评估 SSE 方案实际安全性中的核心作用，我们认为对子串 -SSE 方案的泄露密码分析是一个值得关注的问题。

### 2.1 我们的贡献

我们对 Chase 和 Shen 在 PoPETS'15 [14] 提出的开创性子串 -SSE 方案（以下简称 CS 方案）进行了首次泄露密码分析。更具体地说，我们提出了一种针对 CS 方案的新型查询重建攻击（query reconstruction attack）。我们的攻击仅利用了 CS 方案完整泄露模式的简化版本（该泄露模式已在 [14] 中正式建立），并且在一个比 Chase 和 Shen 原本声称其方案安全性适用的攻击模型更弱的模型下进行。

我们实现了该攻击，并在两个真实世界的数据集上对其成功率和实际效率进行了实验验证——分别是**英文维基百科数据集**和来自**国家生物技术信息中心（NCBI）**的基因组数据集。

据我们所知，这是针对任何子串 -SSE 方案的首个查询恢复攻击，也是首个系统性泄露密码分析。我们选择 CS 方案作为分析对象，因为它是首个被提出的子串 -SSE 方案，并且在近十年内从未进行过泄露密码分析。对其他子串 -SSE 方案（如 [20, 36, 51]）的泄露进行密码分析也会很有趣；然而，我们相信，由于这些方案基于完全不同的设计原理，其泄露模式差异很大，每种方案都可能需要开发独特的密码分析技术。我们将对这些方案的（密码）分析作为一个有趣的开放问题。

### 2.2 技术概述

**CS 方案的非正式概述**：我们从 CS 方案的一个非常高层次的非正式描述开始，提供足够的细节以便对我们的攻击方法进行有意义的阐述。更详细的内容请参考第 3 节。

正如前文提到的，CS 方案基于**后缀树（suffix tree）**。后缀树是一种常用于在非加密数据上高效执行子串搜索的数据结构。在字符串 𝑠 的后缀树表示中，从根节点到每个其他节点的路径由一系列标记的边组成，这些边表示𝑠的一个唯一后缀。子串搜索基于以下关键观察：字符串𝑞是𝑠的子串当且仅当𝑞是𝑠某个后缀的前缀。因此，搜索𝑞在𝑠中的出现位置可以简化为从根节点到某个匹配节点的路径识别（即：从根节点到该节点的路径上的标记序列与𝑞匹配的节点）。

基于上述思想，CS 方案结合了基本的对称密钥密码学原语，设计了一种加密子串搜索过程。该过程允许在后缀树的加密表示中选择性地遍历某些边。总体上，CS 方案通过**键值字典（key-value dictionary）** 创建了这种加密表示。更具体地说：

- 后缀树中的每个节点𝑢都与一个伪随机密钥相关联，该密钥表示从根节点到𝑢的路径；
- 与之关联的值加密了节点𝑢的索引。

加密子串搜索的过程如下：

1. 计算与查询子串𝑞匹配的节点的伪随机密钥；
2. 在加密的键值存储中搜索匹配的密钥；
3. 如果找到匹配项，则检索并解密对应的索引。

我们再次强调，这是一种高度简化的 CS 方案描述，故意忽略了许多技术细节和优化。但这已经足够为我们的攻击方法提供一个高层次的概述。

---

**CS 方案的泄露** 我们的攻击依赖于 CS 方案泄露模式的三个子组件，这些子组件在 [14] 中已被建立。以下是这些泄露子组件的简化和非正式总结（详细内容请见第 4 节）：

1. **路径长度（Path Length）**：从根节点到任何查询子串𝑞匹配节点的路径长度（如果存在这样的匹配节点）。
2. **响应量（Response Volume）**：任何查询子串𝑞的匹配出现次数。
3. **公共前缀长度（Common Prefix Length）**：任意两个查询子串（𝑞, 𝑞′）之间最长公共前缀的长度。

我们特别指出，CS 方案的整体泄露模式远比上述子组件的组合要大得多。事实上，正如我们在第 4 节中讨论的，一个**被动攻击者**仅通过观察客户端与服务器在 CS 搜索协议执行期间交换的消息记录，就可以直接推导出上述泄露组件。换句话说，该攻击不仅可以由恶意服务器执行，还可以由任何能够观察客户端与服务器通信的恶意实体执行。

### 2.3 我们的攻击概述

我们利用上述泄露子组件设计了一种针对 CS 方案的**查询恢复攻击**。我们的攻击核心原理如下：我们展示了如何基于 CS 方案的泄露子组件以及一个近似的原始数据库版本（辅助数据），开发新的子串查询统计模型。随后，我们使用这些模型开发了一种新的推断式泄露密码分析攻击，目标是实现查询重建。我们还强调，我们的攻击假设服务器是 " 诚实但好奇 "（被动窃听）的。这是更广泛的 SSE（可搜索加密）文献中最常假设的攻击模型，而 [14] 的作者声称 CS 方案在更强的 " 完全恶意服务器 " 模型下是安全的。因此，我们的攻击在一个比 CS 方案原本声称安全的攻击模型更弱的环境下工作。更多关于攻击的详细描述请参考第 4 节。

#### 2.3.1 **辅助数据**

我们的攻击使用了辅助数据，即假设与目标数据库分布相同的额外数据。更具体地说，我们假设目标数据库和辅助数据库是从同一分布中独立采样的。这一假设比 " 已知数据攻击 "（如 [2, 8, 34, 37]）更弱，因为后者假设辅助数据库和目标数据库是完全相同的。

在我们的实验评估中，具体的采样策略可以总结如下：给定一个数据集，我们将其中一半作为攻击目标（用于生成泄露信息），而将另一半的子样本用作辅助数据。通过这种方式，我们有效地使用了来自相同经验分布的独立样本来定义目标和辅助数据分布。这类似于机器学习中将训练数据与测试数据分离的标准方法。第 5 节中对此方法有更详细的描述。

有人可能会认为，我们将可用数据分成两组，一组用于创建辅助分布，另一组用于实验的做法过于理想化，因为这实际上为攻击者提供了一个已知的明文分布。虽然这一点是事实，但我们认为：

1. 即使在这种设置下，方案也应该能够隐藏查询；
2. 我们的假设比相关工作中使用的已知明文假设（如 [2, 8, 34, 37]）更弱；
3. 我们可以通过使用两个不同（但相关）的分布，或向辅助分布中添加噪声来放宽这一假设。我们将后者的探索留待未来研究。

---

#### 2.3.2 **攻击思路**

我们的攻击核心思路是解决一个优化问题，其中目标函数是给定观察到的泄露信息和辅助数据作为先验信息时，候选子串分配到查询的形式化似然性（likelihood）。我们随后使用**模拟退火算法（simulated annealing）** 最大化目标函数，这相当于最大化解决方案的似然性。因此，如果模拟退火算法有效，它将生成 " 良好 " 的解决方案，其中许多候选子串被正确地分配到对应的查询。当然，也可以使用任何高效的优化技术代替模拟退火算法。

这一方法需要仔细的数学分析来推导似然函数。我们基于之前针对关键词搜索 SSE 方案的攻击工作（如 [33]），并将这些分析适配于 CS 方案的泄露信息。

---

#### 2.3.3 **单字符串与多字符串**

原始的 CS 方案仅处理单字符串，我们将其推广到处理多字符串。一些实验攻击是在多字符串设置中进行的。然而，我们希望强调，我们的攻击在单字符串和多字符串设置中同样有效。特别地，对于长度总和为𝐿的字符串集合，其多字符串设置的性能与单字符串设置中长度为𝐿的字符串是相同的。这是因为在多字符串设置中，方案首先通过使用特殊符号标记每个字符串的结尾，将所有字符串连接成一个长字符串；然而，我们的攻击从不涉及包含该符号的子串。

---

#### 2.3.4 **攻击实现**

我们展示了如何在大量查询和泄露信息上高效地评估似然函数。这尤其具有挑战性，因为与之前针对关键词查询恢复的推断式攻击方法（如 [16, 33, 54, 55]）相比，对于任意子串的候选集，即使在中等大小的数据库中，其规模也大得多。为了解决这一问题，我们设计并实现了多种计算优化和近似技术，使我们的攻击在查询子串的数量、辅助信息中的候选子串数量以及目标数据集的大小方面高度可扩展。我们为速度和灵活性开发了自己的模拟退火算法实现。

---

#### 2.3.5 **实验评估**

在第 5 节中，我们对提出的攻击进行了广泛的实验评估，以验证其在**英文维基百科**和**NCBI 基因组数据集**上的实用性。实验表明，我们的攻击在合理的实际效率下实现了较高的成功率，并且能够扩展到大规模数据集。

1. **英文维基百科**（100,000 个维基百科页面，2,000 个查询）：
    - 攻击成功恢复了超过 50% 的查询；
    - 如果专注于恢复查询的字符，我们的攻击达到了超过 70% 的字符恢复率；
    - 如果包括短查询（长度为 1 或 2 的查询），上述恢复率分别提高到 64% 和 80%。
2. **NCBI 基因组数据集**（字符数量与 100,000 个维基百科页面相当，2,000 个查询）：
    - 攻击成功恢复了超过 60% 的查询；
    - 字符恢复率也超过了 60%。

### 2.4 相关工作

#### 2.4.1 **其他子串 -SSE 方案**

据我们所知，[14] 提出的 CS 方案是唯一一个基于**后缀树（suffix trees）** 的子串 -SSE（可搜索加密）方案。除此之外，只有少数其他子串 -SSE 方案存在（如 [20, 36, 51]），它们采用的技术与后缀树完全不同，因此具有不可比拟的泄露模式。具体来说：

- [20] 将子串匹配建模为 n-gram 上的合取查询（conjunctions），并使用受关键词合取查询 SSE 技术启发的方法（如 [9, 10, 38]）。
- [36] 将子串查询视为范围查询（range queries）的特例，并提出了一种基于**顺序保持加密（order-preserving encryption）**的构造方法（参考 [3, 4]）。
- [51] 提出了基于加密 Ferragina-Manzini 索引（encrypted Ferragina-Manzini indices）（参考 [22, 23]）的方法。

这些方案所用技术和泄露模式的多样性使得针对所有子串匹配方案的通用攻击策略变得不可能。这与关键词/范围查询 SSE 不同，因为绝大多数此类方案的泄露模式是相似的（详见 [33] 的讨论）。

---

#### 2.4.2 **基于全同态加密（FHE）的子串匹配**

一些先前的研究（如 [5]）探索了使用**全同态加密（Fully Homomorphic Encryption, FHE）**技术进行子串匹配的可能性。研究 SSE 及其泄露的动机在于，SSE 为结构化加密数据库上的特定查询类别提供了显著更高效和可扩展的替代方案，尽管这需要以向攻击者服务器泄露部分信息为代价。作为一个具体的比较：

- [20] 报告其子串 -SSE 方案在 10TB 大小的数据库上查询处理时间为 40 秒；
- 而 [5] 报告其基于 FHE 的子串匹配方案在一个长度为 10、包含 1080 个字符的单字符串上的查询处理时间也为 40 秒。

由于性能对实际应用至关重要，将子串 -SSE 作为通用 FHE 解决方案的替代方案显然具有重要意义。同时，理解此类 SSE 方案泄露的影响也非常重要。传统方法是通过**泄露密码分析（leakage cryptanalysis）**来研究泄露的影响，而在我们工作之前，这种方法尚未被用于子串 -SSE 的研究。

---

#### 2.4.3 **应对泄露密码分析的对策**

最近的研究探讨了抑制某些类型泄露（特别是**响应量泄露**）的技术，这些研究主要针对关键词搜索的 SSE 方案（如 [25, 29, 35, 42, 57]）和范围查询（如 [17]）。由于我们的攻击利用了 CS 方案中的响应量泄露，一个自然的问题是，是否可以通过对 CS 方案应用响应量泄露抑制技术来作为对抗我们攻击的对策。

遗憾的是，这种方法并不可行，因为我们攻击中利用的响应量泄露实际上是 CS 方案查询执行方法的重要组成部分（泄露来自后缀树中每个节点存储的一个值，该值用于确定查询执行期间后缀树的遍历方式——详见第 3 节的详细说明）。如果抑制了这部分泄露，方案可能无法正常运行。因此，目前尚不清楚如何在不影响方案功能的情况下抑制这种泄露。我们将设计针对我们提出攻击的对策视为一个有趣的开放问题。

## 3 前置知识

在本节中，我们介绍了贯穿全文使用的符号表示，并正式定义了子串 -SSE（Substring-SSE）。为了完整性，我们首先介绍明文子串匹配的语法，然后给出子串 -SSE 的定义。定义基于单客户端、单服务器的设置，其中假设服务器是被动窃听的（即**半诚实模型，semi-honest**）。我们注意到，这是 SSE 文献中最广泛研究的设置（参考 [9, 10, 13, 15]）。

---

### 3.1 **明文子串匹配**
明文子串匹配的数据库建模如下：

- 设数据库 $\text{DB} = (S_1, \dots, S_N)$ 是一个字符串集合（称为数据库），其字符来自一个共享的字母表 $\Sigma$，即对于所有 $i \in [1, N]$，有 $S_i \in \Sigma^*$。
- 一个明文子串查询 $\text{Query} : \Sigma^* \times (\Sigma^*) \to \{0, 1\}^*$ 接收一个明文查询字符串 $q \in \Sigma^*$ 和明文数据库 $\text{DB} = (S_1, \dots, S_N)$ 作为输入，并输出一个索引对的列表 $((i_k, j_k))_{k=1}^l$，其中满足以下条件：

 $$
  S_{i_k}[j_k, (j_k + |q|)] = q, \quad \forall k = 1, \dots, l.
 $$

我们称查询 $\text{Query}$ 是**正确的**，当且仅当 $\text{Query(DB, q)}$ 能返回数据库 $\text{DB}$ 中所有与查询字符串 $q$ 匹配的索引对。为了简化表示，我们用 $\text{DB(q)}$ 表示 $\text{Query(DB, q)}$。

---

### 3.2 **子串 -SSE 的语法**

一个**子串可搜索对称加密**（Substring-Searchable Symmetric Encryption, Substring-SSE）方案 $\Pi$ 定义为包含以下三个算法的元组：

$$
\Pi = (\text{Gen}, \text{Setup}, \text{EQuery})
$$

1. **密钥生成**：

  $$
   \text{sk} \leftarrow \text{Gen}_{\text{Clt}}(1^\lambda)
  $$

   - 这是一个由客户端 $\text{Clt}$ 执行的概率算法。
   - 输入：一个安全参数 $1^\lambda$。
   - 输出：一个秘密密钥 $\text{sk}$。

2. **数据库加密设置**：

  $$
   (\perp, \text{EDB}) \leftarrow [\text{Setup}_{\text{Clt}}(\text{sk}, \text{DB}), \text{Setup}_{\text{Svr}}()]
  $$

   - 这是客户端 $\text{Clt}$ 和服务器 $\text{Svr}$ 之间的交互协议。
   - 客户端输入：秘密密钥 $\text{sk}$ 和明文数据库 $\text{DB}$。
   - 服务器输入：无。
   - 输出：服务器生成一个加密数据库 $\text{EDB}$。

3. **加密查询**：

  $$
   (((i_k, j_k))_{k=1}^l, \perp) \leftarrow [\text{EQuery}_{\text{Clt}}(\text{sk}, q), \text{EQuery}_{\text{Svr}}(\text{EDB})]
  $$

   - 这是客户端 $\text{Clt}$ 和服务器 $\text{Svr}$ 之间的交互协议。
   - 客户端输入：秘密密钥 $\text{sk}$ 和子串查询 $q$。
   - 服务器输入：加密数据库 $\text{EDB}$。
   - 输出：
     - 客户端获得一个响应列表 $((i_k, j_k))_{k=1}^l$，表示查询结果。
     - 服务器无任何输出。

一个子串 -SSE 方案需要满足特定的**正确性**和**安全性**属性（将在后续定义）。

---

#### 3.2.1 **子串 -SSE 的正确性**
我们称子串 -SSE 方案 $\Pi$ 是**正确的**，如果 $\text{EQuery}$ 能返回正确的子串匹配结果。具体来说，对于任意数据库 $\text{DB}$ 和查询字符串 $q$，在执行以下操作序列时：

1.$\text{sk} \leftarrow \text{Gen}_{\text{Clt}}(1^\lambda)$
2.$(\perp, \text{EDB}) \leftarrow [\text{Setup}_{\text{Clt}}(\text{sk}, \text{DB}), \text{Setup}_{\text{Svr}}()]$
3.$((i_k, j_k))_{k=1}^l, \perp \leftarrow [\text{EQuery}_{\text{Clt}}(\text{sk}, q), \text{EQuery}_{\text{Svr}}(\text{EDB})]$

我们有：

$$
((i_k, j_k))_{k=1}^l = \text{Query(DB, q)}。
$$

---

#### 3.2.2 **子串 -SSE 的安全性**
我们定义子串 -SSE 的安全性基于**模拟模型**，针对**半诚实对手**的攻击（即服务器遵守协议，但试图从中推断出明文数据库和查询的信息）。我们的定义采用**真实世界 - 理想世界范式**，并严格遵循 SSE 文献中广泛使用的模拟安全定义。

令 $\Pi = (\text{Gen}, \text{Setup}, \text{EQuery})$ 是一个子串 -SSE 方案，假设：
-$\mathcal{A}$：一个有状态的概率多项式时间（PPT）对手；
-$\mathcal{S}$：一个 PPT 模拟器；
-$\mathcal{L} = (\mathcal{L}_{\text{Setup}}, \mathcal{L}_{\text{EQuery}})$：一个有状态的泄漏函数。

我们定义以下两个概率实验：

1. **真实世界实验**$\text{Real}_{\Pi, \mathcal{A}}(1^\lambda)$：
   - 挑战者运行 $\text{Gen}_{\text{Clt}}(1^\lambda)$ 生成一个秘密密钥 $\text{sk}$。
   - 对手 $\mathcal{A}$ 输出一个数据库 $\text{DB}$。
   - 挑战者与对手交互，执行 $(\perp, \text{EDB}) \leftarrow [\text{Setup}_{\text{Clt}}(\text{sk}, \text{DB}), \text{Setup}_{\text{Svr}}()]$，其中挑战者扮演客户端，$\mathcal{A}$ 扮演服务器。
   - 对手 $\mathcal{A}$ 发起多项式次自适应子串匹配查询：每次查询运行 $[\text{EQuery}_{\text{Clt}}(\text{sk}, q), \text{EQuery}_{\text{Svr}}(\text{EDB})]$，其中 $\mathcal{A}$ 自适应选择查询字符串 $q$。
   - 最后，对手 $\mathcal{A}$ 输出一个比特 $b$，作为实验的输出。

2. **理想世界实验**$\text{Ideal}_{\Pi, \mathcal{A}, \mathcal{S}}(1^\lambda)$：
   - 对手 $\mathcal{A}$ 输出一个数据库 $\text{DB}$。
   - 模拟器 $\mathcal{S}$ 和对手交互，执行 $(\perp, \text{EDB}) \leftarrow [\mathcal{S}(\mathcal{L}_{\text{Setup}}(\text{DB})), \text{Setup}_{\text{Svr}}()]$，其中 $\mathcal{S}$ 扮演客户端，$\mathcal{A}$ 扮演服务器。
   - 对手 $\mathcal{A}$ 发起多项式次自适应子串匹配查询：每次查询运行模拟协议 $[\mathcal{S}(\mathcal{L}_{\text{EQuery}}(q)), \text{EQuery}_{\text{Svr}}(\text{EDB})]$，其中模拟器 $\mathcal{S}$ 扮演客户端，$\mathcal{A}$ 扮演服务器。
   - 最后，对手 $\mathcal{A}$ 输出一个比特 $b$，作为实验的输出。

---

#### 3.2.3 **安全性定义**
我们称子串 -SSE 方案 $\Pi$ 在自适应选择查询攻击下是 $\mathcal{L}$- 安全的，如果对于任意 PPT 对手 $\mathcal{A}$，存在一个 PPT 模拟器 $\mathcal{S}$，使得以下不等式成立：

$$
\Big| \Pr[\text{Real}_{\Pi, \mathcal{A}}(1^\lambda) = 1] - \Pr[\text{Ideal}_{\Pi, \mathcal{A}, \mathcal{S}}(1^\lambda) = 1] \Big| \leq \text{negl}(\lambda)。
$$

其中 $\text{negl}(\lambda)$ 表示一个关于安全参数 $\lambda$ 的可忽略函数。

#### 3.2.4 **基于推断的泄漏密码分析**
需要注意的是，上述安全性定义非正式地表达了以下事实：一个**半诚实的对手服务器**无法超出泄漏函数 $\mathcal{L} = (\mathcal{L}_{\text{Setup}}, \mathcal{L}_{\text{EQuery}})$ 所描述的范围，了解客户端明文数据库和查询的任何信息。在本文中，我们设计了**查询重构攻击**，其中半诚实对手利用泄漏函数 $\mathcal{L}$ 来恢复客户端的查询。
我们的攻击属于**推断攻击**。更具体地说，我们假设攻击者可以访问一些关于底层明文数据库的辅助统计信息。基于这些数据库的统计信息以及加密查询执行的通信记录，半诚实攻击者试图推断底层的明文查询。

---

#### 3.2.5 **半诚实与恶意腐败**
需要在此指出的是，Chase 和 Shen 在 [14] 中最初声称其 CS 方案在一个更严格的安全模型下是安全的，该模型允许服务器被**恶意腐败**。在上述的安全性定义中，我们仅考虑了服务器的**半诚实腐败**，这是一种更弱的对手模型（除此之外，上述安全性定义与 [14] 中的定义相同）。我们选择在半诚实对手模型下定义子串 -SSE 的安全性，以与我们提出的攻击场景保持一致，该场景假设对手是半诚实的。

---

## 4 CS 方案及其泄露

在本节中，我们概述了由 Chase 和 Shen 在文献 [14] 中提出的第一个子串 -SSE 方案（CS 方案）。此外，我们还讨论了其泄漏特性，并在后续中利用这些泄漏特性实施查询重构攻击。

本节的结构如下：
- 在**3.1 节**，我们简要介绍了后缀树（suffix tree），这是 CS 方案的主要数据结构。
- 接着在**3.2 节**，我们描述了 CS 方案的具体内容。
- 最后在**3.3 节**，我们概述了 CS 方案的泄漏特性。

---

### 4.1 **后缀树**

在本节中，我们介绍了后缀树，这是一种用于 CS 方案的核心数据结构。

#### 4.1.1 **后缀树（Suffix Tree）**
设 $S$ 是一个长度为 $n$ 的字符串。字符串 $S$ 的后缀树 $T_S$ 是满足以下属性的树：

1. 树有且仅有 $n$ 个叶节点。
2. 除根节点外，每个内部节点至少有两个子节点。
3. 每条边都标记为 $S$ 的一个非空子串。
4. 以同一节点为起点的任意两条边，其起始字符不能相同。
5. 设 $N$ 是后缀树 $T_S$ 的一个内部节点或叶节点。从根节点到节点 $N$ 的路径上的字符串，定义为从根到 $N$ 的所有边上的字符串的连接。
   - 节点 $N$ 存储 $S$ 中该路径字符串首次出现的起始索引。

从现在起，我们用 $\text{ind}(N)$ 表示存储在节点 $N$ 中的字符串索引，用 $\text{path}(N)$ 表示从根节点到节点 $N$ 的路径字符串。

---

#### 4.1.2 **多字符串的后缀树**
上述描述的后缀树可以推广以支持多个字符串，得到的数据结构称为**广义后缀树（Generalised Suffix Tree）** [1]。广义后缀树与普通后缀树的主要区别在于：
- 在广义后缀树中，节点不再只存储匹配的起始索引，而是存储字符串索引（即子串出现在哪些字符串中）以及匹配的起始位置。
- 为方便起见，我们仍将存储在节点中的内容称为 " 索引 "。

图 1 展示了一个广义后缀树的例子，该树表示两个字符串 "hello" 和 "help"。

虽然 Chase 和 Shen [14] 仅描述了如何使用他们的方案对单个字符串进行搜索，但该方案可以轻松扩展以支持多个字符串的搜索。在我们的攻击中，我们考虑了支持多个字符串的方案版本，但我们的攻击对原始的单字符串版本同样有效。

---

#### 4.1.3 **使用广义后缀树进行子串查询**
我们现在说明如何利用表示多个字符串的广义后缀树高效地执行（明文）子串匹配查询。
- **单个匹配**：例如，考虑子串查询 "ell"。通过在后缀树（图 1）中以 "ell" 进行遍历，我们会到达节点 $N_9$。虽然节点 $N_9$ 存储的是后缀 "ello" 的起始索引，但由于 "ell" 是 "ello" 的前缀，因此该索引也是子串 "ell" 的起始索引。通过遍历后缀树，我们可以得到与查询 "ell" 对应的正确响应。
- **多个匹配**：后缀树同样支持具有多个匹配的子串查询。例如，考虑子串查询 "he"。在这里，与其仅检索存储在节点 $N_2$ 中的索引，不如检索以 $N_2$ 为根的子树中所有叶节点存储的索引。由于这些叶节点包含所有以 "he" 开头的后缀的起始索引，检索这些叶节点存储的所有索引即可得到 "he" 的所有匹配结果。

### 4.2 **CS 方案：基于后缀树构建子串 -SSE**

在本节中，我们展示了 Chase 和 Shen [14] 如何基于后缀树构建他们的子串 -SSE 方案 CS。按照他们的描述，我们展示了构建子串 -SSE 方案的三个尝试。

---

#### 4.2.1 **第一次尝试**

[14] 中的第一个想法如下：
设 $F$ 是一个伪随机函数，$\Gamma$ 是一个 CPA 安全的对称加密方案。令 $sk_1$ 是 $F$ 的密钥，$\text{sk}_2$ 是 $\Gamma$ 的密钥。设节点 $N$ 是后缀树中的一个非根节点。子串 -SSE 方案的加密过程如下：

1. 计算伪随机函数值 $t = F_{sk_1}(\text{path}(N))$。
2. 加密存储在节点 $N$ 中的索引 $c = \Gamma.\text{Enc}_{sk_2}(\text{ind}(N))$。
3. 将 $(t, c)$ 存储在加密字典 $D$ 中，其中 $t$ 作为键，$c$ 作为值。
4. 对所有非根节点执行上述过程。

此方案允许客户端通过加密查询的形式查询后缀树中的所有路径子串，查询形式为 $eq = F_{sk_1}(q)$。如果 $q$ 是路径之一，则伪随机函数值 $F_{sk_1}(q)$ 会存在于加密字典 $D$ 中，字典中存储的值 $D[t]$ 是查询 $q$ 的第一个匹配索引的加密值。
**注意**：由于加密字典 $D$ 无法实现树的遍历，该方案只能返回第一个匹配索引。

##### 4.2.1.1 **返回可能的匹配**
定义 $\text{initpath}(N)$ 为从根节点到节点 $N$ 的路径上所有边上的字符串的连接，但最后一条边（最接近 $N$ 的边）只取其字符串的第一个字符。例如，在图 1 中：
-$\text{initpath}(N_7) = "hell"$
-$\text{initpath}(N_9) = "ell"$

---

#### 4.2.2 **第二次尝试**

在第二次尝试中，Chase 和 Shen 做出了以下改进：
- 不再使用 $F_{sk_1}(\text{path}(N))$ 查询节点 $N$，而是使用 $F_{sk_1}(\text{initpath}(N))$ 查询节点。
- 具体而言，查询可以通过计算加密查询 $eq = (F_{sk_1}(q[1,1]), \dots, F_{sk_1}(q[1,|q|]))$ 来完成。

给定 $eq$，服务器在加密字典 $D$ 中找到与 $q$ 的最长子串匹配的伪随机函数值，并返回与之关联的值。客户端解密该值以获得字符串索引 $(i, j)$。之后，客户端将 $(i, j|q|)$ 发送给服务器，并检索以下加密值（这些值应在**设置阶段**存储于服务器中）：

$$
\Gamma.\text{Enc}_{sk_2}(S_i[j]), \dots, \Gamma.\text{Enc}_{sk_2}(S_i[j + |q| - 1])
$$

客户端检查解密后的字符是否与 $q$ 相同。如果字符匹配，则 $(i, j)$ 是匹配的索引；否则，$q$ 在数据库中没有匹配。

##### 4.2.2.1 **返回所有匹配**
一个简单的解决方案是让客户端检索查询的所有匹配位置，即将所有匹配索引存储在加密字典中。然而，这种方案在最坏情况下会导致存储需求线性增长（与服务器存储的字符串长度成正比）。

为了解决这一问题，Chase 和 Shen 利用了以下事实：
- 如果节点 $N$ 是第二次尝试中与查询匹配的节点，则查询的所有匹配索引必然与 $N$ 的子树中叶节点存储的索引完全一致。因此，只需将 $N$ 子树的索引信息存储在 $N$ 中，以便稍后访问叶节点。

具体方法如下：
- 令 $\text{leaf}_i$ 是后缀树中的第 $i$ 个叶节点。在**设置阶段**，客户端创建一个加密数组 $L$，其中 $L[i] = \Gamma.\text{Enc}_{sk_2}(\text{ind}(\text{leaf}_i))$。这与加密字典 $D$ 为叶节点存储的索引相同。
- 对于加密字典 $D$，除了存储第一个匹配的索引外，还存储每个条目的子树信息。
  - 对于节点 $N$，定义 $\text{leafpos}(N)$ 为 $N$ 子树中最左叶节点的位置，定义 $\text{num}(N)$ 为 $N$ 子树中叶节点的数量。
  - 然后，对于字典键 $F_{sk_1}(\text{initpath}(N))$，存储 $\Gamma.\text{Enc}_{sk_2}(\text{ind}(N), \text{leafpos}(N), \text{num}(N))$。

假设查询字符串为 $q$，加密子串查询的执行过程如下：

1. **客户端计算查询令牌**
   客户端计算加密查询 $eq = (F_{sk_1}(q[1,1]), \dots, F_{sk_1}(q[1,|q|]))$，并将其发送给服务器。

2. **服务器查找最长匹配**
   服务器在加密字典 $D$ 中找到与 $q$ 的最长子串匹配的伪随机函数值，并返回与之关联的值。

3. **客户端解密并获取节点信息**
   客户端解密返回值，获取某个节点 $N$ 的信息，包括：
   -$\text{ind}(N)$：索引值
   -$\text{leafpos}(N)$：子树中最左叶节点的位置
   -$\text{num}(N)$：子树中叶节点的数量

   此节点 $N$ 是 $q$ 的一个前缀。

4. **客户端验证匹配**
   客户端从服务器检索以下加密值：

  $$
   \Gamma.\text{Enc}_{sk_2}(S_i[j]), \dots, \Gamma.\text{Enc}_{sk_2}(S_i[j + |q| - 1])
  $$

   并解密这些值以检查字符是否与 $q$ 匹配。

5. **返回所有匹配索引**
   如果字符匹配，客户端进一步检索：

  $$
    L[\text{leafpos}(N)], \dots, L[\text{leafpos}(N) + \text{num}(N) - 1]
   $$

   并解密这些值以获取所有匹配的索引。

6. **无匹配情况**
   如果字符不匹配，客户端知道 $q$ 在数据库中没有匹配。

---

#### 4.2.3 **进一步的修改**

为了减少信息泄漏，最终的 CS 方案对第三次尝试进行了以下改进：

- **加密查询令牌**
  查询令牌被加密，并且修改了加密字典的内容，使得方案仅在两个查询共享前缀时才泄露信息。

- **节点度数与节点数量的混淆**
  通过填充（padding）混淆后缀树中节点的度数和节点数量，并通过重新排列子节点的顺序隐藏其排列方式。

- **字符串索引的隐藏**
  通过重新排列加密的密文（例如 $\Gamma.\text{Enc}_{sk_2}(S_1[1]), \dots, \Gamma.\text{Enc}_{sk_2}(S_N[|S_N|])$）来隐藏字符串索引。

### 4.3 **CS 方案的泄露分析**

我们现在描述 CS 方案的泄露特性，并通过一个例子来说明泄露情况。

---

#### 4.3.1 **泄露描述**

- **设置阶段的泄露**
  在设置阶段，方案泄露了字符串的总长度。也就是说，如果数据库 $\text{DB} = (S_1, \dots, S_N)$，则泄露如下信息：

 $$
  \mathcal{L}_{\text{Setup}}(\text{DB}) = \sum_{i=1}^N |S_i|
 $$

- **查询阶段的泄露**
  在查询阶段（$\mathcal{L}_{\text{EQuery}}$），对于一个子串查询 $q$，设节点 $N$ 是后缀树 $T$ 中 $q$ 的最长前缀。处理查询 $q$ 时，方案泄露以下信息：
  - 查询的长度 $|q|$
  - 前缀的长度 $|\text{initpath}(N)|$

  对于一系列查询 $q_1, \dots, q_l$，CS 方案还泄露以下三个附加模式：

---

#### 4.3.2 **附加泄露模式**

1. **查询前缀模式（Query Prefix Pattern, QP）**
   查询前缀模式 $\text{QP}(\text{DB}, q_1, \dots, q_l)$ 指示每个查询 $q_l$ 访问的节点是否也被之前的查询访问过。
   - 该模式可以表示为一个 $l \times n_l$ 的矩阵，其中 $n_l$ 是查询 $q_l$ 访问的节点数。
   - 矩阵的第 $(i, j)$ 个条目为 1，表示查询 $q_i$ 访问了查询 $q_l$ 访问的第 $j$ 个节点；否则为 0。

2. **叶节点交集模式（Leaf Intersection Pattern, LP）**
   叶节点交集模式 $\text{LP}(\text{DB}, q_1, \dots, q_l)$ 表示查询 $q_l$ 检索的叶节点索引是否也被之前的查询检索过。
   - 该模式可以表示为一个 $l \times m_j$ 的矩阵，其中 $m_j$ 是查询 $q_l$ 检索的叶节点数。
   - 令 $r_1 : [m_j] \to [m_j]$ 是一个随机排列。矩阵的第 $(i, j)$ 个条目为 1，表示查询 $q_i$ 检索的第 $r_1(i)$ 个叶节点也被查询 $q_l$ 检索过；否则为 0。

3. **索引交集模式（Index Intersection Pattern, IP）**
   索引交集模式 $\text{IP}(\text{DB}, q_1, \dots, q_l)$ 表示查询 $q_l$ 检索的字符串索引是否也被之前的查询检索过。
   - 该模式可以表示为一个 $l \times |q_l|$ 的矩阵。
   - 令 $r_2 : [|q_l|] \to [|q_l|]$ 是一个随机排列。矩阵的第 $(i, j)$ 个条目为 1，表示查询 $q_i$ 检索的第 $r_2(i)$ 个字符串索引也被查询 $q_l$ 检索过；否则为 0。

---

#### 4.3.3 **泄露示例**

为了说明方案的泄露情况，考虑以下数据库：

$$
\text{DB} = (\text{"hello"}, \text{"help"})
$$

- 服务器得知叶节点总数为 9（$\lvert L \rvert = 9$），这正是字符串的总长度。

#### 4.3.4 **查询示例**
1. 查询 $q_1 = \text{"ello"}$ 和 $q_2 = \text{"elp"}$：
   - 服务器得知 $|q_1| = 4$ 和 $|q_2| = 3$，因为服务器看到了 4 个和 3 个加密的伪随机函数（PRF）值。
   - 服务器还得知：

    $$
     |\text{initpath}(\text{"ello"})| = |\text{"ell"}| = 3
    $$$$

     |\text{initpath}(\text{"elp"})| = |\text{"elp"}| = 3

    $$
     这是因为用于检索这些初始路径的 PRF 值表明 PRF 的输入长度为 3。






1. **联合分析 $q_1$ 和 $q_2$**
   通过同时观察 $q_1$ 和 $q_2$，一个半诚实的攻击者可以立即推断以下信息：

   - **查询前缀模式**
     服务器观察到节点 $N_3$ 是两个查询的共享前缀，因为它被两个查询访问。服务器还得知 $|\text{initpath}(N_3)| = 1$，因为它必须通过 $F_{sk_1}(q_1[1,1])$ 或 $F_{sk_1}(q_2[1,1])$ 检索。

   - **叶节点交集模式**
     服务器没有观察到叶节点交集，因为两个查询访问了不同的节点集（分别是 $\{N_9\}$ 和 $\{N_{10}\}$）。然而，服务器可以推断两个查询的响应量均为 1。

   - **索引交集模式**
     服务器没有观察到索引交集，因为第一个字符串出现在 $\text{initpath}(q_1)$ 的第一次出现中，第二个字符串出现在 $\text{initpath}(q_2)$ 的第一次出现中。

---

CS 方案在设置阶段和查询阶段都会泄露一些信息，这些信息包括字符串总长度、查询长度、前缀长度，以及查询之间的前缀模式、叶节点交集和索引交集。这些泄露可能被半诚实的攻击者利用来推断部分查询相关信息。

## 5 **显著的泄露组件**

我们的攻击利用了 CS 方案中以下泄露的组件：

---

### 5.1 **初始路径的长度**
我们的攻击旨在恢复查询的初始路径。初始路径的长度（或 $\text{ipLen}_i = |\text{initpath}(q_i)|$）对于攻击者限制其对初始路径的猜测集合非常有用。

---

### 5.2 **• 查询响应量**
查询响应量（或 $\text{vol}_i = |\text{DB}(\text{initpath}(q_i))|$）可以从叶节点交集模式中推断出来。这使攻击者能够提取数据库中初始路径的频率信息。

---

### 5.3 **• 查询之间的字符相等性**
通过叶节点交集模式，攻击者可以发现两个查询的起始字符是否相同。具体来说，考虑后缀树中的查询 $q_1 = \text{"ell"}$ 和 $q_2 = \text{"elp"}$。攻击者得知两个查询都访问了节点 $N_3$。这只有在两个查询的前两个字符相同时才可能发生。
注意，泄露的共享字符数量等于两个查询初始路径的长度减去节点 $N_3$ 路径上的字符串长度。例如，上述情况中，$\text{charEq}(1, 2) = 2$，表示 $q_1$ 和 $q_2$ 有两个相同的字符。
查询之间的字符相等性可以帮助攻击者进一步缩小对查询的猜测范围。

---

## 6 **泄露提取**

上述泄露组件可以直接从 CS 方案执行的记录（transcript）中提取。以下是具体方法：

---

### 6.1 **提取初始路径的长度**
回忆一下，对于查询 $q$，客户端会向服务器发送 $F_{sk_1}(q[1,1]), \dots, F_{sk_1}(q[1,|q|])$。服务器找到最大的 $m$ 使得 $F_{sk_1}(q[1,m])$ 存在于加密数据库中。由于 $m$ 是根据构造等于初始路径的长度，服务器可以从记录中直接得知初始路径的长度。

---

### 6.2 **提取查询响应量**
在搜索的最后一步，假设与查询匹配的最长初始路径是节点 $N$。那么客户端将检索 $L[\text{leafpos}(N)], \dots, L[\text{leafpos}(N) + \text{num}(N) - 1]$（最终方案中会使用一个随机排列版本）。检索的叶节点数量等于 $\text{num}(N)$，即与节点 $N$ 匹配的索引数。这使服务器能够直接得知查询响应量。

---

### 6.3 **提取查询之间的字符相等性**
为了简单起见，考虑查询 $q_i$ 和 $q_j$。
- 对于 $q_i$，客户端计算并向服务器发送伪随机函数值 $F_{sk_1}(q_i[1,1]), \dots, F_{sk_1}(q_i[1,|q|])$。
- 对于 $q_j$，这些值是 $F_{sk_1}(q_j[1,1]), \dots, F_{sk_1}(q_j[1,|q|])$。

关键点在于，如果 $q_i$ 和 $q_j$ 存在非空的公共前缀，即存在 $k \geq 1$ 使得 $q_i[1,k] = q_j[1,k]$，那么两个查询的前 $k$ 个伪随机函数值将相同。因此，服务器只需比较客户端发送的伪随机函数值，即可得知查询之间的字符相等性。

## 7 **泄露表示**

在我们的攻击中，我们处理上述泄露信息，并将加密查询表示为由整数组成的令牌列表，其中每个令牌表示一个整数。如果相同的令牌出现在两个加密查询中，则意味着这两个查询中的对应字符是相同的。例如，对于 $q_1 = \text{"ell"}$ 和 $q_2 = \text{"elp"}$，由于 $\text{charEq}(1, 2) = 2$，我们可以分别将查询的加密版本表示为 $(1, 2, 3)$ 和 $(1, 2, 4)$。我们的攻击试图将这些令牌映射到查询中使用的字母表。

值得注意的是，我们感兴趣的加密查询的长度仅与原始查询的初始路径长度相同。这是因为根据设计，服务器只能获取与初始路径相关的信息。

---

## 8 **符号说明**

在下面的攻击描述中，我们使用以下符号：
- 我们滥用符号并将 $eq_i = (tk_{i,1}, \dots, tk_{i,m_i})$ 表示为查询 $q_i$ 的加密形式，其中 $m_i$ 是查询 $q_i$ 初始路径的长度。
- 我们用 $|\text{DB}(eq_i)|$ 表示查询 $q_i$ 的初始路径的查询响应量。

---

## 9 **泄露输入表示**

使用上述符号，我们攻击的泄露输入可以简单地表示为以下内容：
1. 令牌序列的集合 $(tk_{i,1}, \dots, tk_{i,m_i})_{i=1}^l$，其中 $l$ 是查询的数量。
2. 它们对应的查询响应量 $(vol_i)_{i=1}^l$，其中 $vol_i = |\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))|$。

## 10 **我们的攻击**

根据上述泄露信息，我们设计了一种推断攻击，试图恢复与令牌对应的字母表。通过这样做，我们可以恢复查询的初始路径。

---

## 11 **核心思路**

我们的攻击有三个核心组成部分：

1. **确定候选集**
   首先，我们需要确定对每个加密查询进行猜测的集合，我们称之为加密查询的**候选集**。
   - 在高层次上，借助一些辅助信息，我们可以利用初始路径的长度和查询响应量来过滤掉不太可能的猜测，从而缩小每个加密查询的候选集。
   - 然后，我们可以利用查询之间的字符相等性泄露进一步减少候选集的大小。

2. **建立统计模型**
   一旦我们为所有加密查询获得了候选集，就需要一个统计模型来衡量对加密查询的猜测与观察到的泄露信息的契合程度。
   - 为此，我们使用泊松分布（Poisson distribution）来建模子字符串出现的次数，其中分布的参数由一些辅助数据决定。
   - 然后，我们根据观察到的泄露组件计算一个猜测的可能性（似然值）。

3. **高效搜索算法**
   最后，我们需要使用一种高效算法，在可能的猜测集合中搜索，并基于统计模型找到最可能的猜测结果。

## 12 **识别候选集**

定义 $\text{CandSet}: \mathbb{N}^* \to \mathcal{P}(\Sigma^*)$，它是一个将令牌序列映射到所有可能字符串子集的映射。我们的目标是为每个加密查询找到候选集，并尽可能缩小候选集的范围，以提高后续搜索过程的效率。

---

### 12.1 **候选集的识别步骤**

在我们的攻击中，候选集的识别分为两个步骤：

1. **频率分析**
   假设存在某种辅助信息 $\text{Aux}: \Sigma^* \to \mathbb{R}$，它可以告诉攻击者查询 $s$ 的期望响应量。攻击者可以通过以下方式设置候选集：
   $
   \text{CandSet}((tk_{i,1}, \dots, tk_{i,m_i})) = \{s : |s| = m_i \land ||\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))| - \text{Aux}(s)| < \epsilon \cdot \sqrt{|\text{DB}((tk_{i,1}, \dots, tk_{i,m_i}))|}\}
   $
   其中 $\epsilon$ 是一个阈值。在我们的实验中，我们在真实数据集上确定了该阈值的取值（详见论文第 5 节）。

2. **裁剪候选集**
   上述步骤可能会生成非常大的候选集（通常在 $10^3$ 的数量级以上）。对于 $l$ 个查询，搜索空间的大小大约为 $10^{3l}$，这使得高效搜索变得不可行。因此，我们引入了一种裁剪算法，在运行攻击的主要算法之前缩小搜索空间。

---

### 12.2 **裁剪算法的核心思想**

裁剪算法的核心思想是：
- 利用每个令牌的候选集（而不是整个令牌序列），确定每个令牌最可能的字符。
- 然后使用这些字符进一步裁剪候选集。

**示例**：
假设有以下候选集：
- 对于令牌序列 $(1, 2, 3)$，$\text{CandSet}((1, 2, 3)) = \{"ell", "ali"\}$。
- 对于令牌序列 $(1, 2, 4)$，$\text{CandSet}((1, 2, 4)) = \{"elp", "bob"\}$。

从中可以推断出，令牌 1 最可能对应字符 "e"，因为它出现在两个候选集中。
因此，可以将候选集裁剪为：
-$\text{CandSet}((1, 2, 3)) = \{"ell"\}$
-$\text{CandSet}((1, 2, 4)) = \{"elp"\}$

**注意**：
- 可能存在真实查询未包含在候选集中的情况（例如，观察到的查询响应量与子字符串的期望频率相差过大）。
- 因此，我们采用一种 " 软决策 " 过程：即使某些字符未出现在所有候选集中，它们仍可能被视为可能字符。

---

## 13 **裁剪过程的实现**

我们初始化一个数组 $\text{Arr}: \mathbb{N} \times \Sigma \to \mathbb{N}$，它将令牌和字母表中的字符映射到一个整数。
- 该数组以所有可能的令牌 - 字符对初始化，初始值为 0。
- 对于每个令牌序列 $(tk_{i,1}, \dots, tk_{i,m_i})$，统计候选集中每个位置出现的字符。
- 对于令牌序列中的每个令牌 $tk$ 和候选集中出现的每个字符 $c$，将 $\text{Arr}(tk, c)$ 加 1。

完成所有令牌序列的统计后，创建一个映射 $\text{TokenCandSet}: \mathbb{N} \to \mathcal{P}(\Sigma)$，将每个令牌映射到字母表的一个子集。
- 对于令牌 $tk$，$\text{TokenCandSet}(tk)$ 包含 $\text{Arr}(tk, c)$ 值最大的 $t$ 个字符。
- 如果有多个字符的值相同且为最大值，则将这些字符都加入 $\text{TokenCandSet}(tk)$。

最终，$\text{TokenCandSet}$ 可用于裁剪 $\text{CandSet}$。
- 该过程将重复进行，直到裁剪不再改变 $\text{CandSet}$。
- 裁剪过程的伪代码可参见算法 1。

## 14 **观察泄露信息的统计模型**

给定候选集 $\text{CandSet}$，攻击者可以开始对查询初始路径的明文进行猜测，即 $\text{guess}: \mathbb{N}^* \to \Sigma^*$。然而，我们仍然需要衡量每个猜测的质量，以便选择最佳的猜测作为攻击的输出。

为此，我们将查询响应量建模为泊松分布（Poisson distributions）。这些单独的分布被组合在一起，形成所有查询的联合分布。随后，我们应用标准的统计技术，将联合分布转化为似然函数。

---

## 15 **似然函数**

由于篇幅限制，我们在附录 A 中给出了似然函数的推导过程。在本节的其余部分，我们描述了攻击者如何搜索最大化似然函数的猜测。

## 16 **猜测的一致性**

请注意，在上述攻击的描述中，每个查询的猜测是单独进行的。这意味着可能会出现如下情况：
- 对于查询 $(1, 2, 3)$，猜测为 "elp"；
- 对于查询 $(1, 2, 4)$，猜测为 "bob"。

尽管我们知道这两个查询的前两个字符必须相同，但猜测却不一致。

在我们的攻击中，我们选择以迭代的方式进行猜测，并跟踪我们对各个令牌所做的猜测。对某个令牌的新猜测可以覆盖旧的猜测。具体而言，对于上述例子：
- 首先，我们对查询 $(1, 2, 3)$ 进行猜测，得到 "elp"；
- 随后，对查询 $(1, 2, 4)$ 进行猜测，得到 "bob"。

由于第二次猜测覆盖了令牌 1 和令牌 2 的猜测，最终将 $(1, 2, 3)$ 的猜测更改为 "bop"。

这种方法允许我们在保持令牌一致性的同时，可能会导致查询的次优猜测。然而，我们认为这并不是一个主要问题，因为次优猜测通常会产生较低的似然分数，因此不太可能被后续的优化算法接受。

---

## 17 **最大化似然函数**

我们使用模拟退火算法（Simulated Annealing）来最大化似然函数。
对应的伪代码可以在算法 2 中找到，其中的得分函数 $\text{score}()$ 正是之前数学上描述的似然函数。

该过程包括五个主要子程序：

1. **Initial_solution(CandSet)**
   - 算法接收候选集 $\text{CandSet}$ 作为输入，并输出一个初始猜测 $\text{guess}$，用于模拟退火的初始解。

2. **Neighbour(guess, CandSet)**
   - 算法接收当前猜测 $\text{guess}$ 和候选集 $\text{CandSet}$ 作为输入，并输出一个接近当前猜测的新猜测 $\text{guess}'$。

3. **score(guess,$(tk_{i,1}, \ldots, tk_{i,m_i})_{i=1}^l$,$(vol_i)_{i=1}^l$, Aux)**
   - 算法接收以下输入：
     - 一个猜测 $\text{guess}$；
     - 一个令牌列表 $(tk_{i,1}, \ldots, tk_{i,m_i})_{i=1}^l$；
     - 一个观察到的查询响应量列表 $(vol_i)_{i=1}^l$；
     - 一个辅助分布 $\text{Aux}$。
   - 输出一个得分 $\text{sc}$。

4. **Cooling(T)**
   - 算法接收温度 $T$ 作为输入，并输出一个新的温度 $T'$。

5. **Accept_prob(sc, sc', T)**
   - 算法接收以下输入：
     - 两个得分 $\text{sc}$ 和 $\text{sc}'$；
     - 温度 $T$。
   - 根据输入和一定的随机性，输出 0 或 1。

### 17.1 模拟退火算法的完整运行过程

以下是五个子程序在模拟退火算法中的组合步骤：

1. **初始解生成：**
   - 执行 $\text{Initial\_solution(CandSet)}$ 来生成一个初始猜测 $\text{guess}$。

2. **温度初始化：**
   - 初始化一个温度 $T$。

3. **迭代过程：**
   - 随后，以下过程将在固定的迭代次数内重复执行：
     - 调用冷却子程序 $\text{Cooling(T)}$，生成一个新的温度 $T'$。同时，计算当前猜测的邻居 $\text{guess'} \leftarrow \text{Neighbour(guess, CandSet)}$。
     - 对新的猜测 $\text{guess'}$ 计算得分 $\text{sc}{\prime} \leftarrow \text{score}\left(\text{guess}{\prime},\, \left(tk_{i,1}, \ldots, tk_{i,m_i}\right)_{i=1}^l,\, (vol_i)_{i=1}^l,\, \text{Aux}\right)$。
       假设旧的得分为 $\text{sc} \leftarrow \text{score}\left(\text{guess},\, \left(tk_{i,1}, \ldots, tk_{i,m_i}\right)_{i=1}^l,\, (vol_i)_{i=1}^l,\, \text{Aux}\right)$。
     - 调用 $\text{Accept\_prob(sc, sc', T)}$，输出 0 或 1。
     - 如果输出为 0，则保持当前猜测不变，模拟退火进入下一次迭代。
     - 如果输出为 1，则用新的猜测 $\text{guess'}$ 替换旧的猜测 $\text{guess}$，模拟退火进入下一次迭代。
