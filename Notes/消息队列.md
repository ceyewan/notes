## 1 消息队列的基本概念

### 1.1 消费队列的作用

- **解耦**：发送方（生产者）和接收方（消费者）不需要直接交互，通过消息队列实现松耦合，方便系统扩展和维护。
- **异步处理**：生产者发送消息后无需等待消费者处理完成，提高系统响应速度和并发能力。
- **削峰填谷**：通过消息排队处理高峰流量，防止瞬时请求过载，保护后端系统稳定性。
- **可靠通信**：提供消息持久化、重试机制，保证消息不丢失，提高系统可靠性。
- **流量控制**：可通过消费者数量调整处理速度，平衡系统负载。

### 1.2 Redis Stream 核心组件

- **生产者**：向 Stream 中发布消息（`XADD` 命令）。
- **消费者**：从 Stream 中读取消息（`XREAD` 或 `XREADGROUP` 命令）。
- **消息**：Stream 中的每条消息由一个唯一的 ID 和键值对组成。
- **消费者组**：允许多个消费者协同处理消息，确保每条消息只被组内的一个消费者处理（`XGROUP` 命令）。
- **消息 ID**：每条消息都有一个唯一的 ID（如 `timestamp-sequence`），用于排序和去重。
- **ACK 机制**：消费者处理完消息后，需要显式确认（`XACK`），否则消息会被重新投递。
- **PEL**：Pending Entries List，存储 **已分配但未确认（ACK）的消息**，避免消息丢失（`XPENDING` 命令和 `XCLAIM` 命令）。

### 1.3 NSQ 核心组件

- **生产者**：向 NSQ 的 Topic 发布消息。
- **消费者**：订阅 Topic 或 Channel 并处理消息。
- **Topic**：消息的逻辑分类，生产者将消息发送到 Topic。
- **Channel**：Topic 的分组，每个 Channel 可以有多个消费者，消息会被复制到所有 Channel。
- **消息**：NSQ 中的消息是二进制数据，支持多种格式（如 JSON、Protobuf）。
- **ACK 机制**：消费者处理完消息后需要显式确认，否则消息会重新入队。
- **去中心化**：NSQ 是无中心节点的分布式系统，依赖 nsqd（消息处理节点）和 nsqlookupd（服务发现）。

## 2 消息队列的核心特性

Redis Stream 通过 **持久化** 和 **ACK 机制** 保障消息的可靠性，同时支持 **消费组**、**顺序性**、**延迟消息** 及 **死信队列** 机制，确保高效稳定的消息处理。

### 2.1 可靠性

- **持久化**：支持 **AOF（Append-Only File）** 和 **RDB（Redis Database Snapshot）**，即使 Redis 重启也能恢复数据。
- **ACK 机制**：消费者需要 **显式确认**（`XACK`）消息处理成功，否则消息会被视为未完成。
- **Pending Entries List（PEL）**：记录 **未 ACK 消息**，可通过 `XPENDING` 查询并重新分配，避免消息丢失。

### 2.2 消费者组

Redis Stream 提供 Kafka-like 的 **消费组**，实现高效的消息分发：

- **广播模式**：多个消费组 **独立消费**，每个组都能读取 **全部** 消息。
- **组内独占消费**：同一消费组内，消息 **只会被其中一个消费者处理**，避免重复消费。

**消息分配机制**

- **轮询（round-robin）**：默认均衡分发消息给不同的消费者。
- **故障恢复**：消费者崩溃或超时未 ACK 时，可使用 `XCLAIM` 让其他消费者重新领取消息。

### 2.3 消息顺序

- **严格递增的消息 ID**：采用 `<时间戳-序列号>` 格式（如 `1710405654872-0`），确保全局有序。
- **幂等性支持**：
    - 依赖 **唯一 ID** 确保不会重复消费。
    - **PEL 机制** 允许查询未确认消息，避免丢失或重复处理。

### 2.4 延迟消息

Redis Stream 支持 **定时或延迟消费**，但需要应用层处理：

- **存储消息，按时间戳轮询消费**。
- **使用 Sorted Set（ZSET）+ Stream 组合**：
    1. 先将消息存入 **ZSET**，按时间戳排序。
    2. 定时任务查询 `ZRANGEBYSCORE`，取出到期消息并写入 **Stream** 供消费者处理。

### 2.5 死信队列（Dead Letter Queue, DLQ）

死信队列用于存储 **无法正常消费** 的消息，防止数据丢失，并支持后续分析或重试：
- **触发条件**：
    - **未被 ACK**（`XACK` 未执行）。
    - **消费超时**（PEL 中长时间未确认）。
    - **达到最大重试次数**。

Redis Stream **未内置** 死信队列，但可基于 **PEL + XPENDING + XCLAIM** 机制构建：

1. **XPENDING**：查询超时未 ACK 的消息。
2. **XCLAIM**：重新分配给其他消费者，或转移至死信队列。
3. **XADD**：将失败消息存入另一个 Stream 作为死信队列（DLQ）。

> **应用场景**：
> - **异常监控**：统计高失败率的消息，优化业务逻辑。
> - **延迟重试**：定期检查死信队列，决定是否重新投递。
> - **人工干预**：某些业务需手动修正死信消息，再次消费。
