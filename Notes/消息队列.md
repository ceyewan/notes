## 1 消息队列的基本概念

### 1.1 消费队列的作用

消息队列（Message Queue, MQ）在分布式系统中起着**异步解耦、流量调控、提升系统稳定性**的作用。它通过**生产者 - 消费者模式**，将数据暂存到队列中，使得生产者和消费者不必同步执行，从而提高系统效率和容错能力。

- **解耦（Decoupling）**：生产者和消费者不直接通信，而是通过消息队列中转，使两者**相互独立**，降低系统耦合性。（订单系统的库存、支付、物流独立处理）
- **异步处理（Asynchronous Processing）**：生产者发送消息后无需等待消费者处理完成，直接返回，提高响应速度和吞吐量。（邮件短信通知）
- **削峰填谷（Traffic Shaping）**：在**高流量时**，消息队列充当 " 缓冲池 "，防止服务过载；在**低流量时**，消费者逐步消费，保持系统稳定。（秒杀）
- **可靠通信（Reliable Communication）**：提供**消息持久化、重试机制**，确保消息不丢失，提高系统可靠性。（支付订单）
- **流量控制（Rate Limiting）**：控制消息消费速率，避免消费者被高并发流量压垮，平衡系统负载。（日志分析系统）

### 1.2 Redis Stream 核心组件

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250314124222.png)

- **生产者**：向 Stream 中发布消息（`XADD` 命令）。
- **消费者**：从 Stream 中读取消息（`XREAD` 或 `XREADGROUP` 命令）。
- **消息**：Stream 中的每条消息由一个唯一的 ID 和键值对组成。
- **消费者组**：允许多个消费者协同处理消息，确保每条消息只被组内的一个消费者处理（`XGROUP` 命令）。
- **消息 ID**：每条消息都有一个唯一的 ID（如 `timestamp-sequence`），用于排序和去重。
- **ACK 机制**：消费者处理完消息后，需要显式确认（`XACK`），否则消息会被重新投递。
- **PEL**：Pending Entries List，存储 **已分配但未确认（ACK）的消息**，避免消息丢失（`XPENDING` 命令和 `XCLAIM` 命令）。

### 1.3 NSQ 核心组件

- **生产者**：向 NSQ 的 Topic 发布消息。
- **消费者**：订阅 Topic 或 Channel 并处理消息。
- **消息**：支持多种格式（如 JSON、Protobuf），由 **Topic -> Channel** 进行投递。
- **Topic**：消息的逻辑分类，所有消息都需归属于某个 Topic。
- **Channel**：**消息分发单元**，一个 Topic 可有多个 Channel，消息会被**复制**到所有 Channel。
- **ACK 机制**：消费者处理完消息后需要显式确认，否则消息会重新入队。
- **去中心化**：NSQ **无中心节点**，由 `nsqd`（消息处理节点）存储和转发消息，`nsqlookupd` 负责 **服务发现**。

## 2 消息队列的核心特性

Redis Stream 通过 **持久化** 和 **ACK 机制** 保障消息的可靠性，同时支持 **消费组**、**顺序性**、**延迟消息** 及 **死信队列** 机制，确保高效稳定的消息处理。

### 2.1 可靠性

- **持久化**：支持 **AOF（Append-Only File）** 和 **RDB（Redis Database Snapshot）**，即使 Redis 重启也能恢复数据。
- **ACK 机制**：消费者需要 **显式确认**（`XACK`）消息处理成功，否则消息会被视为未完成。
- **Pending Entries List（PEL）**：记录 **未 ACK 消息**，可通过 `XPENDING` 查询并重新分配，避免消息丢失。

### 2.2 消费者组

Redis Stream 提供 Kafka-like 的 **消费组**，实现高效的消息分发：

- **广播模式**：多个消费组 **独立消费**，每个组都能读取 **全部** 消息。
- **组内独占消费**：同一消费组内，消息 **只会被其中一个消费者处理**，避免重复消费。

**消息分配机制**

- **轮询（round-robin）**：默认均衡分发消息给不同的消费者。
- **故障恢复**：消费者崩溃或超时未 ACK 时，可使用 `XCLAIM` 让其他消费者重新领取消息。

### 2.3 消息顺序

- **严格递增的消息 ID**：采用 `<时间戳-序列号>` 格式（如 `1710405654872-0`），确保全局有序。
- **幂等性支持**：
    - 依赖 **唯一 ID** 确保不会重复消费。
    - **PEL 机制** 允许查询未确认消息，避免丢失或重复处理。

### 2.4 延迟消息

Redis Stream 支持 **定时或延迟消费**，但需要应用层处理：

- **存储消息，按时间戳轮询消费**。
- **使用 Sorted Set（ZSET）+ Stream 组合**：
    1. 先将消息存入 **ZSET**，按时间戳排序。
    2. 定时任务查询 `ZRANGEBYSCORE`，取出到期消息并写入 **Stream** 供消费者处理。

### 2.5 死信队列（Dead Letter Queue, DLQ）

死信队列用于存储 **无法正常消费** 的消息，防止数据丢失，并支持后续分析或重试：
- **触发条件**：
    - **未被 ACK**（`XACK` 未执行）。
    - **消费超时**（PEL 中长时间未确认）。
    - **达到最大重试次数**。

Redis Stream **未内置** 死信队列，但可基于 **PEL + XPENDING + XCLAIM** 机制构建：

1. **XPENDING**：查询超时未 ACK 的消息。
2. **XCLAIM**：重新分配给其他消费者，或转移至死信队列。
3. **XADD**：将失败消息存入另一个 Stream 作为死信队列（DLQ）。

> **应用场景**：
> - **异常监控**：统计高失败率的消息，优化业务逻辑。
> - **延迟重试**：定期检查死信队列，决定是否重新投递。
> - **人工干预**：某些业务需手动修正死信消息，再次消费。

## 3 NSQ 分布式消息队列

### 3.1 简介

NSQ 是一个实时分布式消息平台，主要由三个核心组件构成：
 - **nsqd**：这是 NSQ 最核心的消息队列后端模块。它负责接收、存储和发送消息。nsqd 是一个独立的守护进程，能够处理消息的发布和消费。它支持多种消息传输协议，并且能够将消息持久化到磁盘，确保消息的可靠传递。nsqd 还负责管理消息的队列、处理消息的确认和重试机制，确保消息不会丢失。
- **nsqlookupd**：这是 NSQ 中的服务发现与注册中心。它的主要功能是管理 nsqd 节点、topic（主题）和 channel（通道）之间的拓扑映射关系。nsqlookupd 允许生产者和消费者动态地发现可用的 nsqd 节点，并且能够自动处理节点的加入和退出。通过 nsqlookupd，NSQ 能够实现高可用性和负载均衡，确保消息的可靠传递和高效处理。
- **nsqadmin**：这是一个用于实时监控 NSQ 集群的 Web 可视化界面。nsqadmin 提供了一个用户友好的界面，允许管理员和开发者查看和管理 NSQ 集群的状态。通过 nsqadmin，用户可以查看当前的 topic 和 channel 的状态、消息的生产和消费速率、节点的健康状况等信息。nsqadmin 还支持一些管理操作，如创建和删除 topic、查看消息的详细信息等。

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250314124423.png)

**生产者**是消息的发送方，负责将消息发布到 NSQ 中。生产者不需要知道消息的具体存储位置或消费者的信息，它只需要将消息发送到指定的 **Topic** 即可。生产者通过 NSQ 的 API 或客户端库与 nsqd 节点通信，将消息推送到对应的 Topic 中。

**Topic** 是消息的逻辑分类单位，可以理解为一个消息的主题或类别。生产者按照先进先出（FIFO）的顺序将消息发送到特定的 Topic，而消费者则从 Topic 中订阅消息（实际上是通过 Channel 将消息分发给消费者）。

**Channel** 是 Topic 的子单元，用于实现**消息的分发和负载均衡**。每个 Topic 可以有多个 Channel，而每个 Channel 会独立存储一份完整的 Topic 消息。
- **Channel 与 Topic 的关系**：Channel 与 Topic 是一对多的关系。每当 Topic 收到一条新消息时，这条消息会被复制到所有关联的 Channel 中，确保每个 Channel 都拥有一份完整的消息副本。
- **Channel 与消费者的关系**：消费者在订阅消息时，需要指定 Topic 和 Channel。一个 Channel 下的消息会被随机分发给订阅了该 Channel 的消费者，确保每条消息只会被一个消费者处理。
- **负载均衡**：所有订阅了同一个 Channel 的消费者会自动形成一个类似 " 消费者组 " 的机制。消息会被均匀地分发给这些消费者，从而实现负载均衡。
- **全量数据消费**：如果某个消费者需要获取 Topic 中的全量数据，可以订阅一个独立的、不与他人共享的 Channel。这样，该消费者将接收到 Topic 中的所有消息。

消费者是消息的接收方，负责从 NSQ 中获取并处理消息。消费者通过订阅特定的 Topic 和 Channel 来接收消息。

> [!NOTE] 懒创建
> NSQ 与其他消息队列的一个显著区别在于其 Topic 和 Channel 采用了**懒创建机制**，这种设计极大地简化了使用流程。在使用 NSQ 时，开发者无需显式创建 Topic 或 Channel，系统会根据需要自动完成这些操作。具体来说，当 Producer 首次向某个 Topic 发布消息，或者 Consumer 首次订阅某个 Topic 时，该 Topic 会自动创建。同样地，当 Consumer 首次订阅某个 Channel 时，该 Channel 也会自动创建并与对应的 Topic 关联。

### 3.2 NSQD

![image.png](https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250314131620.png)

NSQD 类代表一个 nsqd 节点，封装了以下关键信息：
- **topicMap**：存储当前节点管理的所有 Topic。
- **lookupPeers**：在集群模式下，记录其他 nsqd 节点的信息，用于服务发现和通信。
- **tcpServer**：负责处理客户端的 TCP 请求，支持消息的发布、订阅等操作。

#### 3.2.1 Topic

Topic 是 NSQ 中的一个消息主题，其核心字段包括：
- **channelMap**：存储该 Topic 下的所有 Channel。
- **memoryMsgChan**：用于在内存中传递新消息的通道。当有新消息到达时，首先通过此通道传递。
- **backend**：当 **memoryMsgChan** 容量达到上限时，消息会被持久化到磁盘文件中，确保消息不丢失。当 **memoryMsgChan** 为空时，会从磁盘文件中读取之前存储的消息，重新加载到内存中，确保消息不丢失。

在 NSQ 的 Topic 中，异步启动的 `messagePump` 协程会将消息分发到该 Topic 下的所有 Channel，使用的是**浅拷贝**，从而满足  **发布 - 订阅** " 模式（Pub/Sub）。

#### 3.2.2 Channel

Channel 对应为一个消息频道，

- **memoryMsgChan：**有新消息到达时，在内存中通过此通道向 channel 传递消息
- **backend：当 memoryMsgChan 容量达到上限时**，则通过磁盘文件向 channel 传递消息
- **clients:** 订阅该 channel 的 consumer 集合
- **deferredPQ：**channel 下的延时消息队列，基于小顶堆实现
- **inFlightPQ：**channel 下的待 ack 确认消息队列，基于小顶堆实现
channel 下的 **memoryMsgChan 和 backend** 会同时**被所有订阅了该 channel 的 consumer client goroutine 所接收**，因此 **channel 下的同一条消息只会随机被某个 consumer 消费到**.

#### 3.2.3 deferredPQ

延时队列 deferredQ 和待 ack 队列 inFlightPQ 底层数据结构类似，都是基于时间戳进行排序的小顶堆.
