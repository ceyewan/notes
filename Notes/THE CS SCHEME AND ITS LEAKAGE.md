## 1 Suffix Trees

在本节中，我们介绍了后缀树（Suffix Tree），这是 CS 方案中使用的主要数据结构。

### 1.1 后缀树

设字符串 $S$ 的长度为 $n$。字符串 $S$ 的后缀树 $T_S$ 是一棵具有以下性质的树：

- 该树恰好有 $n$ 个叶节点。
- 除根节点外，每个内部节点至少有两个子节点。
- 每条边都标记为字符串 $S$ 的一个非空子串。
- 对于同一个起始节点的任何两条边，它们的起始字符不同。
- 设 $N$ 是 $T_S$ 的一个内部节点或叶节点。从根节点到节点 $N$ 的路径上的字符串定义为从根到节点 $N$ 的所有边上的字符串的连接。节点 $N$ 存储从字符串 $S$ 中第一次出现的路径字符串的起始索引。

从现在起，我们用 $ind(N)$ 表示存储在节点 $N$ 中的字符串索引，用 $path(N)$ 表示从根节点到节点 $N$ 的路径上的字符串。

### 1.2 多字符串的后缀树

上述描述的后缀树可以推广以支持多个字符串。所得的数据结构称为**广义后缀树**（generalised suffix tree）$1$。广义后缀树与普通后缀树的主要区别在于，广义后缀树中的节点不再仅仅存储匹配的起始索引，而是存储字符串的索引（即子串出现在哪些字符串中）以及匹配的起始位置。为了方便，我们仍将存储在节点中的内容称为索引。图 1 展示了字符串 "hello" 和 "help" 的广义后缀树示例。

尽管 Chase 和 Shen $14$ 仅描述了如何使用其方案搜索单个字符串，但其方案可以很容易地扩展为支持多个字符串。在我们的攻击中，我们考虑了支持多个字符串的版本，但我们的攻击对原始的单字符串版本同样有效。

### 1.3 使用广义后缀树的子串查询

接下来我们说明如何使用表示多个字符串的广义后缀树高效地执行（明文）子串匹配。考虑子串查询 "ell"。通过使用 "ell" 遍历后缀树（图 1），我们会到达节点 $N_9$。尽管节点 $N_9$ 存储的是后缀 "ello" 的起始索引，但由于 "ell" 是 "ello" 的前缀，因此该索引也是子串 "ell" 的起始索引。结果，我们通过遍历后缀树得到了与查询 "ell" 对应的正确响应。

后缀树还支持具有多个匹配项的子串查询。例如，考虑子串查询 "he"。在这种情况下，与其检索存储在节点 $N_2$ 中的索引，不如检索以节点 $N_2$ 为根的子树中所有叶节点存储的索引。由于这些叶节点包含所有以 "he" 开头的后缀的起始索引，因此检索子树中所有叶节点存储的索引即可得到 "he" 的所有匹配项。

### 1.4 广义后缀树图例

1. **ind(N)**
   表示从根节点到节点 $N$ 的路径字符串在原始字符串中的首次出现位置。
   例如：
   - $ind(N_7) = (1, 1)$，因为 "hello" 在第一个字符串的第 1 个位置首次出现。
   - $ind(N_{12}) = (2, 3)$，因为 "lp" 在第二个字符串的第 3 个位置首次出现。

2. **path(N)**
   表示从根节点到节点 $N$ 的完整路径字符串。
   例如：
   - $path(N_7) = "hello"$。

3. **initpath(N)**
   表示从根节点到节点 $N$ 的路径字符串，但最后一条边仅取首字符。
   例如：
   - $initpath(N_7) = "hell"$，因为路径到 $N_7$ 的最后一条边是 "o"，只取 "o" 的首字符。
   - $initpath(N_9) = "ell"$。

4. **leafpos(N)**
   表示以节点 $N$ 为根的子树中最左侧叶节点的位置。
   例如：
   - $leafpos(N_3) = 3$。

5. **num(N)**
   表示以节点 $N$ 为根的子树中叶节点的数量。
   例如：
   - $num(N_3) = 2$，因为 $N_3$ 的子树中有 2 个叶节点。

## 2 The CS Scheme: Building Substring-SSE from Suffix Trees

在本节中，我们展示了 Chase 和 Shen [14] 如何基于后缀树构建其子串 -SSE 方案（Substring-SSE Scheme），称为 CS 方案。按照他们的描述，我们展示了构建子串 -SSE 方案的三个尝试。

---

### 2.1 **第一次尝试**

[14] 提出的第一个想法如下：
设 $F$ 是一个伪随机函数，$\Gamma$ 是一个 CPA 安全的对称加密方案。令 $sk_1$ 是 $F$ 的密钥，$sk_2$ 是 $\Gamma$ 的密钥。令节点 $N$ 是后缀树中的一个非根节点。子串 -SSE 方案执行以下加密操作：

1. 计算伪随机函数值 $t = F_{sk_1}(\text{path}(N))$。
2. 使用对称加密方案加密存储在节点 $N$ 中的索引，得到 $c = \Gamma.\text{Enc}_{sk_2}(\text{ind}(N))$。
3. 将 $(t, c)$ 存储在加密字典 $D$ 中，其中 $t$ 用作键，$c$ 用作值。

上述过程对所有非根节点执行。

该方案允许客户端通过加密查询的形式查询所有后缀树中的路径子串。查询的加密形式为 $e_q = F_{sk_1}(q)$。如果查询的子串 $q$ 是后缀树中的路径之一，则伪随机函数值 $F_{sk_1}(q)$ 存在于加密字典 $D$ 中，对应的值 $D[t]$ 是子串 $q$ 首次匹配的索引的加密值。

需要注意的是，该方案只返回子串 $q$ 首次匹配的索引，因为在加密字典 $D$ 中无法进行树的遍历操作。

> [!NOTE] 伪随机函数
> 使用伪随机函数（PRF）的关键原因在于它能够通过密钥生成计算上无法区分于随机值的输出，从而保护数据隐私和查询内容的安全。相比普通哈希函数，PRF 的输出受密钥控制，攻击者无法通过枚举或暴力破解推断出输入内容，确保查询内容和存储数据的隐秘性。同时，PRF 具有抗碰撞性和密钥依赖性，能够防止数据泄露和错误匹配，是加密场景中不可或缺的安全工具。

### 2.2 返回可能的匹配

将 $\text{initpath}(N)$ 定义为从根节点到节点 $N$ 的边上字符串的连接，但对于最后一条边（最接近 $N$ 的边），仅使用该边上字符串的第一个字符。例如，在图 1 中，$\text{initpath}(N_7) = "hell"$，而 $\text{initpath}(N_9) = "ell"$。

在第二次尝试中，Chase 和 Shen 进行了以下更改：
不再通过 $F_{sk_1}(\text{path}(N))$ 查询节点 $N$，而是通过 $F_{sk_1}(\text{initpath}(N))$ 查询节点。这可以通过计算加密查询 $e_q = (F_{sk_1}(q[1,1]), \dots, F_{sk_1}(q[1,|q|]))$ 来实现。给定 $e_q$，服务器在加密字典 $D$ 中找到与 $q$ 的最长子串匹配的 PRF 值，并返回与之相关联的值。客户端随后解密该值以获得字符串索引 $(i, j)$。之后，客户端将 $(i, j + |q|)$ 发送给服务器，并检索以下加密值（这些值应在设置阶段存储在服务器上）：

$$
\Gamma.\text{Enc}_{sk_2}(S_i[j]), \dots, \Gamma.\text{Enc}_{sk_2}(S_i[j + |q| - 1]),
$$

并检查这些字符的解密结果是否与 $q$ 相同。如果字符匹配，则 $(i, j)$ 是一个匹配的索引。否则，$q$ 在数据库中没有任何匹配项。

### 2.3 返回所有匹配项

一个简单的解决方案是让客户端在加密字典中存储所有匹配项的索引。然而，这种方案在最坏情况下会导致存储需求呈线性增长（相对于服务器存储的字符串长度）。

为了克服这个问题，Chase 和 Shen 利用了以下事实：如果节点 $N$ 是在第二次尝试中匹配查询的节点，那么查询的所有匹配索引必然是节点 $N$ 的子树中叶子节点所存储的索引。因此，只需要将 $N$ 子树的索引信息存储在节点 $N$ 中，以便之后可以访问这些叶子节点。

具体实现如下：
令 $\text{leaf}_i$ 为后缀树中的第 $i$ 个叶子节点。在设置阶段，客户端创建一个加密数组 $L$，其中 $L[i] = \Gamma.\text{Enc}_{sk_2}(\text{ind}(\text{leaf}_i))$。这个索引与加密字典 $D$ 在第二次尝试中为叶子节点存储的索引相同。
对于加密字典 $D$，除了存储第一次出现的索引外，还为每个条目存储子树信息。对于节点 $N$，定义 $\text{leafpos}(N)$ 为 $N$ 子树中最左边叶子节点的位置，定义 $\text{num}(N)$ 为 $N$ 子树中叶子节点的数量。然后，对于字典键 $F_{sk_1}(\text{initpath}(N))$，我们存储 $\Gamma.\text{Enc}_{sk_2}(\text{ind}(N), \text{leafpos}(N), \text{num}(N))$。

加密的子字符串查询过程如下：
令 $q$ 为查询字符串。客户端首先计算 $e_q = (F_{sk_1}(q[1,1]), \dots, F_{sk_1}(q[1,|q|]))$ 并将其发送给服务器。服务器在加密字典 $D$ 中找到与 $q$ 的最长子串匹配的 PRF 值，并返回与之相关联的值。客户端解密该值，得到 $\text{ind}(N), \text{leafpos}(N), \text{num}(N)$，其中 $N$ 是 $q$ 的某个前缀的节点。客户端接着检索

$$
\Gamma.\text{Enc}_{sk_2}(S_i[j]), \dots, \Gamma.\text{Enc}_{sk_2}(S_i[j + |q| - 1]),
$$

并检查这些字符的解密结果是否与 $q$ 相同。如果匹配，客户端进一步检索

$$
L[\text{leafpos}(N)], \dots, L[\text{leafpos}(N) + \text{num}(N) - 1],
$$

并解密它们以获得所有匹配项的索引。如果不匹配，客户端知道查询 $q$ 没有任何匹配项。

### 2.4 进一步的改进

最终的 CS 方案对第三次尝试进行了以下修改，以减少信息泄漏：

- **加密查询令牌**：查询令牌被加密，同时修改了加密字典的内容，使得该方案仅在两个查询具有**共享前缀**时才会泄漏信息。
- **隐藏节点信息**：后缀树的节点度数和节点总数通过填充进行混淆。子节点的顺序通过随机排列进行隐藏。
- **隐藏字符串索引**：字符串的索引通过对加密的密文进行随机排列来隐藏，即 $\Gamma.\text{Enc}_{sk_2}(S_1[1]), \dots, \Gamma.\text{Enc}_{sk_2}(S_N[|S_N|])$ 被随机打乱。

## 3 Leakage Profile of the CS Scheme

我们现在描述 CS 方案的泄漏特性，并通过一个示例来说明泄漏情况。

---

### 3.1 **泄漏描述**

在**初始化阶段（Setup）**，该方案会泄漏字符串的总长度。具体来说，如果数据库 $\text{DB} = (S_1, \dots, S_N)$，则泄漏如下信息：

$$
\mathcal{L}_{\text{Setup}}(\text{DB}) = \sum_{i=1}^N |S_i|
$$

我们现在关注**查询阶段**（$\mathcal{L}_{\text{EQuery}}$）的泄漏情况。对于一个子串查询 $q$，令 $\text{initpath}(N)$ 表示后缀树 $T$ 中节点 $N$ 的最长前缀路径。当处理查询 $q$ 时，该方案泄漏以下信息：
- 查询的长度 $|q|$；
- 前缀路径的长度 $|\text{initpath}(N)|$。

对于一系列查询 $q_1, \dots, q_l$，CS 方案额外泄漏以下三种模式：

---

#### 3.1.1 **查询前缀模式（Query Prefix Pattern, QP）**

- **定义**：查询 $q_l$ 的查询前缀模式 $\text{QP}(\text{DB}, q_1, \dots, q_l)$ 表示查询 $q_l$ 所访问的每个节点是否也被之前的查询访问过。
- **表示**：该模式可以表示为一个 $l \times n_i$ 的矩阵，其中 $n_i$ 是查询 $q_l$ 访问的节点数。
- **矩阵定义**：
  - 如果查询 $q_i$ 访问了查询 $q_l$ 所访问的第 $j$ 个节点，则矩阵的第 $(i, j)$ 项为 1；
  - 否则为 0。

---

#### 3.1.2 **叶节点交集模式（Leaf Intersection Pattern, LP）**

- **定义**：查询 $q_l$ 的叶节点交集模式 $\text{LP}(\text{DB}, q_1, \dots, q_l)$ 表示查询 $q_l$ 检索到的叶节点索引是否也被之前的查询检索到。
- **表示**：该模式可以表示为一个 $l \times m_j$ 的矩阵，其中 $m_j$ 是查询 $q_l$ 检索到的叶节点数。
- **矩阵定义**：
  - 令 $r_1: [m_j] \to [m_j]$ 为一个随机排列；
  - 如果查询 $q_i$ 检索到的 $r_1(i)$-th 叶节点也被查询 $q_l$ 检索到，则矩阵的第 $(i, j)$ 项为 1；
  - 否则为 0。

---

#### 3.1.3 **索引交集模式（Index Intersection Pattern, IP）**

- **定义**：查询 $q_l$ 的索引交集模式 $\text{IP}(\text{DB}, q_1, \dots, q_l)$ 表示查询 $q_l$ 检索到的字符串索引是否也被之前的查询检索到。
- **表示**：该模式可以表示为一个 $l \times |q_l|$ 的矩阵。
- **矩阵定义**：
  - 令 $r_2: [|q_l|] \to [|q_l|]$ 为一个随机排列；
  - 如果查询 $q_i$ 检索到的第 $i$-th 字符串索引也被查询 $q_l$ 检索到，则矩阵的第 $(i, j)$ 项为 1；
  - 否则为 0。

---

以上描述了 CS 方案在初始化和查询阶段的泄漏特性及其表示方式。

### 3.2 使用示例说明泄漏情况

为说明该方案的泄漏情况，考虑数据库 $\text{DB} = ("hello", "help")$。服务器通过 $|L|$ 知道存在 9 个叶节点，这正是字符串的总长度。

---

#### 3.2.1 **查询示例**

现在，考虑查询 $q_1 = "ello"$ 和 $q_2 = "elp"$。服务器可以推断出以下信息：

1. **查询长度**
   服务器知道 $|q_1| = 4$ 和 $|q_2| = 3$，因为服务器分别看到了 4 和 3 个加密的伪随机函数（PRF）值。

2. **前缀路径长度**
   服务器知道 $|\text{initpath}("ello")| = |\text{"ell"}| = 3$ 和 $|\text{initpath}("elp")| = |\text{"elp"}| = 3$，因为用于检索这些初始路径相关节点的 PRF 值揭示了 PRF 输入的长度为 3。

---

#### 3.2.2 **半诚实对手的推断**

当同时观察 $q_1$ 和 $q_2$ 时，半诚实对手可以立即推断出以下信息：

1. **查询前缀模式（Query Prefix Pattern）**
   - 服务器观察到节点 $N_3$ 是两个查询的共享前缀，因为它被两个查询都访问了。
   - 服务器还观察到 $|\text{initpath}(N_3)| = 1$，因为该节点必须通过 $F_{\text{sk}_1}(q_1[1, 1])$ 或 $F_{\text{sk}_1}(q_2[1, 1])$ 检索。

2. **叶节点交集模式（Leaf Intersection Pattern）**
   - 服务器没有看到任何叶节点交集，因为两个查询访问了不相交的节点集合（分别为 $\{N_9\}$ 和 $\{N_{10}\}$）。
   - 然而，服务器可以推断出两个查询的查询响应大小均为 1。

3. **索引交集模式（Index Intersection Pattern）**
   - 服务器没有看到任何索引交集，因为第一个字符串在 $\text{initpath}(q_1)$ 的首次出现，而第二个字符串在 $\text{initpath}(q_2)$ 的首次出现。

---

以上示例清晰地展示了该方案在处理查询时的泄漏情况及其对服务器的推断能力的影响。
