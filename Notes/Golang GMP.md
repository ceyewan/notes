## 1 基础概念

### 1.1 **进程（Process）**

- **定义**：进程是操作系统分配资源的基本单位。每个进程都有独立的内存空间、文件描述符、环境变量等资源。
- **特点**：
    - 进程之间相互隔离，一个进程崩溃不会影响其他进程。
    - 进程间通信（IPC）需要通过管道、消息队列、共享内存等机制。
    - 创建和切换进程的开销较大，因为需要分配独立的内存空间和资源。
- **应用场景**：适合需要强隔离的任务，例如运行独立的应用程序。

---

### 1.2 **线程（Thread）**

- **定义**：线程是进程内的执行单元，是操作系统调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。
- **特点**：
    - 线程间共享内存，通信更加高效，但也容易引发竞争条件（Race Condition）。
    - 创建和切换线程的开销比进程小，但仍需要操作系统介入。
    - 线程的数量受限于操作系统的资源限制。
- **应用场景**：适合需要并发执行的任务，例如多线程服务器。

---

### 1.3 **协程（Coroutine）**

- **定义**：协程是一种用户态的轻量级线程，由程序员显式控制调度，而不是由操作系统调度。
- **特点**：
     - 协程的切换不需要操作系统的介入，开销极小。
    - 协程是单线程的，通过协作式调度实现并发，避免了多线程的竞争问题。
    - 协程的执行是顺序的，需要显式地让出控制权（yield）。
- **应用场景**：适合高并发的 I/O 密集型任务，例如网络爬虫、异步编程。

---

### 1.4 **Goroutine**

- **定义**：Goroutine 是 Go 语言中的并发执行单元，是一种轻量级的线程实现，由 Go 运行时（runtime）管理。
- **特点**：
    - Goroutine 的创建和切换开销极小，通常只需要几 KB 的栈空间。
    - Goroutine 由 Go 运行时调度，采用 M:N 调度模型（多个 Goroutine 映射到多个操作系统线程）。
    - Goroutine 之间通过通道（Channel）进行通信，避免了共享内存的竞争问题。
    - Goroutine 的数量可以轻松达到数十万甚至更多。
- **应用场景**：适合高并发的任务，尤其是 Go 语言中的并发编程。

---

### 1.5 对比总结

| 特性       | 进程            | 线程     | 协程      | Goroutine |
| -------- | ------------- | ------ | ------- | --------- |
| **资源隔离** | 完全隔离          | 共享进程资源 | 共享线程资源  | 共享线程资源    |
| **调度方式** | 操作系统调度        | 操作系统调度 | 用户态调度   | Go 运行时调度  |
| **创建开销** | 大             | 中等     | 小       | 极小        |
| **通信方式** | IPC（管道、共享内存等） | 共享内存   | 共享内存    | Channel   |
| **并发能力** | 低             | 中等     | 高       | 极高        |
| **典型应用** | 独立应用程序        | 多线程服务器 | 异步编程、爬虫 | Go 并发编程   |

---

## 2 GMP 概述

**GMP 架构** 是 Go 运行时（runtime）用来管理和调度 Goroutine 的核心机制。GMP 是 **Goroutine**、**Machine**（线程）和 **Processor**（处理器）的缩写，它们共同协作，实现了高效的并发调度。

### 2.1 **Goroutine（G）**

- **定义**：Goroutine 是 Go 语言中的并发执行单元，是 golang 中对协程的抽象；
- **特点**：
    - 每个 Goroutine 只需要几 KB 的栈空间，且栈空间可以动态扩展。
    - Goroutine 的创建和切换开销极小。
    - Goroutine 的数量可以轻松达到数十万甚至更多。

### 2.2 **Machine（M）**

- **定义**：M 是操作系统线程（OS Thread）的抽象，由 Go 运行时管理。
- **特点**：
    - M 负责执行 Goroutine 的代码。
    - M 的数量通常与 CPU 核心数相关，但可以通过 `GOMAXPROCS` 调整。
    - M 与 Goroutine 之间是多对多的关系。

### 2.3 **Processor（P）**

- **定义**：P 是 Goroutine 的执行上下文，负责调度 Goroutine 到 M 上执行。
- **特点**：
    - P 的数量由 `GOMAXPROCS` 决定，默认等于 CPU 核心数。
    - 每个 P 维护一个本地 Goroutine 队列（Local Run Queue）。
    - P 是 Goroutine 和 M 之间的桥梁，负责将 Goroutine 分配给 M 执行。

---
