## 1 分布式微服务即时通讯系统

在这个分布式微服务即时通讯系统的设计中，我采用了四层架构，分别包括 **API 层**、**Logic 层**、**Task 层** 和 **Connect 层**。为了提升系统的性能和可扩展性，我在 **Logic 层** 和 **Connect 层** 分别实现了 RPC 服务器，分别称为 **LogicRPC** 和 **ConnectRPC**。系统支持单聊消息和群聊消息。

首先，**API 层** 基于 **Gin** 框架，作为系统的 HTTP 入口，负责处理用户登录、注册等请求。这些请求通过 **gRPC** 调用 **LogicRPC**，由 **Logic 层** 处理具体的业务逻辑。**Logic 层** 不仅负责用户认证和消息处理，还通过 **Redis** 维护用户状态，并利用 **Redis Stream** 作为高吞吐量的消息队列，实现实时消息的投递与存储分离。

在 **Task 层**，我实现了两种消息处理逻辑：一个消费者组通过调用 **ConnectRPC**，将消息及时投递到 **Connect 层**，确保消息的低延迟推送；另一个消费者组则异步读取消息，并将其持久化到 **MySQL** 中，保证数据的可靠性。

**Connect 层** 通过 **WebSocket** 与用户建立长连接，确保消息的低延迟推送。当用户登录后，系统会与 **Connect 层** 建立 WebSocket 长连接。**Connect 层** 通过 **LogicRPC** 进行用户状态管理，确保消息的精准投递。**Task 层** 从 **Redis Stream** 读取消息后，通过 **ConnectRPC** 将消息投递到 **Connect 层**，并最终推送给用户。

为了增强系统的可扩展性，我采用了 **etcd** 进行动态服务发现，支持集群的扩展与自动负载均衡。同时，系统基于 **Docker Compose** 进行容器化部署，确保弹性伸缩和高效的资源利用。

最终，该系统能够支持 **5W+ QPS**，消息投递延迟稳定在 **50ms** 以内，并具备秒级故障恢复能力，能够高效满足大规模用户的实时通讯需求。

Q：为什么要实现四层架构？你有什么考量？
1. 职责分离与模块化
2. 性能优化与高可用性
3. 开发与部署灵活
4. 后续扩展，如 Task 层增加消息批量处理、延迟投递、消息审计监控功能；Logic 层增加消息撤回、已读回执功能。

Q：如何确保消息唯一的投递？

- **使用 MurmurHash 哈希消息内容**，将 `userID + hash` 作为 Redis 的 key，并设置过期时间。
- **检查 Redis 中的重复 key**，如果存在，则判定为重复消息，拒绝投递。
- **生成分布式唯一 ID**，使用雪花算法为消息生成唯一 ID，确保消息在分布式系统中的唯一性。
- **投递到支持消息去重的消息队列**，如 Kafka 或 RabbitMQ 的幂等性生产者，配置消息的唯一 ID，防止重复投递。
- **增加幂等性检查**，在处理消息前，检查 MySQL 中是否已记录该消息 ID，确保消息只被处理一次。
- **结合 Redis 和消息队列**，通过双重机制确保消息的唯一投递和幂等性处理。

Q：有哪些应对高并发、提高容错率的办法？

- etcd 服务动态注册和发现，k8s 弹性伸缩
- 健康检查：心跳机制、HTTP 健康检查接口
- 熔断降级：当服务调用失败率达到阈值时，触发熔断，直接返回降级结果（默认值）
- 令牌桶限流：限制单位时间内的请求量，超出限制的请求被拒绝或排队。
- 负载均衡策略：一致性哈希、结合服务监控选择最佳服务实例来提供服务
- 服务监控、日志分析（普罗米修斯、ELK 等）：实时监控系统性能，分析日志定位问题。
- 消息队列：将操作异步化，减少请求响应时间，流量削峰。

**ELK** 是一个流行的日志管理和分析技术栈，由三个开源工具组成：

1. **Elasticsearch**：分布式搜索和分析引擎，用于存储和快速检索日志数据。
2. **Logstash**：数据收集和处理管道，用于接收、解析和转换日志数据。
3. **Kibana**：数据可视化工具，用于在 Web 界面中展示和分析日志数据。

Q：性能瓶颈分析？

1. 消息的反复序列化与反序列化
2. 内存、CPU 资源的竞争、IO 吞吐量
3. RPC 调用的性能瓶颈，流式调用、负载均衡

## 2 核心块

### 2.1 Golang 底层原理

   - **Go 语言的特点**：并发模型、垃圾回收、静态类型、编译型语言等。
   - **Go 的并发模型**：Goroutine、Channel、Select 语句。
   - **Go 的错误处理**：`error` 接口、`panic` 和 `recover`。
   - **Go 的包管理**：`go mod`、依赖管理、包的导入与导出。
   - **Slice 底层原理**：
     - Slice 的底层数据结构（数组指针、长度、容量）。
     - Slice 的扩容机制（何时扩容、扩容策略）。
     - Slice 与数组的区别。
   - **Map 底层原理**：
     - Map 的底层实现（哈希表、桶结构）。
     - Map 的扩容机制（负载因子、渐进式扩容）。
     - Map 的并发安全问题。
   - **String 底层原理**：
     - String 的不可变性。
     - String 与 `[]byte` 的转换。
   - **Struct 底层原理**：
     - 内存对齐（alignment）、字段顺序对内存布局的影响。
     - 空结构体 `struct{}` 的作用。
   - **Goroutine 调度**：
     - Go 调度器（GMP 模型）。
     - Goroutine 的创建、调度、阻塞与唤醒。
   - **Channel 底层原理**：
     - Channel 的底层数据结构（环形队列、等待队列）。
     - Channel 的阻塞与非阻塞操作。
     - Channel 的关闭与 `select` 语句。
   - **同步原语**：
     - `sync.Mutex` 和 `sync.RWMutex` 的底层实现。
     - `sync.WaitGroup` 的使用与原理。
     - `sync.Once` 的实现原理。
   - **sync.Map 底层原理**：
     - `sync.Map` 的设计思想与适用场景。
     - `sync.Map` 的底层实现（读写分离、原子操作）。
   - **Go 的内存管理**：
     - 栈与堆的区别。
     - 逃逸分析（Escape Analysis）及其作用。
   - **Go 的垃圾回收机制**：
     - 三色标记清除算法（Tri-color Mark and Sweep）。
     - STW（Stop The World）及其优化。
     - GC 触发条件与调优。
   - **接口底层原理**：
     - 接口的底层实现（`iface` 和 `eface`）。
     - 接口的动态派发机制。
   - **反射**：
     - `reflect` 包的使用。
     - 反射的性能开销与适用场景。
   - **性能分析工具**：
     - `pprof` 的使用（CPU、内存、Goroutine 分析）。
     - `trace` 工具的使用。
   - **性能优化技巧**：
     - 减少内存分配、避免不必要的锁竞争、优化 Goroutine 数量等。
   - **Context 包**：
     - `context` 包的使用场景与实现原理。
     - `context` 的取消、超时、值传递。
   - **net/http 包**：
     - HTTP 服务器的实现与优化。
     - HTTP 客户端的超时控制与连接池。
   - **encoding/json 包**：
     - JSON 的序列化与反序列化。
     - 自定义序列化与反序列化。
   - **Go 的编译过程**：
     - 从源码到可执行文件的编译流程。
     - 编译器优化（内联、逃逸分析等）。
   - **Go 的运行时**：
     - 运行时调度器、垃圾回收器、内存分配器等。
     - `runtime` 包的使用与调试。
   - **并发模式**：
     - Worker Pool、Pipeline、Fan-in/Fan-out 等并发模式。
   - **设计模式**：
     - Go 中常用的设计模式（单例模式、工厂模式、装饰器模式等）。
   - **Go 的测试工具**：
     - `go test`、`testing` 包的使用。
     - 单元测试、基准测试、性能测试。
   - **Go 的代码格式化与静态分析**：
     - `gofmt`、`go vet`、`golint` 等工具的使用。
   - **Go 的构建与部署**：
     - 跨平台编译、Docker 镜像构建、CI/CD 集成
   - **项目中的并发问题**：
     - 如何解决并发竞争、死锁、资源泄漏等问题。
   - **性能调优经验**：
     - 如何定位和解决性能瓶颈。
   - **错误处理与日志管理**：
     - 如何设计合理的错误处理机制与日志系统。
   - **Go 的优缺点**：
     - Go 的优势与局限性，与其他语言的对比。
   - **Go 的适用场景**：
     - 什么场景下适合使用 Go，什么场景下不适合。
   - **Go 的学习路径**：
     - 如何深入学习 Go，推荐的学习资源与实践方法。

### 2.2 操作系统

   - **进程调度器**：
     - Linux 调度器的演变（O(1) 调度器、CFS 调度器）。
     - CFS（Completely Fair Scheduler）的工作原理（虚拟运行时间、红黑树）。
   - **调度策略**：
     - 实时调度策略（`SCHED_FIFO`、`SCHED_RR`）。
     - 普通调度策略（`SCHED_NORMAL` 或 `SCHED_OTHER`）。
     - 调度优先级（`nice` 值、`rt_priority`）。
   - **多核调度**：
     - CPU 亲和性（`taskset`、`cpuset`）。
     - 负载均衡机制。
   - **上下文切换**：
     - 上下文切换的开销与优化。
     - 进程切换与线程切换的区别。

   - **虚拟内存**：
     - 虚拟地址空间与物理内存的映射。
     - 页表与多级页表。
   - **内存分配**：
     - 伙伴系统（Buddy System）与 Slab 分配器。
     - `malloc` 和 `free` 的底层实现（`brk`、`mmap`）。
   - **内存回收**：
     - 页面置换算法（LRU、Clock 算法）。
     - OOM（Out of Memory）机制与 `oom_score`。
   - **内存映射**：
     - `mmap` 的原理与使用场景。
     - 文件映射与匿名映射。
   - **内存泄漏与检测**：
     - 如何检测内存泄漏（`valgrind`、`pmap`）。
     - 内存泄漏的常见原因与避免方法。

   - **多线程编程**：
     - 线程的创建与同步（`pthread_create`、`pthread_join`）。
     - 线程同步机制（互斥锁、条件变量、读写锁）。
   - **多进程编程**：
     - 进程的创建与通信（`fork`、`exec`、`wait`）。
     - 进程间通信（IPC）机制（管道、消息队列、共享内存、信号量）。
   - **异步编程**：
     - 异步 I/O（`aio_read`、`aio_write`）。
     - 事件驱动模型（`epoll`、`select`、`poll`）。
   - **并发问题**：
     - 死锁、竞态条件、资源泄漏的检测与避免。
     - 并发性能优化（减少锁竞争、无锁编程）。

   - **性能分析工具**：
     - `top`、`htop`、`vmstat`、`iostat` 的使用。
     - `perf`、`strace`、`gdb` 的使用。
   - **性能瓶颈定位**：
     - CPU 瓶颈、内存瓶颈、I/O 瓶颈的定位与优化。
   - **系统调优**：
     - 内核参数调优（`sysctl`、`/proc` 文件系统）。
     - 文件系统调优、网络调优。

   - **系统调用**：
     - 系统调用的工作原理（用户态与内核态的切换）。
     - 常见的系统调用（`fork`、`exec`、`mmap`、`ioctl`）。
   - **内核模块**：
     - 内核模块的编写与加载（`insmod`、`rmmod`）。
     - 内核模块的调试与优化。
   - **内核同步机制**：
     - 内核中的锁机制（自旋锁、信号量、RCU）。
     - 内核中的原子操作与内存屏障。

   - **容器与虚拟化**：
     - Docker 与 Kubernetes 的底层原理（cgroups、namespaces）。
     - 虚拟化技术（KVM、Xen、QEMU）。
   - **网络编程**：
     - TCP/IP 协议栈、Socket 编程。
     - 高性能网络框架（如 `libevent`、`libuv`）。
   - **安全机制**：
     - Linux 的安全模块（SELinux、AppArmor）。
     - 权限管理与安全加固。

### 2.3 计算机网络

   - **协议栈分层**：
     - OSI 七层模型与 TCP/IP 四层模型的对应关系。
     - 各层的功能与协议（物理层、数据链路层、网络层、传输层、应用层）。
   - **网络层**：
     - IP 协议（IPv4、IPv6）。
     - IP 地址与子网划分（CIDR）。
     - ARP 协议与路由选择。
   - **传输层**：
     - TCP 协议：
       - TCP 的三次握手与四次挥手。
       - TCP 的可靠性机制（序列号、确认应答、超时重传）。
       - TCP 的流量控制（滑动窗口）与拥塞控制（慢启动、拥塞避免、快速重传、快速恢复）。
     - UDP 协议：
       - UDP 的特点与适用场景。
       - UDP 的可靠性实现（应用层实现）。
   - **应用层**：
     - HTTP/HTTPS、FTP、DNS、SMTP 等协议的工作原理。
     - HTTP/1.1、HTTP/2、HTTP/3 的演进与优化。

   - **Socket 基础**：
     - Socket 的概念与类型（流式 Socket、数据报 Socket、原始 Socket）。
     - Socket 的创建、绑定、监听、连接、发送与接收。
   - **TCP Socket 编程**：
     - 服务器端与客户端的编程模型（`socket`、`bind`、`listen`、`accept`、`connect`）。
     - 多线程与多进程模型下的 Socket 编程。
   - **UDP Socket 编程**：
     - UDP 服务器与客户端的编程模型。
     - UDP 的广播与多播。
   - **Socket 选项**：
     - `setsockopt` 与 `getsockopt` 的使用（超时、缓冲区大小、重用地址等）。
   - **Socket 编程中的常见问题**：
     - 粘包与拆包问题。
     - 连接超时与重试机制。
     - 非阻塞 Socket 与异步 I/O。

   - **I/O 多路复用**：
     - 多路复用的概念与适用场景。
     - `select`、`poll`、`epoll` 的区别与优缺点。
   - **Epoll 的工作原理**：
     - Epoll 的三种工作模式（水平触发 LT、边缘触发 ET）。
     - Epoll 的底层实现（红黑树、就绪队列）。
   - **Epoll 的使用**：
     - `epoll_create`、`epoll_ctl`、`epoll_wait` 的使用。
     - Epoll 与非阻塞 Socket 的结合。
   - **Epoll 的性能优化**：
     - 减少系统调用、优化事件处理逻辑。
     - Epoll 在高并发场景下的性能表现。
 - 惊群

   - **多线程模型**：
     - 每个连接一个线程的模型。
     - 线程池模型。
   - **多进程模型**：
     - 每个连接一个进程的模型。
     - 进程池模型。
   - **Reactor 模型**：
     - Reactor 模式的工作原理。
     - 单 Reactor 单线程、单 Reactor 多线程、多 Reactor 多线程的实现。
   - **Proactor 模型**：
     - Proactor 模式的工作原理。
     - Proactor 与 Reactor 的区别。

   - **TCP 性能优化**：
     - TCP 参数调优（`tcp_nodelay`、`tcp_cork`、`tcp_syncookies`）。
     - 减少 TCP 连接的建立与关闭开销（长连接、连接池）。
   - **网络缓冲区优化**：
     - 发送缓冲区与接收缓冲区的大小调整。
     - 零拷贝技术（`sendfile`、`splice`）。
   - **高并发优化**：
     - 减少上下文切换、减少锁竞争。
     - 使用高效的数据结构与算法。

   - **高并发网络服务**：
     - 如何设计一个高并发的网络服务（如 Web 服务器、消息队列）。
     - 如何解决网络服务中的性能瓶颈。
   - **网络协议实现**：
     - 是否实现过自定义的网络协议。
     - 如何保证协议的可靠性与高效性。
   - **网络调试与问题排查**：
     - 如何排查网络连接问题、性能问题。
     - 使用 `tcpdump`、`Wireshark` 等工具进行网络抓包与分析。

   - **QUIC 协议**：
     - QUIC 的工作原理与优势。
     - QUIC 与 TCP 的对比。
   - **CDN 与负载均衡**：
     - CDN 的工作原理与优化。
     - 负载均衡算法与实现（轮询、加权轮询、一致性哈希）。


